{
  "api/Bunit.Asserting.ActualExpectedAssertException.html": {
    "href": "api/Bunit.Asserting.ActualExpectedAssertException.html",
    "title": "Class ActualExpectedAssertException | bUnit",
    "keywords": "Class ActualExpectedAssertException Namespace Bunit.Asserting Assembly bunit.dll Represents a generic assert exception used when an actual result does not match an expected result. public class ActualExpectedAssertException : Exception, ISerializable Inheritance object Exception ActualExpectedAssertException Implements ISerializable Derived HtmlEqualException Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ActualExpectedAssertException(string, string, string, string, string) Initializes a new instance of the ActualExpectedAssertException class. public ActualExpectedAssertException(string actual, string expected, string actualText, string expectedText, string message) Parameters actual string The actual result. expected string The expected result. actualText string A text explaining the actual result. expectedText string A text explaining the expected result. message string An error message explaining the context of the assertion."
  },
  "api/Bunit.Asserting.AssertionMethodAttribute.html": {
    "href": "api/Bunit.Asserting.AssertionMethodAttribute.html",
    "title": "Class AssertionMethodAttribute | bUnit",
    "keywords": "Class AssertionMethodAttribute Namespace Bunit.Asserting Assembly bunit.dll Add this attribute to assertion methods to indicate to 3rd party analyzers that the method is an assertion method. See more here: https://rules.sonarsource.com/csharp/RSPEC-2699. [AttributeUsage(AttributeTargets.Method)] public sealed class AssertionMethodAttribute : Attribute Inheritance object Attribute AssertionMethodAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors AssertionMethodAttribute() public AssertionMethodAttribute()"
  },
  "api/Bunit.Asserting.html": {
    "href": "api/Bunit.Asserting.html",
    "title": "Namespace Bunit.Asserting | bUnit",
    "keywords": "Namespace Bunit.Asserting Classes ActualExpectedAssertException Represents a generic assert exception used when an actual result does not match an expected result. AssertionMethodAttribute Add this attribute to assertion methods to indicate to 3rd party analyzers that the method is an assertion method. See more here: https://rules.sonarsource.com/csharp/RSPEC-2699."
  },
  "api/Bunit.BunitContext.html": {
    "href": "api/Bunit.BunitContext.html",
    "title": "Class BunitContext | bUnit",
    "keywords": "Class BunitContext Namespace Bunit Assembly bunit.dll A test context is a factory that makes it possible to create components under tests. public class BunitContext : IDisposable, IAsyncDisposable Inheritance object BunitContext Implements IDisposable IAsyncDisposable Derived TestContext Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitContext() Initializes a new instance of the BunitContext class. public BunitContext() Properties ComponentFactories Gets the ComponentFactoryCollection. Factories added to it will be used to create components during testing, starting with the last added factory. If no factories in the collection can create a requested component, then the default Blazor factory is used. public ComponentFactoryCollection ComponentFactories { get; } Property Value ComponentFactoryCollection DefaultWaitTimeout Gets or sets the default wait timeout used by \"WaitFor\" operations, i.e. WaitForAssertion<TComponent>(IRenderedComponent<TComponent>, Action, TimeSpan?), and JSInterop invocation handlers that have not been configured with results. public static TimeSpan DefaultWaitTimeout { get; set; } Property Value TimeSpan Remarks The default is 1 second. JSInterop Gets bUnits JSInterop, that allows setting up handlers for InvokeAsync<TValue>(string, object[]) invocations that components under tests will issue during testing. It also makes it possible to verify that the invocations has happened as expected. public BunitJSInterop JSInterop { get; } Property Value BunitJSInterop RenderTree Gets the RootRenderTree that all components rendered with the Render<TComponent>() methods, are rendered inside. public RootRenderTree RenderTree { get; } Property Value RootRenderTree Remarks Use this to add default layout- or root-components which a component under test should be rendered under. Renderer Gets the renderer used by the test context. public BunitRenderer Renderer { get; } Property Value BunitRenderer Services Gets the service collection and service provider that is used when a component is rendered by the test context. public BunitServiceProvider Services { get; } Property Value BunitServiceProvider Methods AddAuthorization() Adds the appropriate Blazor authentication and authorization services to the BunitServiceProvider to enable an authenticated user, as well as adding the CascadingAuthenticationState component to the test contexts render tree. public BunitAuthorizationContext AddAuthorization() Returns BunitAuthorizationContext AddBunitPersistentComponentState() Adds and returns a BunitPersistentComponentState to the services of this BunitContext. public BunitPersistentComponentState AddBunitPersistentComponentState() Returns BunitPersistentComponentState The added BunitPersistentComponentState. BuildRenderTree(RenderTreeBuilder) Dummy method required to allow Blazor's compiler to generate C# from .razor files. protected virtual void BuildRenderTree(RenderTreeBuilder builder) Parameters builder RenderTreeBuilder Dispose() public void Dispose() Dispose(bool) Disposes of the test context resources, in particular it disposes the Services service provider. protected virtual void Dispose(bool disposing) Parameters disposing bool Set to true if called from Dispose(), false if called from a finalizer.f. Remarks The disposing parameter should be false when called from a finalizer, and true when called from the Dispose() method. In other words, it is true when deterministically called and false when non-deterministically called. DisposeAsync() public ValueTask DisposeAsync() Returns ValueTask DisposeAsyncCore() Disposes of the test context resources that are asynchronous, in particular it disposes the Services service provider.s protected virtual ValueTask DisposeAsyncCore() Returns ValueTask DisposeComponentsAsync() Disposes all components rendered via this BunitContext. public Task DisposeComponentsAsync() Returns Task Render(RenderFragment) Renders the renderFragment and returns it as a IRenderedComponent<TComponent>. public virtual IRenderedComponent<ContainerFragment> Render(RenderFragment renderFragment) Parameters renderFragment RenderFragment The render fragment to render. Returns IRenderedComponent<ContainerFragment> The IRenderedComponent<TComponent>. RenderComponent<TComponent>() Use Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) instead. [Obsolete(\"Use Render instead.\", true, UrlFormat = \"https://bunit.dev/docs/migrations\")] public IRenderedComponent<TComponent> RenderComponent<TComponent>() where TComponent : IComponent Returns IRenderedComponent<TComponent> Type Parameters TComponent RenderComponent<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) Use Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) instead. [Obsolete(\"Use Render instead.\", true, UrlFormat = \"https://bunit.dev/docs/migrations\")] public IRenderedComponent<TComponent> RenderComponent<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>? parameterBuilder) where TComponent : IComponent Parameters parameterBuilder Action<ComponentParameterCollectionBuilder<TComponent>> Returns IRenderedComponent<TComponent> Type Parameters TComponent Render<TComponent>(RenderFragment) Renders the renderFragment and returns the first TComponent in the resulting render tree. public virtual IRenderedComponent<TComponent> Render<TComponent>(RenderFragment renderFragment) where TComponent : IComponent Parameters renderFragment RenderFragment The render fragment to render. Returns IRenderedComponent<TComponent> The RenderedComponent<TComponent>. Type Parameters TComponent The type of component to find in the render tree. Remarks Calling this method is equivalent to calling Render(renderFragment).FindComponent<TComponent>(). Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) Instantiates and performs a first render of a component of type TComponent. public virtual IRenderedComponent<TComponent> Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>? parameterBuilder = null) where TComponent : IComponent Parameters parameterBuilder Action<ComponentParameterCollectionBuilder<TComponent>> The ComponentParameterBuilder action to add type safe parameters to pass to the component when it is rendered. Returns IRenderedComponent<TComponent> The rendered TComponent. Type Parameters TComponent Type of the component to render. SetRendererInfo(RendererInfo?) Sets the RendererInfo for the renderer. public void SetRendererInfo(RendererInfo? rendererInfo) Parameters rendererInfo RendererInfo"
  },
  "api/Bunit.BunitJSInterop.html": {
    "href": "api/Bunit.BunitJSInterop.html",
    "title": "Class BunitJSInterop | bUnit",
    "keywords": "Class BunitJSInterop Namespace Bunit Assembly bunit.dll Represents an bUnit's implementation of Blazor's JSInterop. public class BunitJSInterop Inheritance object BunitJSInterop Derived BunitJSModuleInterop Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop) BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop, InvocationMatcher, bool) BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop, string) BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop, string, InvocationMatcher) BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop, string, object?[]) BunitJSInteropSetupExtensions.SetupVoid(BunitJSInterop) BunitJSInteropSetupExtensions.SetupVoid(BunitJSInterop, InvocationMatcher, bool) BunitJSInteropSetupExtensions.SetupVoid(BunitJSInterop, string, InvocationMatcher) BunitJSInteropSetupExtensions.SetupVoid(BunitJSInterop, string, params object?[]?) BunitJSInteropSetupExtensions.Setup<TResult>(BunitJSInterop) BunitJSInteropSetupExtensions.Setup<TResult>(BunitJSInterop, InvocationMatcher, bool) BunitJSInteropSetupExtensions.Setup<TResult>(BunitJSInterop, string, InvocationMatcher) BunitJSInteropSetupExtensions.Setup<TResult>(BunitJSInterop, string, params object?[]?) BunitJSInteropSetupExtensions.TryGetInvokeHandler<TResult>(BunitJSInterop, string, params object?[]?) BunitJSInteropSetupExtensions.TryGetInvokeVoidHandler(BunitJSInterop, string, params object?[]?) BunitJSInteropSetupExtensions.TryGetModuleJSInterop(BunitJSInterop, string, params object?[]?) FocusAsyncAssertJSInteropExtensions.VerifyFocusAsyncInvoke(BunitJSInterop, int, string?) FocusAsyncAssertJSInteropExtensions.VerifyFocusAsyncInvoke(BunitJSInterop, string?) FocusOnNavigateAssertJSInteropExtensions.VerifyFocusOnNavigateInvoke(BunitJSInterop, int, string?) FocusOnNavigateAssertJSInteropExtensions.VerifyFocusOnNavigateInvoke(BunitJSInterop, string?) JSRuntimeAssertExtensions.VerifyInvoke(BunitJSInterop, string, int, string?) JSRuntimeAssertExtensions.VerifyInvoke(BunitJSInterop, string, string?) JSRuntimeAssertExtensions.VerifyNotInvoke(BunitJSInterop, string, string?) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitJSInterop() Initializes a new instance of the BunitJSInterop class. public BunitJSInterop() Properties Invocations Gets a dictionary of all List<T> this mock has observed. public JSRuntimeInvocationDictionary Invocations { get; } Property Value JSRuntimeInvocationDictionary JSRuntime Gets the mocked IJSRuntime instance. public IJSRuntime JSRuntime { get; } Property Value IJSRuntime Mode Gets or sets whether the BunitJSInterop is running in Loose or Strict. public virtual JSRuntimeMode Mode { get; set; } Property Value JSRuntimeMode Methods AddInvocationHandler<TResult>(JSRuntimeInvocationHandlerBase<TResult>) Adds an invocation handler to bUnit's JSInterop. Can be used to register custom invocation handlers. public void AddInvocationHandler<TResult>(JSRuntimeInvocationHandlerBase<TResult> handler) Parameters handler JSRuntimeInvocationHandlerBase<TResult> Type Parameters TResult"
  },
  "api/Bunit.BunitJSInteropSetupExtensions.html": {
    "href": "api/Bunit.BunitJSInteropSetupExtensions.html",
    "title": "Class BunitJSInteropSetupExtensions | bUnit",
    "keywords": "Class BunitJSInteropSetupExtensions Namespace Bunit Assembly bunit.dll Helper methods for creating invocation handlers and adding the to a BunitJSInterop. public static class BunitJSInteropSetupExtensions Inheritance object BunitJSInteropSetupExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods SetupModule(BunitJSInterop) Configure a catch all JSObjectReferenceInvocationHandler invocation handler for any module load and invocations on those modules. public static BunitJSModuleInterop SetupModule(this BunitJSInterop jsInterop) Parameters jsInterop BunitJSInterop The JSInterop to setup the handler for. Returns BunitJSModuleInterop A BunitJSModuleInterop. Remarks The returned BunitJSInterop can be used to setup handlers for InvokeAsync<TValue>(string, object?[]?)\" calls to the module, using either SetupModule(BunitJSInterop, string) or Setup calls. Exceptions ArgumentNullException Thrown when jsInterop is null. SetupModule(BunitJSInterop, InvocationMatcher, bool) Setup a handler for a IJSRuntime.InvokeAsync<IJSObjectReference>() call whose input parameters is matched by the provided invocationMatcher. public static BunitJSModuleInterop SetupModule(this BunitJSInterop jsInterop, InvocationMatcher invocationMatcher, bool isCatchAllHandler = false) Parameters jsInterop BunitJSInterop The JSInterop to setup the handler for. invocationMatcher InvocationMatcher The matcher to use to match JSRuntimeInvocation's with. isCatchAllHandler bool Set to true if the created handler is a catch all handler, that should only be used if there are no other non-catch all handlers available. Returns BunitJSModuleInterop A BunitJSModuleInterop. Remarks The returned BunitJSInterop can be used to setup handlers for InvokeAsync<TValue>(string, object?[]?)\" calls to the module, using either SetupModule(BunitJSInterop, string) or Setup calls. Exceptions ArgumentNullException Thrown when jsInterop is null. ArgumentNullException Thrown when invocationMatcher is null. SetupModule(BunitJSInterop, string) Setup a handler for a IJSRuntime.InvokeAsync<IJSObjectReference>(\"import\", moduleName) call. public static BunitJSModuleInterop SetupModule(this BunitJSInterop jsInterop, string moduleName) Parameters jsInterop BunitJSInterop The JSInterop to setup the handler for. moduleName string The name of the JavaScript module to handle invocations for. Returns BunitJSModuleInterop A BunitJSModuleInterop. Remarks The returned BunitJSInterop can be used to setup handlers for InvokeAsync<TValue>(string, object?[]?)\" calls to the module, using either SetupModule(BunitJSInterop, string) or Setup calls. Exceptions ArgumentNullException Thrown when jsInterop is null. ArgumentException Thrown when moduleName is null or whitespace. SetupModule(BunitJSInterop, string, InvocationMatcher) Setup a handler for a IJSRuntime.InvokeAsync<IJSObjectReference>() call whose input parameters is matched by the provided invocationMatcher and the identifier. public static BunitJSModuleInterop SetupModule(this BunitJSInterop jsInterop, string identifier, InvocationMatcher invocationMatcher) Parameters jsInterop BunitJSInterop The JSInterop to setup the handler for. identifier string The identifier to setup a response for. invocationMatcher InvocationMatcher The matcher to use to match JSRuntimeInvocation's with. Returns BunitJSModuleInterop A BunitJSModuleInterop. Remarks The returned BunitJSInterop can be used to setup handlers for InvokeAsync<TValue>(string, object?[]?)\" calls to the module, using either SetupModule(BunitJSInterop, string) or Setup calls. Exceptions ArgumentNullException Thrown when jsInterop is null. ArgumentNullException Thrown when invocationMatcher is null. SetupModule(BunitJSInterop, string, object?[]) Setup a handler for a IJSRuntime.InvokeAsync<IJSObjectReference>(identifier, arguments) call. public static BunitJSModuleInterop SetupModule(this BunitJSInterop jsInterop, string identifier, object?[] arguments) Parameters jsInterop BunitJSInterop The JSInterop to setup the handler for. identifier string The identifier to setup a response for. arguments object[] The arguments that an invocation to identifier should match. Use Array.Empty<object?>() for none. Returns BunitJSModuleInterop A BunitJSModuleInterop. Remarks The returned BunitJSInterop can be used to setup handlers for InvokeAsync<TValue>(string, object?[]?)\" calls to the module, using either SetupModule(BunitJSInterop, string) or Setup calls. Exceptions ArgumentNullException Thrown when jsInterop is null. ArgumentException Thrown when identifier is null or whitespace. SetupVoid(BunitJSInterop) Configure a catch all JSInterop invocation handler, that should not receive any result. public static JSRuntimeInvocationHandler SetupVoid(this BunitJSInterop jsInterop) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. Returns JSRuntimeInvocationHandler A JSRuntimeInvocationHandler. SetupVoid(BunitJSInterop, InvocationMatcher, bool) Configure a JSInterop invocation handler for an InvokeVoidAsync call with arguments passing the invocationMatcher test, that should not receive any result. public static JSRuntimeInvocationHandler SetupVoid(this BunitJSInterop jsInterop, InvocationMatcher invocationMatcher, bool isCatchAllHandler = false) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. invocationMatcher InvocationMatcher A matcher that is passed an JSRuntimeInvocation. If it returns true the invocation is matched. isCatchAllHandler bool Set to true if the created handler is a catch all handler, that should only be used if there are no other non-catch all handlers available. Returns JSRuntimeInvocationHandler A JSRuntimeInvocationHandler. SetupVoid(BunitJSInterop, string, InvocationMatcher) Configure a JSInterop invocation handler with the identifier and arguments passing the invocationMatcher test, that should not receive any result. public static JSRuntimeInvocationHandler SetupVoid(this BunitJSInterop jsInterop, string identifier, InvocationMatcher invocationMatcher) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. identifier string The identifier to setup a response for. invocationMatcher InvocationMatcher A matcher that is passed an JSRuntimeInvocation associated with theidentifier. If it returns true the invocation is matched. Returns JSRuntimeInvocationHandler A JSRuntimeInvocationHandler. SetupVoid(BunitJSInterop, string, params object?[]?) Configure a JSInterop invocation handler with the identifier and arguments, that should not receive any result. public static JSRuntimeInvocationHandler SetupVoid(this BunitJSInterop jsInterop, string identifier, params object?[]? arguments) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. identifier string The identifier to setup a response for. arguments object[] The arguments that an invocation to identifier should match. Returns JSRuntimeInvocationHandler A JSRuntimeInvocationHandler. Setup<TResult>(BunitJSInterop) Configure a catch all JSInterop invocation handler for a specific return type. This will match only on the TResult, and any arguments passed to InvokeAsync<TValue>(string, object[]). public static JSRuntimeInvocationHandler<TResult> Setup<TResult>(this BunitJSInterop jsInterop) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. Returns JSRuntimeInvocationHandler<TResult> A JSRuntimeInvocationHandler<TResult>. Type Parameters TResult The result type of the invocation. Setup<TResult>(BunitJSInterop, InvocationMatcher, bool) Configure a JSInterop invocation handler for an InvokeAsync<TResult> call with arguments passing the invocationMatcher test. public static JSRuntimeInvocationHandler<TResult> Setup<TResult>(this BunitJSInterop jsInterop, InvocationMatcher invocationMatcher, bool isCatchAllHandler = false) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. invocationMatcher InvocationMatcher A matcher that is passed an JSRuntimeInvocation. If it returns true the invocation is matched. isCatchAllHandler bool Set to true if the created handler is a catch all handler, that should only be used if there are no other non-catch all handlers available. Returns JSRuntimeInvocationHandler<TResult> A JSRuntimeInvocationHandler<TResult>. Type Parameters TResult The result type of the invocation. Setup<TResult>(BunitJSInterop, string, InvocationMatcher) Configure a JSInterop invocation handler with the identifier and arguments passing the invocationMatcher test. public static JSRuntimeInvocationHandler<TResult> Setup<TResult>(this BunitJSInterop jsInterop, string identifier, InvocationMatcher invocationMatcher) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. identifier string The identifier to setup a response for. invocationMatcher InvocationMatcher A matcher that is passed an JSRuntimeInvocation associated with theidentifier. If it returns true the invocation is matched. Returns JSRuntimeInvocationHandler<TResult> A JSRuntimeInvocationHandler<TResult>. Type Parameters TResult The result type of the invocation. Setup<TResult>(BunitJSInterop, string, params object?[]?) Configure a JSInterop invocation handler with the identifier and arguments. public static JSRuntimeInvocationHandler<TResult> Setup<TResult>(this BunitJSInterop jsInterop, string identifier, params object?[]? arguments) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. identifier string The identifier to setup a response for. arguments object[] The arguments that an invocation to identifier should match. Returns JSRuntimeInvocationHandler<TResult> A JSRuntimeInvocationHandler<TResult>. Type Parameters TResult The type of value to match with in a InvokeAsync<TResult> call. TryGetInvokeHandler<TResult>(BunitJSInterop, string, params object?[]?) Looks through the registered handlers and returns the latest registered that can handle the provided identifier and arguments, and that will return TResult. public static JSRuntimeInvocationHandler<TResult>? TryGetInvokeHandler<TResult>(this BunitJSInterop jsInterop, string identifier, params object?[]? arguments) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. identifier string The identifier the handler should match with. arguments object[] The arguments that an invocation to identifier should match. Returns JSRuntimeInvocationHandler<TResult> Returns the JSRuntimeInvocationHandler<TResult> or null if no one is found. Type Parameters TResult The result type of the invocation. TryGetInvokeVoidHandler(BunitJSInterop, string, params object?[]?) Looks through the registered handlers and returns the latest registered that can handle the provided identifier and arguments, and that returns a \"void\" result. public static JSRuntimeInvocationHandler? TryGetInvokeVoidHandler(this BunitJSInterop jsInterop, string identifier, params object?[]? arguments) Parameters jsInterop BunitJSInterop The bUnit JSInterop to setup the invocation handling with. identifier string The identifier the handler should match with. arguments object[] The arguments that an invocation to identifier should match. Returns JSRuntimeInvocationHandler Returns the JSRuntimeInvocationHandler or null if no one is found. TryGetModuleJSInterop(BunitJSInterop, string, params object?[]?) Looks through the registered handlers and returns the latest registered that can handle the provided identifier and arguments, and that will return IJSObjectReference. public static BunitJSModuleInterop? TryGetModuleJSInterop(this BunitJSInterop jsInterop, string identifier, params object?[]? arguments) Parameters jsInterop BunitJSInterop The JSInterop to setup the handler for. identifier string The identifier the handler should match with. arguments object[] The arguments that an invocation to identifier should match. Returns BunitJSModuleInterop A BunitJSModuleInterop or null if no one is found."
  },
  "api/Bunit.BunitJSModuleInterop.html": {
    "href": "api/Bunit.BunitJSModuleInterop.html",
    "title": "Class BunitJSModuleInterop | bUnit",
    "keywords": "Class BunitJSModuleInterop Namespace Bunit Assembly bunit.dll Represents a bUnit JSInterop module. public sealed class BunitJSModuleInterop : BunitJSInterop Inheritance object BunitJSInterop BunitJSModuleInterop Inherited Members BunitJSInterop.AddInvocationHandler<TResult>(JSRuntimeInvocationHandlerBase<TResult>) BunitJSInterop.Invocations BunitJSInterop.JSRuntime object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop) BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop, InvocationMatcher, bool) BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop, string) BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop, string, InvocationMatcher) BunitJSInteropSetupExtensions.SetupModule(BunitJSInterop, string, object?[]) BunitJSInteropSetupExtensions.SetupVoid(BunitJSInterop) BunitJSInteropSetupExtensions.SetupVoid(BunitJSInterop, InvocationMatcher, bool) BunitJSInteropSetupExtensions.SetupVoid(BunitJSInterop, string, InvocationMatcher) BunitJSInteropSetupExtensions.SetupVoid(BunitJSInterop, string, params object?[]?) BunitJSInteropSetupExtensions.Setup<TResult>(BunitJSInterop) BunitJSInteropSetupExtensions.Setup<TResult>(BunitJSInterop, InvocationMatcher, bool) BunitJSInteropSetupExtensions.Setup<TResult>(BunitJSInterop, string, InvocationMatcher) BunitJSInteropSetupExtensions.Setup<TResult>(BunitJSInterop, string, params object?[]?) BunitJSInteropSetupExtensions.TryGetInvokeHandler<TResult>(BunitJSInterop, string, params object?[]?) BunitJSInteropSetupExtensions.TryGetInvokeVoidHandler(BunitJSInterop, string, params object?[]?) BunitJSInteropSetupExtensions.TryGetModuleJSInterop(BunitJSInterop, string, params object?[]?) FocusAsyncAssertJSInteropExtensions.VerifyFocusAsyncInvoke(BunitJSInterop, int, string?) FocusAsyncAssertJSInteropExtensions.VerifyFocusAsyncInvoke(BunitJSInterop, string?) FocusOnNavigateAssertJSInteropExtensions.VerifyFocusOnNavigateInvoke(BunitJSInterop, int, string?) FocusOnNavigateAssertJSInteropExtensions.VerifyFocusOnNavigateInvoke(BunitJSInterop, string?) JSRuntimeAssertExtensions.VerifyInvoke(BunitJSInterop, string, int, string?) JSRuntimeAssertExtensions.VerifyInvoke(BunitJSInterop, string, string?) JSRuntimeAssertExtensions.VerifyNotInvoke(BunitJSInterop, string, string?) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitJSModuleInterop(BunitJSInterop) Initializes a new instance of the BunitJSModuleInterop class. public BunitJSModuleInterop(BunitJSInterop parent) Parameters parent BunitJSInterop The parent BunitJSInterop. Properties Mode Gets or sets whether this BunitJSInterop is running in Loose or Strict. public override JSRuntimeMode Mode { get; set; } Property Value JSRuntimeMode Remarks When this is not set explicitly, the mode from Mode is used. As soon as this is set, the mode will no longer be changed when the Mode changes."
  },
  "api/Bunit.BunitServiceProvider.html": {
    "href": "api/Bunit.BunitServiceProvider.html",
    "title": "Class BunitServiceProvider | bUnit",
    "keywords": "Class BunitServiceProvider Namespace Bunit Assembly bunit.dll Represents a IServiceProvider and IServiceCollection as a single type used for test purposes. public sealed class BunitServiceProvider : IKeyedServiceProvider, IServiceProvider, IServiceCollection, IList<ServiceDescriptor>, ICollection<ServiceDescriptor>, IEnumerable<ServiceDescriptor>, IEnumerable, IDisposable, IAsyncDisposable Inheritance object BunitServiceProvider Implements IKeyedServiceProvider IServiceProvider IServiceCollection IList<ServiceDescriptor> ICollection<ServiceDescriptor> IEnumerable<ServiceDescriptor> IEnumerable IDisposable IAsyncDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitServiceProvider(IServiceCollection?) Initializes a new instance of the BunitServiceProvider class and sets its service collection to the provided initialServiceCollection, if any. public BunitServiceProvider(IServiceCollection? initialServiceCollection = null) Parameters initialServiceCollection IServiceCollection Properties Count public int Count { get; } Property Value int IsProviderInitialized Gets a value indicating whether this BunitServiceProvider has been initialized, and no longer will accept calls to the AddService's methods. public bool IsProviderInitialized { get; } Property Value bool IsReadOnly public bool IsReadOnly { get; } Property Value bool this[int] public ServiceDescriptor this[int index] { get; set; } Parameters index int Property Value ServiceDescriptor Options Gets or sets the ServiceProviderOptions used when the IServiceProvider is created. public ServiceProviderOptions Options { get; set; } Property Value ServiceProviderOptions Methods Add(ServiceDescriptor) public void Add(ServiceDescriptor item) Parameters item ServiceDescriptor AddFallbackServiceProvider(IServiceProvider) Add a fall back service provider that provides services when the default returns null. public void AddFallbackServiceProvider(IServiceProvider serviceProvider) Parameters serviceProvider IServiceProvider The fallback service provider. Clear() public void Clear() Contains(ServiceDescriptor) public bool Contains(ServiceDescriptor item) Parameters item ServiceDescriptor Returns bool CopyTo(ServiceDescriptor[], int) public void CopyTo(ServiceDescriptor[] array, int arrayIndex) Parameters array ServiceDescriptor[] arrayIndex int Dispose() public void Dispose() DisposeAsync() public ValueTask DisposeAsync() Returns ValueTask GetEnumerator() public IEnumerator<ServiceDescriptor> GetEnumerator() Returns IEnumerator<ServiceDescriptor> GetKeyedService(Type, object?) Gets the service object of the specified type. public object? GetKeyedService(Type serviceType, object? serviceKey) Parameters serviceType Type An object that specifies the type of service object to get. serviceKey object An object that specifies the key of service object to get. Returns object A service object of type serviceType. -or- null if there is no service object of type serviceType. GetRequiredKeyedService(Type, object?) Gets service of type serviceType from the IServiceProvider implementing this interface. public object GetRequiredKeyedService(Type serviceType, object? serviceKey) Parameters serviceType Type An object that specifies the type of service object to get. serviceKey object The ServiceKey of the service. Returns object A service object of type serviceType. Throws an exception if the IServiceProvider cannot create the object. GetService(Type) public object? GetService(Type serviceType) Parameters serviceType Type Returns object GetService<TService>() Get service of type T from the test provider. public TService? GetService<TService>() Returns TService A service object of type T or null if there is no such service. Type Parameters TService The type of service object to get. IndexOf(ServiceDescriptor) public int IndexOf(ServiceDescriptor item) Parameters item ServiceDescriptor Returns int Insert(int, ServiceDescriptor) public void Insert(int index, ServiceDescriptor item) Parameters index int item ServiceDescriptor Remove(ServiceDescriptor) public bool Remove(ServiceDescriptor item) Parameters item ServiceDescriptor Returns bool RemoveAt(int) public void RemoveAt(int index) Parameters index int UseServiceProviderFactory(Func<IServiceCollection, IServiceProvider>) Use a custom service provider factory for creating the underlying IServiceProvider. public void UseServiceProviderFactory(Func<IServiceCollection, IServiceProvider> serviceProviderFactory) Parameters serviceProviderFactory Func<IServiceCollection, IServiceProvider> custom service provider factory UseServiceProviderFactory<TContainerBuilder>(IServiceProviderFactory<TContainerBuilder>, Action<TContainerBuilder>?) Use a custom service provider factory for creating the underlying IServiceProvider. public void UseServiceProviderFactory<TContainerBuilder>(IServiceProviderFactory<TContainerBuilder> serviceProviderFactory, Action<TContainerBuilder>? configure = null) where TContainerBuilder : notnull Parameters serviceProviderFactory IServiceProviderFactory<TContainerBuilder> custom service provider factory configure Action<TContainerBuilder> builder configuration action Type Parameters TContainerBuilder Type of the container builder. See IServiceProviderFactory<TContainerBuilder>"
  },
  "api/Bunit.CompareToExtensions.html": {
    "href": "api/Bunit.CompareToExtensions.html",
    "title": "Class CompareToExtensions | bUnit",
    "keywords": "Class CompareToExtensions Namespace Bunit Assembly bunit.dll Extension methods that allows different rendered fragments to be compared to others or strings. public static class CompareToExtensions Inheritance object CompareToExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods CompareTo(INode, INodeList) Compares an actual AngleSharp.Dom.INode with an expected AngleSharp.Dom.INodeList. public static IReadOnlyList<IDiff> CompareTo(this INode actual, INodeList expected) Parameters actual INode The node to check. expected INodeList The node list to compare with. Returns IReadOnlyList<IDiff> Any differences found. CompareTo(INodeList, INode) Compares an actual AngleSharp.Dom.INodeList with an expected AngleSharp.Dom.INode. public static IReadOnlyList<IDiff> CompareTo(this INodeList actual, INode expected) Parameters actual INodeList The node list to check. expected INode The node to compare with. Returns IReadOnlyList<IDiff> Any differences found. CompareTo(INodeList, INodeList) Compares an actual AngleSharp.Dom.INodeList with an expected AngleSharp.Dom.INodeList. public static IReadOnlyList<IDiff> CompareTo(this INodeList actual, INodeList expected) Parameters actual INodeList The node list to check. expected INodeList The node list to compare with. Returns IReadOnlyList<IDiff> Any differences found. CompareTo<TComponent>(IRenderedComponent<TComponent>, string) Compare the rendered markup in the actual IRenderedComponent<TComponent> with that in the expected markup string. public static IReadOnlyList<IDiff> CompareTo<TComponent>(this IRenderedComponent<TComponent> actual, string expected) where TComponent : IComponent Parameters actual IRenderedComponent<TComponent> Source of rendered markup to check. expected string Markup to compare with. Returns IReadOnlyList<IDiff> Any differences found. Type Parameters TComponent CompareTo<TActualComponent, TExpectedComponent>(IRenderedComponent<TActualComponent>, IRenderedComponent<TExpectedComponent>) Compare the rendered markup in the actual IRenderedComponent<TComponent> to the rendered markup in the expected IRenderedComponent<TComponent>. public static IReadOnlyList<IDiff> CompareTo<TActualComponent, TExpectedComponent>(this IRenderedComponent<TActualComponent> actual, IRenderedComponent<TExpectedComponent> expected) where TActualComponent : IComponent where TExpectedComponent : IComponent Parameters actual IRenderedComponent<TActualComponent> Source of rendered markup to check. expected IRenderedComponent<TExpectedComponent> Source of rendered markup to compare with. Returns IReadOnlyList<IDiff> Any differences found. Type Parameters TActualComponent TExpectedComponent"
  },
  "api/Bunit.ComponentFactoryCollection.html": {
    "href": "api/Bunit.ComponentFactoryCollection.html",
    "title": "Class ComponentFactoryCollection | bUnit",
    "keywords": "Class ComponentFactoryCollection Namespace Bunit Assembly bunit.dll Represents a collection of IComponentFactory. public sealed class ComponentFactoryCollection : IList<IComponentFactory>, ICollection<IComponentFactory>, IEnumerable<IComponentFactory>, IEnumerable Inheritance object ComponentFactoryCollection Implements IList<IComponentFactory> ICollection<IComponentFactory> IEnumerable<IComponentFactory> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods ComponentFactoryCollectionExtensions.Add(ComponentFactoryCollection, Predicate<Type>, Func<Type, IComponent>) ComponentFactoryCollectionExtensions.Add<TComponent>(ComponentFactoryCollection, Func<TComponent>) ComponentFactoryCollectionExtensions.Add<TComponent>(ComponentFactoryCollection, TComponent) ComponentFactoryCollectionExtensions.Add<TComponent, TSubstituteComponent>(ComponentFactoryCollection) StubComponentFactoryCollectionExtensions.AddStub(ComponentFactoryCollection, Predicate<Type>) StubComponentFactoryCollectionExtensions.AddStub(ComponentFactoryCollection, Predicate<Type>, RenderFragment) StubComponentFactoryCollectionExtensions.AddStub(ComponentFactoryCollection, Predicate<Type>, string) StubComponentFactoryCollectionExtensions.AddStub<TComponent>(ComponentFactoryCollection) StubComponentFactoryCollectionExtensions.AddStub<TComponent>(ComponentFactoryCollection, RenderFragment) StubComponentFactoryCollectionExtensions.AddStub<TComponent>(ComponentFactoryCollection, RenderFragment<CapturedParameterView<TComponent>>) StubComponentFactoryCollectionExtensions.AddStub<TComponent>(ComponentFactoryCollection, Func<CapturedParameterView<TComponent>, string>) StubComponentFactoryCollectionExtensions.AddStub<TComponent>(ComponentFactoryCollection, string) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ComponentFactoryCollection() public ComponentFactoryCollection() Properties Count Gets the number of IComponentFactory contained in the ComponentFactoryCollection. public int Count { get; } Property Value int IsReadOnly Gets a value indicating whether the ComponentFactoryCollection is read-only. public bool IsReadOnly { get; } Property Value bool this[int] Gets or sets a IComponentFactory at the specified index. public IComponentFactory this[int index] { get; set; } Parameters index int The zero-based index of the element to get or set. Property Value IComponentFactory The IComponentFactory at the specified index. Methods Add(IComponentFactory) Adds an IComponentFactory to the ComponentFactoryCollection. public void Add(IComponentFactory item) Parameters item IComponentFactory The IComponentFactory to add to the collection. Clear() Removes all IComponentFactorys from the ComponentFactoryCollection. public void Clear() Contains(IComponentFactory) Determines whether the ComponentFactoryCollection contains a specific IComponentFactory. public bool Contains(IComponentFactory item) Parameters item IComponentFactory The object to locate in the ComponentFactoryCollection.. Returns bool true if item is found in the ComponentFactoryCollection; otherwise, false. CopyTo(IComponentFactory[], int) Copies the IComponentFactorys of the ComponentFactoryCollection to an Array, starting at a particular Array index. public void CopyTo(IComponentFactory[] array, int arrayIndex) Parameters array IComponentFactory[] The one-dimensional Array that is the destination of the elements copied from ComponentFactoryCollection. The Array must have zero-based indexing. arrayIndex int The zero-based index in array at which copying begins. GetEnumerator() Returns an enumerator that iterates through the collection of IComponentFactory. public IEnumerator<IComponentFactory> GetEnumerator() Returns IEnumerator<IComponentFactory> An enumerator that can be used to iterate through the collection of IComponentFactory. IndexOf(IComponentFactory) Determines the index of a specific IComponentFactory in the ComponentFactoryCollection. public int IndexOf(IComponentFactory item) Parameters item IComponentFactory The IComponentFactory to locate in the ComponentFactoryCollection.. Returns int The index of IComponentFactory if found in the list; otherwise, -1. Insert(int, IComponentFactory) Inserts an IComponentFactory to the ComponentFactoryCollection at the specified index. public void Insert(int index, IComponentFactory item) Parameters index int The zero-based index at which IComponentFactory should be inserted. item IComponentFactory The IComponentFactory to insert into the ComponentFactoryCollection. Remove(IComponentFactory) Removes the first occurrence of a specific IComponentFactory from the ComponentFactoryCollection. public bool Remove(IComponentFactory item) Parameters item IComponentFactory The IComponentFactory to remove from the ComponentFactoryCollection. Returns bool true if IComponentFactory was successfully removed from the ComponentFactoryCollection; otherwise, false. This method also returns false if IComponentFactory is not found in the original ComponentFactoryCollection. RemoveAt(int) Removes the ComponentFactoryCollection IComponentFactory at the specified index. public void RemoveAt(int index) Parameters index int The zero-based index of the IComponentFactory to remove."
  },
  "api/Bunit.ComponentFactoryCollectionExtensions.html": {
    "href": "api/Bunit.ComponentFactoryCollectionExtensions.html",
    "title": "Class ComponentFactoryCollectionExtensions | bUnit",
    "keywords": "Class ComponentFactoryCollectionExtensions Namespace Bunit Assembly bunit.dll Extension methods for using component doubles. public static class ComponentFactoryCollectionExtensions Inheritance object ComponentFactoryCollectionExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods Add(ComponentFactoryCollection, Predicate<Type>, Func<Type, IComponent>) Configures bUnit to substitute components whose type matches the condition, with components created by the provided component factory. public static ComponentFactoryCollection Add(this ComponentFactoryCollection factories, Predicate<Type> condition, Func<Type, IComponent> factory) Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. condition Predicate<Type> The condition that must be met for the factory to be used. factory Func<Type, IComponent> The factory to use to create substitute components with. Returns ComponentFactoryCollection A ComponentFactoryCollection. Remarks The provided factory must return unique instances each time it is called. Blazor does not allow the same component to exists in multiple places in a render tree. Exceptions ArgumentNullException Thrown when factories, condition, and/or factory is null. Add<TComponent>(ComponentFactoryCollection, Func<TComponent>) Configures bUnit to substitute components of type TComponent with one created by the provided component factory. public static ComponentFactoryCollection Add<TComponent>(this ComponentFactoryCollection factories, Func<TComponent> factory) where TComponent : IComponent Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. factory Func<TComponent> The component factory to use to create substitute components with. Returns ComponentFactoryCollection A ComponentFactoryCollection. Type Parameters TComponent Type of component to substitute. Remarks The provided factory must return unique instances each time it is called. Blazor does not allow the same component to exists in multiple places in a render tree. Exceptions ArgumentNullException Thrown when factories and/or factory is null. Add<TComponent>(ComponentFactoryCollection, TComponent) Configures bUnit to substitute a component of type TComponent with the provided instance. public static ComponentFactoryCollection Add<TComponent>(this ComponentFactoryCollection factories, TComponent instance) where TComponent : IComponent Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. instance TComponent The instance of the replacement component. Returns ComponentFactoryCollection A ComponentFactoryCollection. Type Parameters TComponent Type of component to substitute. Remarks Only one TComponent component can be substituted with the component (instance). If there are two or more TComponent components in the render tree, an exception is thrown. Exceptions ArgumentNullException Thrown when factories and/or instance is null. Add<TComponent, TSubstituteComponent>(ComponentFactoryCollection) Configures bUnit to substitute all components of type TComponent with components of type TSubstituteComponent. public static ComponentFactoryCollection Add<TComponent, TSubstituteComponent>(this ComponentFactoryCollection factories) where TComponent : IComponent where TSubstituteComponent : IComponent, new() Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. Returns ComponentFactoryCollection A ComponentFactoryCollection. Type Parameters TComponent Type of component to replace. TSubstituteComponent Type of component to substitute with. Exceptions ArgumentNullException Thrown when factories is null."
  },
  "api/Bunit.ComponentParameterCollectionBuilder-1.html": {
    "href": "api/Bunit.ComponentParameterCollectionBuilder-1.html",
    "title": "Class ComponentParameterCollectionBuilder<TComponent> | bUnit",
    "keywords": "Class ComponentParameterCollectionBuilder<TComponent> Namespace Bunit Assembly bunit.dll A ComponentParameterCollection builder for a specific TComponent component under test. public sealed class ComponentParameterCollectionBuilder<TComponent> where TComponent : IComponent Type Parameters TComponent The type of component under test to add the parameters. Inheritance object ComponentParameterCollectionBuilder<TComponent> Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ComponentParameterCollectionBuilder() Initializes a new instance of the ComponentParameterCollectionBuilder<TComponent> class. public ComponentParameterCollectionBuilder() ComponentParameterCollectionBuilder(Action<ComponentParameterCollectionBuilder<TComponent>>?) Initializes a new instance of the ComponentParameterCollectionBuilder<TComponent> class and invokes the parameterAdder with it as the argument. public ComponentParameterCollectionBuilder(Action<ComponentParameterCollectionBuilder<TComponent>>? parameterAdder) Parameters parameterAdder Action<ComponentParameterCollectionBuilder<TComponent>> Methods Add(Expression<Func<TComponent, EventCallback>>, Action) Adds a component parameter for an EventCallback parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, EventCallback>> parameterSelector, Action callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback>> A lambda function that selects the parameter. callback Action The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add(Expression<Func<TComponent, EventCallback>>, Action<object>) Adds a component parameter for an EventCallback parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, EventCallback>> parameterSelector, Action<object> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback>> A lambda function that selects the parameter. callback Action<object> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add(Expression<Func<TComponent, EventCallback>>, Func<object, Task>) Adds a component parameter for an EventCallback parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, EventCallback>> parameterSelector, Func<object, Task> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback>> A lambda function that selects the parameter. callback Func<object, Task> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add(Expression<Func<TComponent, EventCallback>>, Func<Task>) Adds a component parameter for an EventCallback parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, EventCallback>> parameterSelector, Func<Task> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback>> A lambda function that selects the parameter. callback Func<Task> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add(Expression<Func<TComponent, RenderFragment?>>, string) Adds a component parameter for a RenderFragment parameter selected with parameterSelector, where the RenderFragment value is the markup passed in through the markup argument. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, RenderFragment?>> parameterSelector, string markup) Parameters parameterSelector Expression<Func<TComponent, RenderFragment>> A lambda function that selects the parameter. markup string The markup string to pass to the RenderFragment. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add(Expression<Func<TComponent, EventCallback?>>, Action) Adds a component parameter for a nullable EventCallback parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, EventCallback?>> parameterSelector, Action callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback?>> A lambda function that selects the parameter. callback Action The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add(Expression<Func<TComponent, EventCallback?>>, Action<object>) Adds a component parameter for a nullable EventCallback parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, EventCallback?>> parameterSelector, Action<object> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback?>> A lambda function that selects the parameter. callback Action<object> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add(Expression<Func<TComponent, EventCallback?>>, Func<object, Task>) Adds a component parameter for a nullable EventCallback parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, EventCallback?>> parameterSelector, Func<object, Task> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback?>> A lambda function that selects the parameter. callback Func<object, Task> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add(Expression<Func<TComponent, EventCallback?>>, Func<Task>) Adds a component parameter for a nullable EventCallback parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add(Expression<Func<TComponent, EventCallback?>> parameterSelector, Func<Task> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback?>> A lambda function that selects the parameter. callback Func<Task> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. AddCascadingValue<TValue>(string, TValue) Adds an NAMED cascading value around the TComponent when it is rendered. Used to pass cascading values to child components of TComponent. public ComponentParameterCollectionBuilder<TComponent> AddCascadingValue<TValue>(string name, TValue cascadingValue) where TValue : notnull Parameters name string The name of the cascading value. cascadingValue TValue The cascading value. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The type of cascading value. AddCascadingValue<TValue>(TValue) Adds an UNNAMED cascading value around the TComponent when it is rendered. Used to pass cascading values to child components of TComponent. public ComponentParameterCollectionBuilder<TComponent> AddCascadingValue<TValue>(TValue cascadingValue) where TValue : notnull Parameters cascadingValue TValue The cascading value. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The type of cascading value. AddChildContent(RenderFragment) Adds a ChildContent RenderFragment type parameter with the childContent as value. Note, this is equivalent to Add(p => p.ChildContent, childContent). public ComponentParameterCollectionBuilder<TComponent> AddChildContent(RenderFragment childContent) Parameters childContent RenderFragment The RenderFragment to pass the ChildContent parameter. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. AddChildContent(string) Adds a ChildContent RenderFragment type parameter with the markup as value wrapped in a RenderFragment. Note, this is equivalent to Add(p => p.ChildContent, \"...\"). public ComponentParameterCollectionBuilder<TComponent> AddChildContent(string markup) Parameters markup string The markup string to pass the ChildContent parameter wrapped in a RenderFragment. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. AddChildContent<TChildComponent>(Action<ComponentParameterCollectionBuilder<TChildComponent>>?) Adds a ChildContent RenderFragment type parameter, that is passed a RenderFragment, which will render the TChildComponent with the parameters passed to childParameterBuilder. public ComponentParameterCollectionBuilder<TComponent> AddChildContent<TChildComponent>(Action<ComponentParameterCollectionBuilder<TChildComponent>>? childParameterBuilder = null) where TChildComponent : IComponent Parameters childParameterBuilder Action<ComponentParameterCollectionBuilder<TChildComponent>> A parameter builder for the TChildComponent. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TChildComponent Type of child component to pass to the ChildContent parameter. AddUnmatched(string, object?) Adds an unmatched attribute value to TComponent. public ComponentParameterCollectionBuilder<TComponent> AddUnmatched(string name, object? value = null) Parameters name string The name of the unmatched attribute. value object The value of the unmatched attribute. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>>>, Action) Adds a component parameter for an EventCallback<TValue> parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>>> parameterSelector, Action callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback<TValue>>> A lambda function that selects the parameter. callback Action The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The value returned in the EventCallback<TValue>. Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>>>, Action<TValue>) Adds a component parameter for an EventCallback<TValue> parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>>> parameterSelector, Action<TValue> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback<TValue>>> A lambda function that selects the parameter. callback Action<TValue> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The value returned in the EventCallback<TValue>. Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>>>, Func<Task>) Adds a component parameter for an EventCallback<TValue> parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>>> parameterSelector, Func<Task> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback<TValue>>> A lambda function that selects the parameter. callback Func<Task> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The value returned in the EventCallback<TValue>. Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>>>, Func<TValue, Task>) Adds a component parameter for an EventCallback<TValue> parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>>> parameterSelector, Func<TValue, Task> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback<TValue>>> A lambda function that selects the parameter. callback Func<TValue, Task> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The value returned in the EventCallback<TValue>. Add<TValue>(Expression<Func<TComponent, RenderFragment<TValue>?>>, Func<TValue, string>) Adds a component parameter for a RenderFragment<TValue> template parameter selected with parameterSelector, where the RenderFragment<TValue> template is based on the markupFactory argument. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, RenderFragment<TValue>?>> parameterSelector, Func<TValue, string> markupFactory) Parameters parameterSelector Expression<Func<TComponent, RenderFragment<TValue>>> A lambda function that selects the parameter. markupFactory Func<TValue, string> A markup factory used to create the RenderFragment<TValue> template with. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The context type of the RenderFragment<TValue>. Add<TChildComponent>(Expression<Func<TComponent, RenderFragment?>>, Action<ComponentParameterCollectionBuilder<TChildComponent>>?) Adds a component parameter for a RenderFragment parameter selected with parameterSelector, where the RenderFragment value is created through the childParameterBuilder argument. public ComponentParameterCollectionBuilder<TComponent> Add<TChildComponent>(Expression<Func<TComponent, RenderFragment?>> parameterSelector, Action<ComponentParameterCollectionBuilder<TChildComponent>>? childParameterBuilder = null) where TChildComponent : IComponent Parameters parameterSelector Expression<Func<TComponent, RenderFragment>> A lambda function that selects the parameter. childParameterBuilder Action<ComponentParameterCollectionBuilder<TChildComponent>> A parameter builder for the TChildComponent. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TChildComponent The type of component to create a RenderFragment for. Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>?>>, Action) Adds a component parameter for a nullable EventCallback<TValue> parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>?>> parameterSelector, Action callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback<TValue>?>> A lambda function that selects the parameter. callback Action The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The value returned in the EventCallback<TValue>. Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>?>>, Action<TValue>) Adds a component parameter for a nullable EventCallback<TValue> parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>?>> parameterSelector, Action<TValue> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback<TValue>?>> A lambda function that selects the parameter. callback Action<TValue> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The value returned in the EventCallback<TValue>. Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>?>>, Func<Task>) Adds a component parameter for a nullable EventCallback<TValue> parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>?>> parameterSelector, Func<Task> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback<TValue>?>> A lambda function that selects the parameter. callback Func<Task> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The value returned in the EventCallback<TValue>. Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>?>>, Func<TValue, Task>) Adds a component parameter for a nullable EventCallback<TValue> parameter selected with parameterSelector, where the callback is used as value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, EventCallback<TValue>?>> parameterSelector, Func<TValue, Task> callback) Parameters parameterSelector Expression<Func<TComponent, EventCallback<TValue>?>> A lambda function that selects the parameter. callback Func<TValue, Task> The callback to pass to the EventCallback. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue The value returned in the EventCallback<TValue>. Add<TValue>(Expression<Func<TComponent, TValue>>, TValue) Adds a component parameter for the parameter selected with parameterSelector with the value value. public ComponentParameterCollectionBuilder<TComponent> Add<TValue>(Expression<Func<TComponent, TValue>> parameterSelector, TValue value) Parameters parameterSelector Expression<Func<TComponent, TValue>> A lambda function that selects the parameter. value TValue The value to pass to TComponent. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue Type of value. Add<TChildComponent, TValue>(Expression<Func<TComponent, RenderFragment<TValue>?>>, Func<TValue, Action<ComponentParameterCollectionBuilder<TChildComponent>>>) Adds a component parameter for a RenderFragment<TValue> template parameter selected with parameterSelector, where the RenderFragment<TValue> template is based on the templateFactory, which is used to create a RenderFragment<TValue> that renders a TChildComponent inside the template. public ComponentParameterCollectionBuilder<TComponent> Add<TChildComponent, TValue>(Expression<Func<TComponent, RenderFragment<TValue>?>> parameterSelector, Func<TValue, Action<ComponentParameterCollectionBuilder<TChildComponent>>> templateFactory) where TChildComponent : IComponent Parameters parameterSelector Expression<Func<TComponent, RenderFragment<TValue>>> A lambda function that selects the parameter. templateFactory Func<TValue, Action<ComponentParameterCollectionBuilder<TChildComponent>>> A template factory used to create the parameters being passed to the TChildComponent. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TChildComponent The type of component to create a RenderFragment<TValue> for. TValue The context type of the RenderFragment<TValue>. Bind<TValue>(Expression<Func<TComponent, TValue>>, TValue, Action<TValue>, Expression<Func<TValue>>?) Adds two-way binding, simulating the @bind-Parameter directive, to a given pair of parameters. public ComponentParameterCollectionBuilder<TComponent> Bind<TValue>(Expression<Func<TComponent, TValue>> parameterSelector, TValue initialValue, Action<TValue> changedAction, Expression<Func<TValue>>? valueExpression = null) Parameters parameterSelector Expression<Func<TComponent, TValue>> Parameter-selector for the two-way binding. initialValue TValue The initial value to pass to TComponent. changedAction Action<TValue> Action which gets invoked when the value has changed. valueExpression Expression<Func<TValue>> Optional value expression. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. Type Parameters TValue Remarks This function is a short-hand form for the following expression: Render<TComponent>(ps => ps .Add(c => c.Value, value) .Add(c => c.ValueChanged, newValue => value = newValue) .Add(c => c.ValueExpression, () => value)); With Bind, it can be written like this: Render<TComponent>(ps => ps .Bind(c => c.Value, value, newValue => value = newValue, () => value)); SetAssignedRenderMode(IComponentRenderMode?) Sets (or unsets) the IComponentRenderMode for the component and child components. public ComponentParameterCollectionBuilder<TComponent> SetAssignedRenderMode(IComponentRenderMode? renderMode) Parameters renderMode IComponentRenderMode The render mode to assign to the component, e.g. RenderMode.InteractiveServer, or null, to not assign a specific render mode. Returns ComponentParameterCollectionBuilder<TComponent> This ComponentParameterCollectionBuilder<TComponent>. TryAdd<TValue>(string, TValue) Try to add a value for a parameter with the name, if TComponent has a property with that name, AND that property has a ParameterAttribute or a CascadingParameterAttribute. public bool TryAdd<TValue>(string name, TValue value) Parameters name string Name of the property for the parameter. value TValue Value to assign to the parameter. Returns bool True if parameter with the name exists and value was set, false otherwise. Type Parameters TValue Value type. Remarks This is an untyped version of this method named AddUnmatched(string, object?). Always prefer the strongly typed Add methods whenever possible."
  },
  "api/Bunit.ElementNotFoundException.html": {
    "href": "api/Bunit.ElementNotFoundException.html",
    "title": "Class ElementNotFoundException | bUnit",
    "keywords": "Class ElementNotFoundException Namespace Bunit Assembly bunit.dll Represents a failure to find an element in the searched target using a CSS selector. public class ElementNotFoundException : Exception, ISerializable Inheritance object Exception ElementNotFoundException Implements ISerializable Derived ElementRemovedFromDomException Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ElementNotFoundException(string) Initializes a new instance of the ElementNotFoundException class. public ElementNotFoundException(string cssSelector) Parameters cssSelector string ElementNotFoundException(string, string) Initializes a new instance of the ElementNotFoundException class. protected ElementNotFoundException(string message, string cssSelector) Parameters message string cssSelector string Properties CssSelector Gets the CSS selector used to search with. public string CssSelector { get; } Property Value string"
  },
  "api/Bunit.ElementRemovedFromDomException.html": {
    "href": "api/Bunit.ElementRemovedFromDomException.html",
    "title": "Class ElementRemovedFromDomException | bUnit",
    "keywords": "Class ElementRemovedFromDomException Namespace Bunit Assembly bunit.dll Represents an exception that is thrown when trying to access an element that was previously found in the DOM. public sealed class ElementRemovedFromDomException : ElementNotFoundException, ISerializable Inheritance object Exception ElementNotFoundException ElementRemovedFromDomException Implements ISerializable Inherited Members ElementNotFoundException.CssSelector Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ElementRemovedFromDomException(string) Initializes a new instance of the ElementRemovedFromDomException class. public ElementRemovedFromDomException(string cssSelector) Parameters cssSelector string"
  },
  "api/Bunit.EventHandlerDispatchExtensions.html": {
    "href": "api/Bunit.EventHandlerDispatchExtensions.html",
    "title": "Class EventHandlerDispatchExtensions | bUnit",
    "keywords": "Class EventHandlerDispatchExtensions Namespace Bunit Assembly bunit.dll Input event dispatch helper extension methods. public static class EventHandlerDispatchExtensions Inheritance object EventHandlerDispatchExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods Abort(IElement, ProgressEventArgs?) Raises the @onabort event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static void Abort(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. AbortAsync(IElement, ProgressEventArgs?) Raises the @onabort event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static Task AbortAsync(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Activate(IElement, EventArgs?) Raises the @onactivate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Activate(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. ActivateAsync(IElement, EventArgs?) Raises the @onactivate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task ActivateAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. BeforeActivate(IElement, EventArgs?) Raises the @onbeforeactivate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void BeforeActivate(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. BeforeActivateAsync(IElement, EventArgs?) Raises the @onbeforeactivate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task BeforeActivateAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. BeforeCopy(IElement, EventArgs?) Raises the @onbeforecopy event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void BeforeCopy(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. BeforeCopyAsync(IElement, EventArgs?) Raises the @onbeforecopy event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task BeforeCopyAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. BeforeCut(IElement, EventArgs?) Raises the @onbeforecut event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void BeforeCut(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. BeforeCutAsync(IElement, EventArgs?) Raises the @onbeforecut event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task BeforeCutAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. BeforeDeactivate(IElement, EventArgs?) Raises the @onbeforedeactivate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void BeforeDeactivate(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. BeforeDeactivateAsync(IElement, EventArgs?) Raises the @onbeforedeactivate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task BeforeDeactivateAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. BeforePaste(IElement, EventArgs?) Raises the @onbeforepaste event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void BeforePaste(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. BeforePasteAsync(IElement, EventArgs?) Raises the @onbeforepaste event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task BeforePasteAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Blur(IElement, FocusEventArgs?) Raises the @onblur event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of FocusEventArgs will be created. public static void Blur(this IElement element, FocusEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs FocusEventArgs The event arguments to pass to the event handler. BlurAsync(IElement, FocusEventArgs?) Raises the @onblur event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of FocusEventArgs will be created. public static Task BlurAsync(this IElement element, FocusEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs FocusEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. CanPlay(IElement, EventArgs?) Raises the @oncanplay event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void CanPlay(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. CanPlayAsync(IElement, EventArgs?) Raises the @oncanplay event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task CanPlayAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. CanPlayThrough(IElement, EventArgs?) Raises the @oncanplaythrough event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void CanPlayThrough(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. CanPlayThroughAsync(IElement, EventArgs?) Raises the @oncanplaythrough event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task CanPlayThroughAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Cancel(IElement, EventArgs?) Raises the @oncancel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Cancel(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. CancelAsync(IElement, EventArgs?) Raises the @oncancel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task CancelAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Change(IElement, ChangeEventArgs?) Raises the @onchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ChangeEventArgs will be created. public static void Change(this IElement element, ChangeEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ChangeEventArgs The event arguments to pass to the event handler. ChangeAsync(IElement, ChangeEventArgs?) Raises the @onchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ChangeEventArgs will be created. public static Task ChangeAsync(this IElement element, ChangeEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ChangeEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. ChangeAsync<T>(IElement, T) Raises the @onchange event on element, passing the provided properties to the event handler via a ChangeEventArgs object. public static Task ChangeAsync<T>(this IElement element, T value) Parameters element IElement The element to raise the event on. value T The new value. Returns Task Type Parameters T Change<T>(IElement, T) Raises the @onchange event on element, passing the provided properties to the event handler via a ChangeEventArgs object. public static void Change<T>(this IElement element, T value) Parameters element IElement The element to raise the event on. value T The new value. Type Parameters T Click(IElement, MouseEventArgs?) Raises the @onclick event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void Click(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. ClickAsync(IElement, MouseEventArgs?) Raises the @onclick event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task ClickAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Close(IElement, EventArgs?) Raises the @onclose event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Close(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. CloseAsync(IElement, EventArgs?) Raises the @onclose event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task CloseAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. ContextMenu(IElement, MouseEventArgs?) Raises the @oncontextmenu event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void ContextMenu(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. ContextMenuAsync(IElement, MouseEventArgs?) Raises the @oncontextmenu event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task ContextMenuAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Copy(IElement, ClipboardEventArgs?) Raises the @oncopy event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ClipboardEventArgs will be created. public static void Copy(this IElement element, ClipboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ClipboardEventArgs The event arguments to pass to the event handler. CopyAsync(IElement, ClipboardEventArgs?) Raises the @oncopy event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ClipboardEventArgs will be created. public static Task CopyAsync(this IElement element, ClipboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ClipboardEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. CueChange(IElement, EventArgs?) Raises the @oncuechange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void CueChange(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. CueChangeAsync(IElement, EventArgs?) Raises the @oncuechange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task CueChangeAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Cut(IElement, ClipboardEventArgs?) Raises the @oncut event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ClipboardEventArgs will be created. public static void Cut(this IElement element, ClipboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ClipboardEventArgs The event arguments to pass to the event handler. CutAsync(IElement, ClipboardEventArgs?) Raises the @oncut event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ClipboardEventArgs will be created. public static Task CutAsync(this IElement element, ClipboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ClipboardEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Deactivate(IElement, EventArgs?) Raises the @ondeactivate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Deactivate(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. DeactivateAsync(IElement, EventArgs?) Raises the @ondeactivate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task DeactivateAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. DoubleClick(IElement, MouseEventArgs?) Raises the @ondblclick event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void DoubleClick(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. DoubleClickAsync(IElement, MouseEventArgs?) Raises the @ondblclick event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task DoubleClickAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Drag(IElement, DragEventArgs?) Raises the @ondrag event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static void Drag(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. DragAsync(IElement, DragEventArgs?) Raises the @ondrag event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static Task DragAsync(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. DragEnd(IElement, DragEventArgs?) Raises the @ondragend event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static void DragEnd(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. DragEndAsync(IElement, DragEventArgs?) Raises the @ondragend event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static Task DragEndAsync(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. DragEnter(IElement, DragEventArgs?) Raises the @ondragenter event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static void DragEnter(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. DragEnterAsync(IElement, DragEventArgs?) Raises the @ondragenter event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static Task DragEnterAsync(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. DragLeave(IElement, DragEventArgs?) Raises the @ondragleave event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static void DragLeave(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. DragLeaveAsync(IElement, DragEventArgs?) Raises the @ondragleave event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static Task DragLeaveAsync(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. DragOver(IElement, DragEventArgs?) Raises the @ondragover event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static void DragOver(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. DragOverAsync(IElement, DragEventArgs?) Raises the @ondragover event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static Task DragOverAsync(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. DragStart(IElement, DragEventArgs?) Raises the @ondragstart event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static void DragStart(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. DragStartAsync(IElement, DragEventArgs?) Raises the @ondragstart event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static Task DragStartAsync(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Drop(IElement, DragEventArgs?) Raises the @ondrop event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static void Drop(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. DropAsync(IElement, DragEventArgs?) Raises the @ondrop event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of DragEventArgs will be created. public static Task DropAsync(this IElement element, DragEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs DragEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. DurationChange(IElement, EventArgs?) Raises the @ondurationchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void DurationChange(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. DurationChangeAsync(IElement, EventArgs?) Raises the @ondurationchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task DurationChangeAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Emptied(IElement, EventArgs?) Raises the @onemptied event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Emptied(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. EmptiedAsync(IElement, EventArgs?) Raises the @onemptied event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task EmptiedAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Ended(IElement, EventArgs?) Raises the @onended event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Ended(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. EndedAsync(IElement, EventArgs?) Raises the @onended event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task EndedAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Error(IElement, ErrorEventArgs?) Raises the @onerror event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of Microsoft.AspNetCore.Components.Web.ErrorEventArgs will be created. public static void Error(this IElement element, ErrorEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ErrorEventArgs The event arguments to pass to the event handler. ErrorAsync(IElement, ErrorEventArgs?) Raises the @onerror event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of Microsoft.AspNetCore.Components.Web.ErrorEventArgs will be created. public static Task ErrorAsync(this IElement element, ErrorEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ErrorEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Focus(IElement, FocusEventArgs?) Raises the @onfocus event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of FocusEventArgs will be created. public static void Focus(this IElement element, FocusEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs FocusEventArgs The event arguments to pass to the event handler. FocusAsync(IElement, FocusEventArgs?) Raises the @onfocus event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of FocusEventArgs will be created. public static Task FocusAsync(this IElement element, FocusEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs FocusEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. FocusIn(IElement, FocusEventArgs?) Raises the @onfocusin event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of FocusEventArgs will be created. public static void FocusIn(this IElement element, FocusEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs FocusEventArgs The event arguments to pass to the event handler. FocusInAsync(IElement, FocusEventArgs?) Raises the @onfocusin event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of FocusEventArgs will be created. public static Task FocusInAsync(this IElement element, FocusEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs FocusEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. FocusOut(IElement, FocusEventArgs?) Raises the @onfocusout event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of FocusEventArgs will be created. public static void FocusOut(this IElement element, FocusEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs FocusEventArgs The event arguments to pass to the event handler. FocusOutAsync(IElement, FocusEventArgs?) Raises the @onfocusout event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of FocusEventArgs will be created. public static Task FocusOutAsync(this IElement element, FocusEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs FocusEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. FullScreenChange(IElement, EventArgs?) Raises the @onfullscreenchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void FullScreenChange(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. FullScreenChangeAsync(IElement, EventArgs?) Raises the @onfullscreenchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task FullScreenChangeAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. FullScreenError(IElement, EventArgs?) Raises the @onfullscreenerror event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void FullScreenError(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. FullScreenErrorAsync(IElement, EventArgs?) Raises the @onfullscreenerror event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task FullScreenErrorAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. GotPointerCapture(IElement, PointerEventArgs?) Raises the @ongotpointercapture event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void GotPointerCapture(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. GotPointerCaptureAsync(IElement, PointerEventArgs?) Raises the @ongotpointercapture event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task GotPointerCaptureAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Input(IElement, ChangeEventArgs?) Raises the @oninput event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ChangeEventArgs will be created. public static void Input(this IElement element, ChangeEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ChangeEventArgs The event arguments to pass to the event handler. InputAsync(IElement, ChangeEventArgs?) Raises the @oninput event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ChangeEventArgs will be created. public static Task InputAsync(this IElement element, ChangeEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ChangeEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. InputAsync<T>(IElement, T) Raises the @oninput event on element, passing the provided properties to the event handler via a ChangeEventArgs object. public static Task InputAsync<T>(this IElement element, T value) Parameters element IElement The element to raise the event on. value T The new value. Returns Task Type Parameters T Input<T>(IElement, T) Raises the @oninput event on element, passing the provided properties to the event handler via a ChangeEventArgs object. public static void Input<T>(this IElement element, T value) Parameters element IElement The element to raise the event on. value T The new value. Type Parameters T Invalid(IElement, EventArgs?) Raises the @oninvalid event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Invalid(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. InvalidAsync(IElement, EventArgs?) Raises the @oninvalid event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task InvalidAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. KeyDown(IElement, Key, bool, string?) Raises the @onkeydown event on element, passing the provided key to the event handler. public static void KeyDown(this IElement element, Key key, bool repeat = false, string? type = null) Parameters element IElement The element to raise the event on. key Key The keyboard key to pass to the event handler. repeat bool true if a key has been depressed long enough to trigger key repetition, otherwise false. type string The type of the event. KeyDown(IElement, KeyboardEventArgs?) Raises the @onkeydown event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of KeyboardEventArgs will be created. public static void KeyDown(this IElement element, KeyboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs KeyboardEventArgs The event arguments to pass to the event handler. KeyDownAsync(IElement, Key, bool, string?) Raises the @onkeydown event on element, passing the provided key to the event handler. public static Task KeyDownAsync(this IElement element, Key key, bool repeat = false, string? type = null) Parameters element IElement The element to raise the event on. key Key The keyboard key to pass to the event handler. repeat bool true if a key has been depressed long enough to trigger key repetition, otherwise false. type string The type of the event. Returns Task KeyDownAsync(IElement, KeyboardEventArgs?) Raises the @onkeydown event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of KeyboardEventArgs will be created. public static Task KeyDownAsync(this IElement element, KeyboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs KeyboardEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. KeyPress(IElement, Key, bool, string?) Raises the @onkeypress event on element, passing the provided key to the event handler. public static void KeyPress(this IElement element, Key key, bool repeat = false, string? type = null) Parameters element IElement The element to raise the event on. key Key The keyboard key to pass to the event handler. repeat bool true if a key has been depressed long enough to trigger key repetition, otherwise false. type string The type of the event. KeyPress(IElement, KeyboardEventArgs?) Raises the @onkeypress event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of KeyboardEventArgs will be created. public static void KeyPress(this IElement element, KeyboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs KeyboardEventArgs The event arguments to pass to the event handler. KeyPressAsync(IElement, Key, bool, string?) Raises the @onkeypress event on element, passing the provided key to the event handler. public static Task KeyPressAsync(this IElement element, Key key, bool repeat = false, string? type = null) Parameters element IElement The element to raise the event on. key Key The keyboard key to pass to the event handler. repeat bool true if a key has been depressed long enough to trigger key repetition, otherwise false. type string The type of the event. Returns Task KeyPressAsync(IElement, KeyboardEventArgs?) Raises the @onkeypress event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of KeyboardEventArgs will be created. public static Task KeyPressAsync(this IElement element, KeyboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs KeyboardEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. KeyUp(IElement, Key, bool, string?) Raises the @onkeyup event on element, passing the provided key to the event handler. public static void KeyUp(this IElement element, Key key, bool repeat = false, string? type = null) Parameters element IElement The element to raise the event on. key Key The keyboard key to pass to the event handler. repeat bool true if a key has been depressed long enough to trigger key repetition, otherwise false. type string The type of the event. KeyUp(IElement, KeyboardEventArgs?) Raises the @onkeyup event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of KeyboardEventArgs will be created. public static void KeyUp(this IElement element, KeyboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs KeyboardEventArgs The event arguments to pass to the event handler. KeyUpAsync(IElement, Key, bool, string?) Raises the @onkeyup event on element, passing the provided key to the event handler. public static Task KeyUpAsync(this IElement element, Key key, bool repeat = false, string? type = null) Parameters element IElement The element to raise the event on. key Key The keyboard key to pass to the event handler. repeat bool true if a key has been depressed long enough to trigger key repetition, otherwise false. type string The type of the event. Returns Task KeyUpAsync(IElement, KeyboardEventArgs?) Raises the @onkeyup event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of KeyboardEventArgs will be created. public static Task KeyUpAsync(this IElement element, KeyboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs KeyboardEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Load(IElement, ProgressEventArgs?) Raises the @onload event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static void Load(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. LoadAsync(IElement, ProgressEventArgs?) Raises the @onload event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static Task LoadAsync(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. LoadEnd(IElement, ProgressEventArgs?) Raises the @onloadend event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static void LoadEnd(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. LoadEndAsync(IElement, ProgressEventArgs?) Raises the @onloadend event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static Task LoadEndAsync(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. LoadStart(IElement, ProgressEventArgs?) Raises the @onloadstart event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static void LoadStart(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. LoadStartAsync(IElement, ProgressEventArgs?) Raises the @onloadstart event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static Task LoadStartAsync(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. LoadedData(IElement, EventArgs?) Raises the @onloadeddata event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void LoadedData(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. LoadedDataAsync(IElement, EventArgs?) Raises the @onloadeddata event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task LoadedDataAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. LoadedMetadata(IElement, EventArgs?) Raises the @onloadedmetadata event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void LoadedMetadata(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. LoadedMetadataAsync(IElement, EventArgs?) Raises the @onloadedmetadata event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task LoadedMetadataAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. LostPointerCapture(IElement, PointerEventArgs?) Raises the @onlostpointercapture event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void LostPointerCapture(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. LostPointerCaptureAsync(IElement, PointerEventArgs?) Raises the @onlostpointercapture event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task LostPointerCaptureAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. MouseDown(IElement, MouseEventArgs?) Raises the @onmousedown event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void MouseDown(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. MouseDownAsync(IElement, MouseEventArgs?) Raises the @onmousedown event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task MouseDownAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. MouseEnter(IElement, MouseEventArgs?) Raises the @onmouseenter event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void MouseEnter(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. MouseEnterAsync(IElement, MouseEventArgs?) Raises the @onmouseenter event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task MouseEnterAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. MouseLeave(IElement, MouseEventArgs?) Raises the @onmouseleave event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void MouseLeave(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. MouseLeaveAsync(IElement, MouseEventArgs?) Raises the @onmouseleave event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task MouseLeaveAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. MouseMove(IElement, MouseEventArgs?) Raises the @onmousemove event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void MouseMove(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. MouseMoveAsync(IElement, MouseEventArgs?) Raises the @onmousemove event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task MouseMoveAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. MouseOut(IElement, MouseEventArgs?) Raises the @onmouseout event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void MouseOut(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. MouseOutAsync(IElement, MouseEventArgs?) Raises the @onmouseout event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task MouseOutAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. MouseOver(IElement, MouseEventArgs?) Raises the @onmouseover event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void MouseOver(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. MouseOverAsync(IElement, MouseEventArgs?) Raises the @onmouseover event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task MouseOverAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. MouseUp(IElement, MouseEventArgs?) Raises the @onmouseup event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static void MouseUp(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. MouseUpAsync(IElement, MouseEventArgs?) Raises the @onmouseup event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of MouseEventArgs will be created. public static Task MouseUpAsync(this IElement element, MouseEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs MouseEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. MouseWheel(IElement, WheelEventArgs?) Raises the @onmousewheel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of WheelEventArgs will be created. public static void MouseWheel(this IElement element, WheelEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs WheelEventArgs The event arguments to pass to the event handler. MouseWheelAsync(IElement, WheelEventArgs?) Raises the @onmousewheel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of WheelEventArgs will be created. public static Task MouseWheelAsync(this IElement element, WheelEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs WheelEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Paste(IElement, ClipboardEventArgs?) Raises the @onpaste event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ClipboardEventArgs will be created. public static void Paste(this IElement element, ClipboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ClipboardEventArgs The event arguments to pass to the event handler. PasteAsync(IElement, ClipboardEventArgs?) Raises the @onpaste event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ClipboardEventArgs will be created. public static Task PasteAsync(this IElement element, ClipboardEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ClipboardEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Pause(IElement, EventArgs?) Raises the @onpause event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Pause(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. PauseAsync(IElement, EventArgs?) Raises the @onpause event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task PauseAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Play(IElement, EventArgs?) Raises the @onplay event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Play(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. PlayAsync(IElement, EventArgs?) Raises the @onplay event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task PlayAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Playing(IElement, EventArgs?) Raises the @onplaying event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Playing(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. PlayingAsync(IElement, EventArgs?) Raises the @onplaying event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task PlayingAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerCancel(IElement, PointerEventArgs?) Raises the @onpointercancel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void PointerCancel(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. PointerCancelAsync(IElement, PointerEventArgs?) Raises the @onpointercancel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task PointerCancelAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerDown(IElement, PointerEventArgs?) Raises the @onpointerdown event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void PointerDown(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. PointerDownAsync(IElement, PointerEventArgs?) Raises the @onpointerdown event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task PointerDownAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerEnter(IElement, PointerEventArgs?) Raises the @onpointerenter event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void PointerEnter(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. PointerEnterAsync(IElement, PointerEventArgs?) Raises the @onpointerenter event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task PointerEnterAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerLeave(IElement, PointerEventArgs?) Raises the @onpointerleave event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void PointerLeave(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. PointerLeaveAsync(IElement, PointerEventArgs?) Raises the @onpointerleave event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task PointerLeaveAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerLockChange(IElement, EventArgs?) Raises the @onpointerlockchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void PointerLockChange(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. PointerLockChangeAsync(IElement, EventArgs?) Raises the @onpointerlockchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task PointerLockChangeAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerLockError(IElement, EventArgs?) Raises the @onpointerlockerror event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void PointerLockError(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. PointerLockErrorAsync(IElement, EventArgs?) Raises the @onpointerlockerror event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task PointerLockErrorAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerMove(IElement, PointerEventArgs?) Raises the @onpointermove event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void PointerMove(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. PointerMoveAsync(IElement, PointerEventArgs?) Raises the @onpointermove event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task PointerMoveAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerOut(IElement, PointerEventArgs?) Raises the @onpointerout event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void PointerOut(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. PointerOutAsync(IElement, PointerEventArgs?) Raises the @onpointerout event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task PointerOutAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerOver(IElement, PointerEventArgs?) Raises the @onpointerover event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void PointerOver(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. PointerOverAsync(IElement, PointerEventArgs?) Raises the @onpointerover event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task PointerOverAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. PointerUp(IElement, PointerEventArgs?) Raises the @onpointerup event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static void PointerUp(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. PointerUpAsync(IElement, PointerEventArgs?) Raises the @onpointerup event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of PointerEventArgs will be created. public static Task PointerUpAsync(this IElement element, PointerEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs PointerEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Progress(IElement, ProgressEventArgs?) Raises the @onprogress event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static void Progress(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. ProgressAsync(IElement, ProgressEventArgs?) Raises the @onprogress event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static Task ProgressAsync(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. RateChange(IElement, EventArgs?) Raises the @onratechange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void RateChange(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. RateChangeAsync(IElement, EventArgs?) Raises the @onratechange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task RateChangeAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. ReadyStateChange(IElement, EventArgs?) Raises the @onreadystatechange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void ReadyStateChange(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. ReadyStateChangeAsync(IElement, EventArgs?) Raises the @onreadystatechange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task ReadyStateChangeAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Reset(IElement, EventArgs?) Raises the @onreset event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Reset(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. ResetAsync(IElement, EventArgs?) Raises the @onreset event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task ResetAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Scroll(IElement, EventArgs?) Raises the @onscroll event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Scroll(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. ScrollAsync(IElement, EventArgs?) Raises the @onscroll event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task ScrollAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Seeked(IElement, EventArgs?) Raises the @onseeked event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Seeked(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. SeekedAsync(IElement, EventArgs?) Raises the @onseeked event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task SeekedAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Seeking(IElement, EventArgs?) Raises the @onseeking event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Seeking(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. SeekingAsync(IElement, EventArgs?) Raises the @onseeking event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task SeekingAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Select(IElement, EventArgs?) Raises the @onselect event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Select(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. SelectAsync(IElement, EventArgs?) Raises the @onselect event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task SelectAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. SelectStart(IElement, EventArgs?) Raises the @onselectstart event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void SelectStart(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. SelectStartAsync(IElement, EventArgs?) Raises the @onselectstart event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task SelectStartAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. SelectionChange(IElement, EventArgs?) Raises the @onselectionchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void SelectionChange(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. SelectionChangeAsync(IElement, EventArgs?) Raises the @onselectionchange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task SelectionChangeAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Stalled(IElement, EventArgs?) Raises the @onstalled event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Stalled(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. StalledAsync(IElement, EventArgs?) Raises the @onstalled event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task StalledAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Stop(IElement, EventArgs?) Raises the @onstop event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Stop(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. StopAsync(IElement, EventArgs?) Raises the @onstop event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task StopAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Submit(IElement, EventArgs?) Raises the @onsubmit event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Submit(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. SubmitAsync(IElement, EventArgs?) Raises the @onsubmit event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task SubmitAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Suspend(IElement, EventArgs?) Raises the @onsuspend event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Suspend(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. SuspendAsync(IElement, EventArgs?) Raises the @onsuspend event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task SuspendAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. TimeOut(IElement, ProgressEventArgs?) Raises the @ontimeout event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static void TimeOut(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. TimeOutAsync(IElement, ProgressEventArgs?) Raises the @ontimeout event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of ProgressEventArgs will be created. public static Task TimeOutAsync(this IElement element, ProgressEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs ProgressEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. TimeUpdate(IElement, EventArgs?) Raises the @ontimeupdate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void TimeUpdate(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. TimeUpdateAsync(IElement, EventArgs?) Raises the @ontimeupdate event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task TimeUpdateAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Toggle(IElement, EventArgs?) Raises the @ontoggle event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Toggle(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. ToggleAsync(IElement, EventArgs?) Raises the @ontoggle event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task ToggleAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. TouchCancel(IElement, TouchEventArgs?) Raises the @ontouchcancel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static void TouchCancel(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. TouchCancelAsync(IElement, TouchEventArgs?) Raises the @ontouchcancel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static Task TouchCancelAsync(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. TouchEnd(IElement, TouchEventArgs?) Raises the @ontouchend event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static void TouchEnd(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. TouchEndAsync(IElement, TouchEventArgs?) Raises the @ontouchend event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static Task TouchEndAsync(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. TouchEnter(IElement, TouchEventArgs?) Raises the @ontouchenter event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static void TouchEnter(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. TouchEnterAsync(IElement, TouchEventArgs?) Raises the @ontouchenter event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static Task TouchEnterAsync(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. TouchLeave(IElement, TouchEventArgs?) Raises the @ontouchleave event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static void TouchLeave(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. TouchLeaveAsync(IElement, TouchEventArgs?) Raises the @ontouchleave event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static Task TouchLeaveAsync(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. TouchMove(IElement, TouchEventArgs?) Raises the @ontouchmove event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static void TouchMove(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. TouchMoveAsync(IElement, TouchEventArgs?) Raises the @ontouchmove event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static Task TouchMoveAsync(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. TouchStart(IElement, TouchEventArgs?) Raises the @ontouchstart event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static void TouchStart(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. TouchStartAsync(IElement, TouchEventArgs?) Raises the @ontouchstart event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of TouchEventArgs will be created. public static Task TouchStartAsync(this IElement element, TouchEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs TouchEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. VolumeChange(IElement, EventArgs?) Raises the @onvolumechange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void VolumeChange(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. VolumeChangeAsync(IElement, EventArgs?) Raises the @onvolumechange event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task VolumeChangeAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Waiting(IElement, EventArgs?) Raises the @onwaiting event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static void Waiting(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. WaitingAsync(IElement, EventArgs?) Raises the @onwaiting event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of EventArgs will be created. public static Task WaitingAsync(this IElement element, EventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done. Wheel(IElement, WheelEventArgs?) Raises the @onwheel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of WheelEventArgs will be created. public static void Wheel(this IElement element, WheelEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs WheelEventArgs The event arguments to pass to the event handler. WheelAsync(IElement, WheelEventArgs?) Raises the @onwheel event on element, passing the provided eventArgs to the event handler. If eventArgs is null, a new instance of WheelEventArgs will be created. public static Task WheelAsync(this IElement element, WheelEventArgs? eventArgs = null) Parameters element IElement The element to raise the event on. eventArgs WheelEventArgs The event arguments to pass to the event handler. Returns Task A task that completes when the event handler is done."
  },
  "api/Bunit.Extensions.WaitForHelpers.WaitForFailedException.html": {
    "href": "api/Bunit.Extensions.WaitForHelpers.WaitForFailedException.html",
    "title": "Class WaitForFailedException | bUnit",
    "keywords": "Class WaitForFailedException Namespace Bunit.Extensions.WaitForHelpers Assembly bunit.dll Represents an exception thrown when the WaitForHelper<T, TComponent> does not complete successfully. public sealed class WaitForFailedException : Exception, ISerializable Inheritance object Exception WaitForFailedException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors WaitForFailedException(string?, Exception?) Initializes a new instance of the WaitForFailedException class. public WaitForFailedException(string? errorMessage, Exception? innerException = null) Parameters errorMessage string innerException Exception"
  },
  "api/Bunit.Extensions.WaitForHelpers.html": {
    "href": "api/Bunit.Extensions.WaitForHelpers.html",
    "title": "Namespace Bunit.Extensions.WaitForHelpers | bUnit",
    "keywords": "Namespace Bunit.Extensions.WaitForHelpers Classes WaitForFailedException Represents an exception thrown when the WaitForHelper<T, TComponent> does not complete successfully."
  },
  "api/Bunit.FocusAsyncAssertJSInteropExtensions.html": {
    "href": "api/Bunit.FocusAsyncAssertJSInteropExtensions.html",
    "title": "Class FocusAsyncAssertJSInteropExtensions | bUnit",
    "keywords": "Class FocusAsyncAssertJSInteropExtensions Namespace Bunit Assembly bunit.dll Extensions methods for verifying FocusAsync(ElementReference) method calls. public static class FocusAsyncAssertJSInteropExtensions Inheritance object FocusAsyncAssertJSInteropExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods VerifyFocusAsyncInvoke(BunitJSInterop, int, string?) Verifies that the FocusAsync(ElementReference) method has been invoked calledTimes times. public static IReadOnlyList<JSRuntimeInvocation> VerifyFocusAsyncInvoke(this BunitJSInterop handler, int calledTimes, string? userMessage = null) Parameters handler BunitJSInterop Handler to verify against. calledTimes int The number of times the invocation is expected to have been called. userMessage string A custom user message to display if the assertion fails. Returns IReadOnlyList<JSRuntimeInvocation> The JSRuntimeInvocation. VerifyFocusAsyncInvoke(BunitJSInterop, string?) Verifies that the FocusAsync(ElementReference) method has been invoked one time. public static JSRuntimeInvocation VerifyFocusAsyncInvoke(this BunitJSInterop handler, string? userMessage = null) Parameters handler BunitJSInterop Handler to verify against. userMessage string A custom user message to display if the assertion fails. Returns JSRuntimeInvocation The JSRuntimeInvocation."
  },
  "api/Bunit.FocusOnNavigateAssertJSInteropExtensions.html": {
    "href": "api/Bunit.FocusOnNavigateAssertJSInteropExtensions.html",
    "title": "Class FocusOnNavigateAssertJSInteropExtensions | bUnit",
    "keywords": "Class FocusOnNavigateAssertJSInteropExtensions Namespace Bunit Assembly bunit.dll Extensions methods for verifying FocusOnNavigate focus calls. public static class FocusOnNavigateAssertJSInteropExtensions Inheritance object FocusOnNavigateAssertJSInteropExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods VerifyFocusOnNavigateInvoke(BunitJSInterop, int, string?) Verifies that the FocusOnNavigate component has set focus calledTimes times. public static IReadOnlyList<JSRuntimeInvocation> VerifyFocusOnNavigateInvoke(this BunitJSInterop handler, int calledTimes, string? userMessage = null) Parameters handler BunitJSInterop Handler to verify against. calledTimes int The number of times the invocation is expected to have been called. userMessage string A custom user message to display if the assertion fails. Returns IReadOnlyList<JSRuntimeInvocation> The JSRuntimeInvocation. VerifyFocusOnNavigateInvoke(BunitJSInterop, string?) Verifies that the FocusOnNavigate component has set focus one time. public static JSRuntimeInvocation VerifyFocusOnNavigateInvoke(this BunitJSInterop handler, string? userMessage = null) Parameters handler BunitJSInterop Handler to verify against. userMessage string A custom user message to display if the assertion fails. Returns JSRuntimeInvocation The JSRuntimeInvocation."
  },
  "api/Bunit.HtmlEqualException.html": {
    "href": "api/Bunit.HtmlEqualException.html",
    "title": "Class HtmlEqualException | bUnit",
    "keywords": "Class HtmlEqualException Namespace Bunit Assembly bunit.dll Represents an differences between pieces of markup. public sealed class HtmlEqualException : ActualExpectedAssertException, ISerializable Inheritance object Exception ActualExpectedAssertException HtmlEqualException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors HtmlEqualException(IEnumerable<IDiff>, IMarkupFormattable, IMarkupFormattable, string?) Initializes a new instance of the HtmlEqualException class. public HtmlEqualException(IEnumerable<IDiff> diffs, IMarkupFormattable expected, IMarkupFormattable actual, string? userMessage) Parameters diffs IEnumerable<IDiff> expected IMarkupFormattable actual IMarkupFormattable userMessage string"
  },
  "api/Bunit.IComponentFactory.html": {
    "href": "api/Bunit.IComponentFactory.html",
    "title": "Interface IComponentFactory | bUnit",
    "keywords": "Interface IComponentFactory Namespace Bunit Assembly bunit.dll Represents a component factory. public interface IComponentFactory Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Methods CanCreate(Type) Check if the factory can create a component of type componentType or a replacement for it. bool CanCreate(Type componentType) Parameters componentType Type The type that should be created or replaced. Returns bool True if the factory can create the type; false otherwise. Create(Type) Create a component of type componentType or a replacement for it. IComponent Create(Type componentType) Parameters componentType Type The type of component to create. Returns IComponent"
  },
  "api/Bunit.IRenderedComponent-1.html": {
    "href": "api/Bunit.IRenderedComponent-1.html",
    "title": "Interface IRenderedComponent<TComponent> | bUnit",
    "keywords": "Interface IRenderedComponent<TComponent> Namespace Bunit Assembly bunit.dll Represents a rendered component. public interface IRenderedComponent<out TComponent> : IDisposable where TComponent : IComponent Type Parameters TComponent Inherited Members IDisposable.Dispose() Extension Methods CompareToExtensions.CompareTo<TComponent>(IRenderedComponent<TComponent>, string) CompareToExtensions.CompareTo<TActualComponent, TExpectedComponent>(IRenderedComponent<TActualComponent>, IRenderedComponent<TExpectedComponent>) MarkupMatchesAssertExtensions.MarkupMatches<TComponent>(IRenderedComponent<TComponent>, RenderFragment, string?) MarkupMatchesAssertExtensions.MarkupMatches<TComponent>(IRenderedComponent<TComponent>, string, string?) MarkupMatchesAssertExtensions.MarkupMatches<TActualComponent, TExpectedComponent>(IRenderedComponent<TActualComponent>, IRenderedComponent<TExpectedComponent>, string?) RenderedComponentExtensions.FindAll<TComponent>(IRenderedComponent<TComponent>, string) RenderedComponentExtensions.FindAll<TComponent, TElement>(IRenderedComponent<TComponent>, string) RenderedComponentExtensions.Find<TComponent>(IRenderedComponent<TComponent>, string) RenderedComponentExtensions.Find<TComponent, TElement>(IRenderedComponent<TComponent>, string) RenderedComponentInvokeAsyncExtensions.InvokeAsync<TComponent>(IRenderedComponent<TComponent>, Action) RenderedComponentInvokeAsyncExtensions.InvokeAsync<TComponent>(IRenderedComponent<TComponent>, Func<Task>) RenderedComponentInvokeAsyncExtensions.InvokeAsync<TComponent, T>(IRenderedComponent<TComponent>, Func<Task<T>>) RenderedComponentInvokeAsyncExtensions.InvokeAsync<TComponent, T>(IRenderedComponent<TComponent>, Func<T>) RenderedComponentRenderExtensions.Render<TComponent>(IRenderedComponent<TComponent>, ParameterView) RenderedComponentRenderExtensions.Render<TComponent>(IRenderedComponent<TComponent>, Action<ComponentParameterCollectionBuilder<TComponent>>?) RenderedComponentWaitForHelperExtensions.WaitForAssertionAsync<TComponent>(IRenderedComponent<TComponent>, Action, TimeSpan?) RenderedComponentWaitForHelperExtensions.WaitForAssertion<TComponent>(IRenderedComponent<TComponent>, Action, TimeSpan?) RenderedComponentWaitForHelperExtensions.WaitForElementAsync<TComponent>(IRenderedComponent<TComponent>, string) RenderedComponentWaitForHelperExtensions.WaitForElementAsync<TComponent>(IRenderedComponent<TComponent>, string, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElementAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string) RenderedComponentWaitForHelperExtensions.WaitForElementAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElement<TComponent>(IRenderedComponent<TComponent>, string) RenderedComponentWaitForHelperExtensions.WaitForElement<TComponent>(IRenderedComponent<TComponent>, string, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElement<TComponent, TElement>(IRenderedComponent<TComponent>, string) RenderedComponentWaitForHelperExtensions.WaitForElement<TComponent, TElement>(IRenderedComponent<TComponent>, string, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElementsAsync<TComponent>(IRenderedComponent<TComponent>, string) RenderedComponentWaitForHelperExtensions.WaitForElementsAsync<TComponent>(IRenderedComponent<TComponent>, string, int) RenderedComponentWaitForHelperExtensions.WaitForElementsAsync<TComponent>(IRenderedComponent<TComponent>, string, int, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElementsAsync<TComponent>(IRenderedComponent<TComponent>, string, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElementsAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string) RenderedComponentWaitForHelperExtensions.WaitForElementsAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string, int) RenderedComponentWaitForHelperExtensions.WaitForElementsAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string, int, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElementsAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElements<TComponent>(IRenderedComponent<TComponent>, string) RenderedComponentWaitForHelperExtensions.WaitForElements<TComponent>(IRenderedComponent<TComponent>, string, int) RenderedComponentWaitForHelperExtensions.WaitForElements<TComponent>(IRenderedComponent<TComponent>, string, int, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElements<TComponent>(IRenderedComponent<TComponent>, string, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElements<TComponent, TElement>(IRenderedComponent<TComponent>, string) RenderedComponentWaitForHelperExtensions.WaitForElements<TComponent, TElement>(IRenderedComponent<TComponent>, string, int) RenderedComponentWaitForHelperExtensions.WaitForElements<TComponent, TElement>(IRenderedComponent<TComponent>, string, int, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForElements<TComponent, TElement>(IRenderedComponent<TComponent>, string, TimeSpan) RenderedComponentWaitForHelperExtensions.WaitForStateAsync<TComponent>(IRenderedComponent<TComponent>, Func<bool>, TimeSpan?) RenderedComponentWaitForHelperExtensions.WaitForState<TComponent>(IRenderedComponent<TComponent>, Func<bool>, TimeSpan?) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Properties ComponentId Gets the id of the rendered component or fragment. int ComponentId { get; } Property Value int Instance Gets the component under test. TComponent Instance { get; } Property Value TComponent IsDisposed Gets a value indicating whether the rendered component or fragment has been disposed by the BunitRenderer. bool IsDisposed { get; } Property Value bool Markup Gets the HTML markup from the rendered fragment/component. string Markup { get; } Property Value string Nodes Gets the AngleSharp AngleSharp.Dom.INodeList based on the HTML markup from the rendered fragment/component. INodeList Nodes { get; } Property Value INodeList RenderCount Gets the total number times the fragment has been through its render life-cycle. int RenderCount { get; } Property Value int Services Gets the IServiceProvider used when rendering the component. IServiceProvider Services { get; } Property Value IServiceProvider Events OnAfterRender Adds or removes an event handler that will be triggered after each render of this IRenderedComponent<TComponent>. event EventHandler? OnAfterRender Event Type EventHandler OnMarkupUpdated An event that is raised after the markup of the IRenderedComponent<TComponent> is updated. event EventHandler? OnMarkupUpdated Event Type EventHandler"
  },
  "api/Bunit.InputFileContent.html": {
    "href": "api/Bunit.InputFileContent.html",
    "title": "Class InputFileContent | bUnit",
    "keywords": "Class InputFileContent Namespace Bunit Assembly bunit.dll Represents a file which can be uploaded. public class InputFileContent Inheritance object InputFileContent Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Methods CreateFromBinary(byte[], string?, DateTimeOffset?, string?) Creates an InputFileContent instance which has binary content. public static InputFileContent CreateFromBinary(byte[] fileContent, string? fileName = null, DateTimeOffset? lastChanged = null, string? contentType = null) Parameters fileContent byte[] The binary content. fileName string The name of the file. lastChanged DateTimeOffset? The last modified date of the file. contentType string The mime type of the file. Returns InputFileContent CreateFromText(string, string?, DateTimeOffset?, string?) Creates an InputFileContent instance which has string content. public static InputFileContent CreateFromText(string fileContent, string? fileName = null, DateTimeOffset? lastChanged = null, string? contentType = null) Parameters fileContent string The string content. fileName string The name of the file. lastChanged DateTimeOffset? The last modified date of the file. contentType string The mime type of the file. Returns InputFileContent"
  },
  "api/Bunit.InputFileExtensions.html": {
    "href": "api/Bunit.InputFileExtensions.html",
    "title": "Class InputFileExtensions | bUnit",
    "keywords": "Class InputFileExtensions Namespace Bunit Assembly bunit.dll Extensions for the InputFile component. public static class InputFileExtensions Inheritance object InputFileExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods UploadFiles(IRenderedComponent<InputFile>, params InputFileContent[]) Uploads multiple files and invokes the OnChange event. public static void UploadFiles(this IRenderedComponent<InputFile> inputFileComponent, params InputFileContent[] files) Parameters inputFileComponent IRenderedComponent<InputFile> The InputFile component which will upload the files. files InputFileContent[] Files to upload."
  },
  "api/Bunit.InvocationMatcher.html": {
    "href": "api/Bunit.InvocationMatcher.html",
    "title": "Delegate InvocationMatcher | bUnit",
    "keywords": "Delegate InvocationMatcher Namespace Bunit Assembly bunit.dll Represents a invocation matcher / predicate, that is used to determine if a JSRuntimeInvocationHandler<TResult> matches a specific JSRuntimeInvocation. public delegate bool InvocationMatcher(JSRuntimeInvocation invocation) Parameters invocation JSRuntimeInvocation The invocation to match against. Returns bool True if the JSRuntimeInvocationHandler<TResult> can handle the invocation, false otherwise. Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors InvocationMatcher(object, nint) public InvocationMatcher(object @object, nint method) Parameters object object method nint Methods BeginInvoke(JSRuntimeInvocation, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(JSRuntimeInvocation invocation, AsyncCallback callback, object @object) Parameters invocation JSRuntimeInvocation callback AsyncCallback object object Returns IAsyncResult EndInvoke(IAsyncResult) public virtual bool EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns bool Invoke(JSRuntimeInvocation) public virtual bool Invoke(JSRuntimeInvocation invocation) Parameters invocation JSRuntimeInvocation Returns bool"
  },
  "api/Bunit.JSInvokeCountExpectedException.html": {
    "href": "api/Bunit.JSInvokeCountExpectedException.html",
    "title": "Class JSInvokeCountExpectedException | bUnit",
    "keywords": "Class JSInvokeCountExpectedException Namespace Bunit Assembly bunit.dll Represents a number of unexpected invocation to a BunitJSInterop. public sealed class JSInvokeCountExpectedException : Exception, ISerializable Inheritance object Exception JSInvokeCountExpectedException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors JSInvokeCountExpectedException(string, int, int, string, string?) Initializes a new instance of the JSInvokeCountExpectedException class. public JSInvokeCountExpectedException(string identifier, int expectedCount, int actualCount, string assertMethod, string? userMessage = null) Parameters identifier string expectedCount int actualCount int assertMethod string userMessage string Properties ActualInvocationCount Gets the actual invocation count. public int ActualInvocationCount { get; } Property Value int ExpectedInvocationCount Gets the expected invocation count. public int ExpectedInvocationCount { get; } Property Value int Identifier Gets the identifier. public string Identifier { get; } Property Value string"
  },
  "api/Bunit.JSRuntimeAssertExtensions.html": {
    "href": "api/Bunit.JSRuntimeAssertExtensions.html",
    "title": "Class JSRuntimeAssertExtensions | bUnit",
    "keywords": "Class JSRuntimeAssertExtensions Namespace Bunit Assembly bunit.dll Assert extensions for JSRuntimeMock. public static class JSRuntimeAssertExtensions Inheritance object JSRuntimeAssertExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods ShouldBeElementReferenceTo(object?, IElement) Verifies that an argument actualArgument passed to an JSRuntime invocation is an ElementReference to the expectedTargetElement. public static void ShouldBeElementReferenceTo(this object? actualArgument, IElement expectedTargetElement) Parameters actualArgument object object to verify. expectedTargetElement IElement expected targeted element. VerifyInvoke(BunitJSInterop, string, int, string?) Verifies that the identifier has been invoked calledTimes times. public static IReadOnlyList<JSRuntimeInvocation> VerifyInvoke(this BunitJSInterop jsInterop, string identifier, int calledTimes, string? userMessage = null) Parameters jsInterop BunitJSInterop The bUnit JSInterop to verify against. identifier string Identifier of invocation that should have been invoked. calledTimes int The number of times the invocation is expected to have been called. userMessage string A custom user message to display if the assertion fails. Returns IReadOnlyList<JSRuntimeInvocation> The JSRuntimeInvocation. VerifyInvoke(BunitJSInterop, string, string?) Verifies that the identifier has been invoked one time. public static JSRuntimeInvocation VerifyInvoke(this BunitJSInterop jsInterop, string identifier, string? userMessage = null) Parameters jsInterop BunitJSInterop The bUnit JSInterop to verify against. identifier string Identifier of invocation that should have been invoked. userMessage string A custom user message to display if the assertion fails. Returns JSRuntimeInvocation The JSRuntimeInvocation. VerifyInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, int, string?) Verifies that the identifier has been invoked calledTimes times. public static IReadOnlyList<JSRuntimeInvocation> VerifyInvoke<TResult>(this JSRuntimeInvocationHandlerBase<TResult> handler, string identifier, int calledTimes, string? userMessage = null) Parameters handler JSRuntimeInvocationHandlerBase<TResult> Handler to verify against. identifier string Identifier of invocation that should have been invoked. calledTimes int The number of times the invocation is expected to have been called. userMessage string A custom user message to display if the assertion fails. Returns IReadOnlyList<JSRuntimeInvocation> The JSRuntimeInvocation. Type Parameters TResult VerifyInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, string?) Verifies that the identifier has been invoked one time. public static JSRuntimeInvocation VerifyInvoke<TResult>(this JSRuntimeInvocationHandlerBase<TResult> handler, string identifier, string? userMessage = null) Parameters handler JSRuntimeInvocationHandlerBase<TResult> Handler to verify against. identifier string Identifier of invocation that should have been invoked. userMessage string A custom user message to display if the assertion fails. Returns JSRuntimeInvocation The JSRuntimeInvocation. Type Parameters TResult VerifyNotInvoke(BunitJSInterop, string, string?) Verifies that the identifier was never invoked on the jsInterop. public static void VerifyNotInvoke(this BunitJSInterop jsInterop, string identifier, string? userMessage = null) Parameters jsInterop BunitJSInterop The bUnit JSInterop to verify against. identifier string Identifier of invocation that should not have happened. userMessage string A custom user message to display if the assertion fails. VerifyNotInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, string?) Verifies that the identifier was never invoked on the handler. public static void VerifyNotInvoke<TResult>(this JSRuntimeInvocationHandlerBase<TResult> handler, string identifier, string? userMessage = null) Parameters handler JSRuntimeInvocationHandlerBase<TResult> Handler to verify against. identifier string Identifier of invocation that should not have happened. userMessage string A custom user message to display if the assertion fails. Type Parameters TResult"
  },
  "api/Bunit.JSRuntimeInvocation.html": {
    "href": "api/Bunit.JSRuntimeInvocation.html",
    "title": "Struct JSRuntimeInvocation | bUnit",
    "keywords": "Struct JSRuntimeInvocation Namespace Bunit Assembly bunit.dll Represents an invocation of JavaScript via the JSRuntime Mock. public readonly struct JSRuntimeInvocation : IEquatable<JSRuntimeInvocation> Implements IEquatable<JSRuntimeInvocation> Inherited Members ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors JSRuntimeInvocation(string, CancellationToken?, object?[]?, Type, string) Initializes a new instance of the JSRuntimeInvocation struct. public JSRuntimeInvocation(string identifier, CancellationToken? cancellationToken, object?[]? args, Type resultType, string invocationMethodName) Parameters identifier string cancellationToken CancellationToken? args object[] resultType Type invocationMethodName string JSRuntimeInvocation(string, object?[], Type, string) Initializes a new instance of the JSRuntimeInvocation struct. public JSRuntimeInvocation(string identifier, object?[] args, Type resultType, string invocationMethodName) Parameters identifier string args object[] resultType Type invocationMethodName string JSRuntimeInvocation(string, Type, string) Initializes a new instance of the JSRuntimeInvocation struct. public JSRuntimeInvocation(string identifier, Type resultType, string invocationMethodName) Parameters identifier string resultType Type invocationMethodName string Properties Arguments Gets the arguments used in the invocation. public IReadOnlyList<object?> Arguments { get; } Property Value IReadOnlyList<object> CancellationToken Gets the cancellation token used in the invocation, if any. public CancellationToken? CancellationToken { get; } Property Value CancellationToken? Identifier Gets the identifier used in the invocation. public string Identifier { get; } Property Value string InvocationMethodName Gets the name of the method that initiated the invocation, e.g. InvokeAsync or Invoke. public string InvocationMethodName { get; } Property Value string IsVoidResultInvocation Gets whether the invocation has a void return type. public bool IsVoidResultInvocation { get; } Property Value bool ResultType Gets the result type of the invocation. If IsVoidResultInvocation then this will be of type object. public Type ResultType { get; } Property Value Type Methods Equals(JSRuntimeInvocation) public bool Equals(JSRuntimeInvocation other) Parameters other JSRuntimeInvocation Returns bool Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int Operators operator ==(JSRuntimeInvocation, JSRuntimeInvocation) Verify whether left and right JSRuntimeInvocation is equal. public static bool operator ==(JSRuntimeInvocation left, JSRuntimeInvocation right) Parameters left JSRuntimeInvocation right JSRuntimeInvocation Returns bool operator !=(JSRuntimeInvocation, JSRuntimeInvocation) Verify whether left and right JSRuntimeInvocation is not equal. public static bool operator !=(JSRuntimeInvocation left, JSRuntimeInvocation right) Parameters left JSRuntimeInvocation right JSRuntimeInvocation Returns bool"
  },
  "api/Bunit.JSRuntimeInvocationDictionary.html": {
    "href": "api/Bunit.JSRuntimeInvocationDictionary.html",
    "title": "Class JSRuntimeInvocationDictionary | bUnit",
    "keywords": "Class JSRuntimeInvocationDictionary Namespace Bunit Assembly bunit.dll Represents a dictionary of JSRuntimeInvocation, keyed by their identifier. public sealed class JSRuntimeInvocationDictionary : IReadOnlyCollection<JSRuntimeInvocation>, IEnumerable<JSRuntimeInvocation>, IEnumerable Inheritance object JSRuntimeInvocationDictionary Implements IReadOnlyCollection<JSRuntimeInvocation> IEnumerable<JSRuntimeInvocation> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors JSRuntimeInvocationDictionary() public JSRuntimeInvocationDictionary() Properties Count Gets the total number of invocations registered in the dictionary. public int Count { get; } Property Value int Identifiers Gets a read only collection of all the identifiers used in invocations in this dictionary. public IReadOnlyCollection<string> Identifiers { get; } Property Value IReadOnlyCollection<string> this[string] Gets all invocations for a specific identifier. public IReadOnlyList<JSRuntimeInvocation> this[string identifier] { get; } Parameters identifier string The identifier to get invocations for. Property Value IReadOnlyList<JSRuntimeInvocation> An IReadOnlyList<T>. Methods GetEnumerator() Gets an IEnumerator<T> that will iterate over all invocations in the dictionary. public IEnumerator<JSRuntimeInvocation> GetEnumerator() Returns IEnumerator<JSRuntimeInvocation> An iterator with all the JSRuntimeInvocation registered in this dictionary."
  },
  "api/Bunit.JSRuntimeInvocationHandler-1.html": {
    "href": "api/Bunit.JSRuntimeInvocationHandler-1.html",
    "title": "Class JSRuntimeInvocationHandler<TResult> | bUnit",
    "keywords": "Class JSRuntimeInvocationHandler<TResult> Namespace Bunit Assembly bunit.dll Represents a handler for an invocation of a JavaScript function with specific arguments and returns TResult. public class JSRuntimeInvocationHandler<TResult> : JSRuntimeInvocationHandlerBase<TResult>, IDisposable Type Parameters TResult The expect result type. Inheritance object JSRuntimeInvocationHandlerBase<TResult> JSRuntimeInvocationHandler<TResult> Implements IDisposable Inherited Members JSRuntimeInvocationHandlerBase<TResult>.SetCanceledBase() JSRuntimeInvocationHandlerBase<TResult>.SetExceptionBase<TException>(TException) JSRuntimeInvocationHandlerBase<TResult>.SetResultBase(TResult) JSRuntimeInvocationHandlerBase<TResult>.HandleAsync(JSRuntimeInvocation) JSRuntimeInvocationHandlerBase<TResult>.Dispose() JSRuntimeInvocationHandlerBase<TResult>.Dispose(bool) JSRuntimeInvocationHandlerBase<TResult>.IsVoidResultHandler JSRuntimeInvocationHandlerBase<TResult>.IsCatchAllHandler JSRuntimeInvocationHandlerBase<TResult>.Invocations object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.VerifyInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, int, string?) JSRuntimeAssertExtensions.VerifyInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, string?) JSRuntimeAssertExtensions.VerifyNotInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, string?) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors JSRuntimeInvocationHandler(InvocationMatcher, bool) Initializes a new instance of the JSRuntimeInvocationHandler<TResult> class. protected JSRuntimeInvocationHandler(InvocationMatcher matcher, bool isCatchAllHandler) Parameters matcher InvocationMatcher An invocation matcher used to determine if the handler should handle an invocation. isCatchAllHandler bool Set to true if this handler is a catch all handler, that should only be used if there are no other non-catch all handlers available. Methods SetCanceled() Marks the Task<TResult> that invocations will receive as canceled. public JSRuntimeInvocationHandler<TResult> SetCanceled() Returns JSRuntimeInvocationHandler<TResult> This handler to allow calls to be chained. SetException<TException>(TException) Sets the TException exception that invocations will receive. public JSRuntimeInvocationHandler<TResult> SetException<TException>(TException exception) where TException : Exception Parameters exception TException The exception to set. Returns JSRuntimeInvocationHandler<TResult> This handler to allow calls to be chained. Type Parameters TException SetResult(TResult) Sets the TResult result that invocations will receive. public JSRuntimeInvocationHandler<TResult> SetResult(TResult result) Parameters result TResult The result to pass to callers. Returns JSRuntimeInvocationHandler<TResult> This handler to allow calls to be chained."
  },
  "api/Bunit.JSRuntimeInvocationHandler.html": {
    "href": "api/Bunit.JSRuntimeInvocationHandler.html",
    "title": "Class JSRuntimeInvocationHandler | bUnit",
    "keywords": "Class JSRuntimeInvocationHandler Namespace Bunit Assembly bunit.dll Represents a handler for an invocation of a JavaScript function which returns nothing, with specific arguments. public class JSRuntimeInvocationHandler : JSRuntimeInvocationHandlerBase<IJSVoidResult>, IDisposable Inheritance object JSRuntimeInvocationHandlerBase<IJSVoidResult> JSRuntimeInvocationHandler Implements IDisposable Inherited Members JSRuntimeInvocationHandlerBase<IJSVoidResult>.SetCanceledBase() JSRuntimeInvocationHandlerBase<IJSVoidResult>.SetExceptionBase<TException>(TException) JSRuntimeInvocationHandlerBase<IJSVoidResult>.SetResultBase(IJSVoidResult) JSRuntimeInvocationHandlerBase<IJSVoidResult>.HandleAsync(JSRuntimeInvocation) JSRuntimeInvocationHandlerBase<IJSVoidResult>.Dispose() JSRuntimeInvocationHandlerBase<IJSVoidResult>.Dispose(bool) JSRuntimeInvocationHandlerBase<IJSVoidResult>.IsCatchAllHandler JSRuntimeInvocationHandlerBase<IJSVoidResult>.Invocations object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.VerifyInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, int, string?) JSRuntimeAssertExtensions.VerifyInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, string?) JSRuntimeAssertExtensions.VerifyNotInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, string?) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors JSRuntimeInvocationHandler(InvocationMatcher, bool) Initializes a new instance of the JSRuntimeInvocationHandler class. protected JSRuntimeInvocationHandler(InvocationMatcher matcher, bool isCatchAllHandler) Parameters matcher InvocationMatcher An invocation matcher used to determine if the handler should handle an invocation. isCatchAllHandler bool Set to true if this handler is a catch all handler, that should only be used if there are no other non-catch all handlers available. Properties IsVoidResultHandler Gets a value indicating whether this handler is set up to handle calls to InvokeVoidAsync(string, object[]). public override sealed bool IsVoidResultHandler { get; } Property Value bool Methods SetCanceled() Marks the Task that invocations will receive as canceled. public JSRuntimeInvocationHandler SetCanceled() Returns JSRuntimeInvocationHandler This handler to allow calls to be chained. SetException<TException>(TException) Sets the TException exception that invocations will receive. public JSRuntimeInvocationHandler SetException<TException>(TException exception) where TException : Exception Parameters exception TException The exception to set. Returns JSRuntimeInvocationHandler This handler to allow calls to be chained. Type Parameters TException SetVoidResult() Completes the current awaiting void invocation requests. public JSRuntimeInvocationHandler SetVoidResult() Returns JSRuntimeInvocationHandler This handler to allow calls to be chained."
  },
  "api/Bunit.JSRuntimeInvocationHandlerBase-1.html": {
    "href": "api/Bunit.JSRuntimeInvocationHandlerBase-1.html",
    "title": "Class JSRuntimeInvocationHandlerBase<TResult> | bUnit",
    "keywords": "Class JSRuntimeInvocationHandlerBase<TResult> Namespace Bunit Assembly bunit.dll Represents an invocation handler for JSRuntimeInvocation instances. public abstract class JSRuntimeInvocationHandlerBase<TResult> : IDisposable Type Parameters TResult Inheritance object JSRuntimeInvocationHandlerBase<TResult> Implements IDisposable Derived JSRuntimeInvocationHandler JSRuntimeInvocationHandler<TResult> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.VerifyInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, int, string?) JSRuntimeAssertExtensions.VerifyInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, string?) JSRuntimeAssertExtensions.VerifyNotInvoke<TResult>(JSRuntimeInvocationHandlerBase<TResult>, string, string?) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors JSRuntimeInvocationHandlerBase(InvocationMatcher, bool) Initializes a new instance of the JSRuntimeInvocationHandlerBase<TResult> class. protected JSRuntimeInvocationHandlerBase(InvocationMatcher matcher, bool isCatchAllHandler) Parameters matcher InvocationMatcher An invocation matcher used to determine if the handler should handle an invocation. isCatchAllHandler bool Set to true if this handler is a catch all handler, that should only be used if there are no other non-catch all handlers available. Properties Invocations Gets the invocations that this JSRuntimeInvocationHandler<TResult> has matched with. public JSRuntimeInvocationDictionary Invocations { get; } Property Value JSRuntimeInvocationDictionary IsCatchAllHandler Gets a value indicating whether this handler is considered a catch all handler for invocations with TResult as the return type. public bool IsCatchAllHandler { get; } Property Value bool IsVoidResultHandler Gets a value indicating whether this handler is set up to handle calls to InvokeVoidAsync(string, object[]). public virtual bool IsVoidResultHandler { get; } Property Value bool Methods Dispose() public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool HandleAsync(JSRuntimeInvocation) Call this to have the this handler handle the invocation. protected virtual Task<TResult> HandleAsync(JSRuntimeInvocation invocation) Parameters invocation JSRuntimeInvocation Invocation to handle. Returns Task<TResult> Remarks Note to implementors: Always call the HandleAsync(JSRuntimeInvocation) method when overriding it in a sub class. It will make sure the invocation is correctly registered in the Invocations dictionary. SetCanceledBase() Marks the Task<TResult> that invocations will receive as canceled. protected void SetCanceledBase() SetExceptionBase<TException>(TException) Sets the TException exception that invocations will receive. protected void SetExceptionBase<TException>(TException exception) where TException : Exception Parameters exception TException The type of exception to pass to the callers. Type Parameters TException SetResultBase(TResult) Sets the TResult result that invocations will receive. protected void SetResultBase(TResult result) Parameters result TResult The type of result to pass to the callers."
  },
  "api/Bunit.JSRuntimeInvocationNotSetException.html": {
    "href": "api/Bunit.JSRuntimeInvocationNotSetException.html",
    "title": "Class JSRuntimeInvocationNotSetException | bUnit",
    "keywords": "Class JSRuntimeInvocationNotSetException Namespace Bunit Assembly bunit.dll Exception used to indicate that an invocation was received by a JSRuntime invocation handler, but the handler was not configured with a result (via SetResult, SetVoidResult, SetCanceled, or SetException). This causes the invocation to hang indefinitely. public sealed class JSRuntimeInvocationNotSetException : Exception, ISerializable Inheritance object Exception JSRuntimeInvocationNotSetException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors JSRuntimeInvocationNotSetException(JSRuntimeInvocation) Initializes a new instance of the JSRuntimeInvocationNotSetException class with the provided Invocation attached. public JSRuntimeInvocationNotSetException(JSRuntimeInvocation invocation) Parameters invocation JSRuntimeInvocation The invocation that was not provided with a result. Properties Invocation Gets the invocation that was not handled with a result. public JSRuntimeInvocation Invocation { get; } Property Value JSRuntimeInvocation"
  },
  "api/Bunit.JSRuntimeMode.html": {
    "href": "api/Bunit.JSRuntimeMode.html",
    "title": "Enum JSRuntimeMode | bUnit",
    "keywords": "Enum JSRuntimeMode Namespace Bunit Assembly bunit.dll The execution mode of the BunitJSInterop. public enum JSRuntimeMode Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Fields Loose = 0 Loose configures the BunitJSInterop to return default TValue for InvokeAsync<TValue>(string, object[]) calls. Strict = 1 Strict configures the BunitJSInterop to throw an JSRuntimeUnhandledInvocationException exception when a call to for InvokeAsync<TValue>(string, object[]) has not been setup."
  },
  "api/Bunit.JSRuntimeUnhandledInvocationException.html": {
    "href": "api/Bunit.JSRuntimeUnhandledInvocationException.html",
    "title": "Class JSRuntimeUnhandledInvocationException | bUnit",
    "keywords": "Class JSRuntimeUnhandledInvocationException Namespace Bunit Assembly bunit.dll Exception use to indicate that an invocation was received by the BunitJSInterop running in Strict mode, which didn't contain a matching invocation handler. public sealed class JSRuntimeUnhandledInvocationException : Exception, ISerializable Inheritance object Exception JSRuntimeUnhandledInvocationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors JSRuntimeUnhandledInvocationException(JSRuntimeInvocation) Initializes a new instance of the JSRuntimeUnhandledInvocationException class with the provided Invocation attached. public JSRuntimeUnhandledInvocationException(JSRuntimeInvocation invocation) Parameters invocation JSRuntimeInvocation The unplanned invocation. Properties Invocation Gets the unplanned invocation. public JSRuntimeInvocation Invocation { get; } Property Value JSRuntimeInvocation"
  },
  "api/Bunit.Key.html": {
    "href": "api/Bunit.Key.html",
    "title": "Class Key | bUnit",
    "keywords": "Class Key Namespace Bunit Assembly bunit.dll Representation of keyboard key that can be argument of keyboard events. public sealed class Key : IEquatable<Key> Inheritance object Key Implements IEquatable<Key> Inherited Members object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Properties Add Gets a Key that represents the number pad addition key. public static Key Add { get; } Property Value Key Alt Gets a Key that represents the Alt key. This is a control key and it can be combined with other keys. E.g. Key.Enter + Keys.Alt. public static Key Alt { get; } Property Value Key AltKey Gets a value indicating whether Alt key is pressed. public bool AltKey { get; } Property Value bool Backspace Gets a Key that represents the Backspace key. public static Key Backspace { get; } Property Value Key Code Gets the string that identifies the physical key being pressed. The value is not affected by the current keyboard layout or modifier state, so a particular key will always return the same value. public string Code { get; } Property Value string Command Gets a Key that represents the function key Command. This is a control key and it can be combined with other keys. E.g. Key.Enter + Key.Command. public static Key Command { get; } Property Value Key CommandKey Gets a value indicating whether Command key is pressed. public bool CommandKey { get; } Property Value bool Control Gets a Key that represents the Control key. This is a control key and it can be combined with other keys. E.g. Key.Enter + Key.Control. public static Key Control { get; } Property Value Key ControlKey Gets a value indicating whether Control key is pressed. public bool ControlKey { get; } Property Value bool Delete Gets a Key that represents the Delete key. public static Key Delete { get; } Property Value Key Divide Gets a Key that represents the number pad division key. public static Key Divide { get; } Property Value Key Down Gets a Key that represents the down arrow key. public static Key Down { get; } Property Value Key End Gets a Key that represents the End key. public static Key End { get; } Property Value Key Enter Gets a Key that represents the Enter key. public static Key Enter { get; } Property Value Key Equal Gets a Key that represents the equal sign key. public static Key Equal { get; } Property Value Key Escape Gets a Key that represents the Escape key. public static Key Escape { get; } Property Value Key F1 Gets a Key that represents the function key F1. public static Key F1 { get; } Property Value Key F10 Gets a Key that represents the function key F10. public static Key F10 { get; } Property Value Key F11 Gets a Key that represents the function key F11. public static Key F11 { get; } Property Value Key F12 Gets a Key that represents the function key F12. public static Key F12 { get; } Property Value Key F2 Gets a Key that represents the function key F2. public static Key F2 { get; } Property Value Key F3 Gets a Key that represents the function key F3. public static Key F3 { get; } Property Value Key F4 Gets a Key that represents the function key F4. public static Key F4 { get; } Property Value Key F5 Gets a Key that represents the function key F5. public static Key F5 { get; } Property Value Key F6 Gets a Key that represents the function key F6. public static Key F6 { get; } Property Value Key F7 Gets a Key that represents the function key F7. public static Key F7 { get; } Property Value Key F8 Gets a Key that represents the function key F8. public static Key F8 { get; } Property Value Key F9 Gets a Key that represents the function key F9. public static Key F9 { get; } Property Value Key Home Gets a Key that represents the Home key. public static Key Home { get; } Property Value Key Insert Gets a Key that represents the Insert key. public static Key Insert { get; } Property Value Key Left Gets a Key that represents the left arrow key. public static Key Left { get; } Property Value Key Multiply Gets a Key that represents the number pad multiplication key. public static Key Multiply { get; } Property Value Key NumberPad0 Gets a Key that represents the number pad 0 key. public static Key NumberPad0 { get; } Property Value Key NumberPad1 Gets a Key that represents the number pad 1 key. public static Key NumberPad1 { get; } Property Value Key NumberPad2 Gets a Key that represents the number pad 2 key. public static Key NumberPad2 { get; } Property Value Key NumberPad3 Gets a Key that represents the number pad 3 key. public static Key NumberPad3 { get; } Property Value Key NumberPad4 Gets a Key that represents the number pad 4 key. public static Key NumberPad4 { get; } Property Value Key NumberPad5 Gets a Key that represents the number pad 5 key. public static Key NumberPad5 { get; } Property Value Key NumberPad6 Gets a Key that represents the number pad 6 key. public static Key NumberPad6 { get; } Property Value Key NumberPad7 Gets a Key that represents the number pad 7 key. public static Key NumberPad7 { get; } Property Value Key NumberPad8 Gets a Key that represents the number pad 8 key. public static Key NumberPad8 { get; } Property Value Key NumberPad9 Gets a Key that represents the number pad 9 key. public static Key NumberPad9 { get; } Property Value Key NumberPadDecimal Gets a Key that represents the number pad decimal separator key. public static Key NumberPadDecimal { get; } Property Value Key PageDown Gets a Key that represents the Page Down key. public static Key PageDown { get; } Property Value Key PageUp Gets a Key that represents the Page Up key. public static Key PageUp { get; } Property Value Key Pause Gets a Key that represents the Pause key. public static Key Pause { get; } Property Value Key Right Gets a Key that represents the right arrow key. public static Key Right { get; } Property Value Key Shift Gets a Key that represents the Shift key. This is a control key and it can be combined with other keys. E.g. Key.Enter + Key.Shift. public static Key Shift { get; } Property Value Key ShiftKey Gets a value indicating whether Shift key is pressed. public bool ShiftKey { get; } Property Value bool Space Gets a Key that represents the Spacebar key. public static Key Space { get; } Property Value Key Subtract Gets a Key that represents the number pad subtraction key. public static Key Subtract { get; } Property Value Key Tab Gets a Key that represents the Tab key. public static Key Tab { get; } Property Value Key Up Gets a Key that represents the up arrow key. public static Key Up { get; } Property Value Key Value Gets the key value of the key represented. If the value has a printed representation, this attribute's value is the same as the char attribute. public string Value { get; } Property Value string Methods Combine(Key?) Gets a combination of current key with another key. A key instance can be combined only with Control, Shift, Alt, or Command keys. public Key Combine(Key? key) Parameters key Key The other key to combine with. Returns Key A new key with combination of Control, Shift, Alt, and Command keys. Equals(Key?) Gets the value indicating whether the current object is equal to another object of the same type. public bool Equals(Key? other) Parameters other Key A key to compare with this object. Returns bool True if the current object is equal to the other parameter; otherwise, false. Equals(object?) Gets the value indicating whether the current object is equal to another object of the same type. public override bool Equals(object? obj) Parameters obj object The object to compare with this object. Returns bool True if the current object is equal to the other parameter; otherwise, false. Get(char) Gets a Key object from specified character. public static Key Get(char value) Parameters value char The key value. Returns Key Get(string) Gets a Key object with specified value. public static Key Get(string value) Parameters value string The key value. Returns Key Get(string, string) Gets a Key object with specified value and code. public static Key Get(string value, string code) Parameters value string The key value. code string The key code of physical key. Returns Key GetHashCode() Gets hash code of this object. public override int GetHashCode() Returns int A hash code for the current object. ToString() Gets a string that represents the current object. public override string ToString() Returns string A string that represents the current object. WithAltKey(bool) Gets the key with new value of Alt key. public Key WithAltKey(bool value) Parameters value bool New value of Alt key. Returns Key The key with new value of Alt key. WithCommandKey(bool) Gets the key with new value of Command key. public Key WithCommandKey(bool value) Parameters value bool New value of Command key. Returns Key The key with new value of Command key. WithControlKey(bool) Gets the key with new value of Control key. public Key WithControlKey(bool value) Parameters value bool New value of Control key. Returns Key The key with new value of Control key. WithShiftKey(bool) Gets the key with new value of Shift key. public Key WithShiftKey(bool value) Parameters value bool New value of Shift key. Returns Key The key with new value of Shift key. Operators operator +(Key, Key?) Gets a combination of 2 key objects. A key instance can be combined only with Control, Shift, Alt, or Command keys. public static Key operator +(Key x, Key? y) Parameters x Key The first key to combine. y Key The second key to combine. Returns Key A new key with combination of Control, Shift, Alt, and Command keys. operator ==(Key?, Key?) Gets the value indicating whether 2 instances of Key are equal. public static bool operator ==(Key? x, Key? y) Parameters x Key The first key to compare. y Key The second key to compare. Returns bool True if the instances of Key are equal; otherwise, false. implicit operator KeyboardEventArgs(Key) Gets a new Key instance with value of character. public static implicit operator KeyboardEventArgs(Key key) Parameters key Key The character to convert to Key instance. Returns KeyboardEventArgs The Key instance with character value. implicit operator Key(char) Gets a new Key instance with value of character. public static implicit operator Key(char key) Parameters key char The character to convert to Key instance. Returns Key The Key instance with character value. implicit operator Key(string) Gets a new Key instance with value of string object. public static implicit operator Key(string value) Parameters value string The string value to convert to Key instance. Returns Key The Key instance with the specified value. operator !=(Key?, Key?) Gets the value indicating whether 2 instances of Key are different. public static bool operator !=(Key? x, Key? y) Parameters x Key The first key to compare. y Key The second key to compare. Returns bool True if the instances of Key are different; otherwise, false."
  },
  "api/Bunit.MarkupMatchesAssertExtensions.html": {
    "href": "api/Bunit.MarkupMatchesAssertExtensions.html",
    "title": "Class MarkupMatchesAssertExtensions | bUnit",
    "keywords": "Class MarkupMatchesAssertExtensions Namespace Bunit Assembly bunit.dll Assert helpers for comparing markup. public static class MarkupMatchesAssertExtensions Inheritance object MarkupMatchesAssertExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods MarkupMatches(IElement, IEnumerable<IElement>, string?) Verifies that the rendered markup from the actual elements matches the expected elements, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this IElement actual, IEnumerable<IElement> expected, string? userMessage = null) Parameters actual IElement An element to verify. expected IEnumerable<IElement> A list of elements. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual element does not match the expected elements. MarkupMatches(INode, INodeList, string?) Verifies that the actual AngleSharp.Dom.INode matches the expected AngleSharp.Dom.INodeList, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this INode actual, INodeList expected, string? userMessage = null) Parameters actual INode The node to verify. expected INodeList The expected list of nodes. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(INode, RenderFragment, string?) Verifies that the markup from the actual matches the rendered markup from the expected RenderFragment, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this INode actual, RenderFragment expected, string? userMessage = null) Parameters actual INode The markup to verify. expected RenderFragment The render fragment whose output to compare against. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(INode, string, string?) Verifies that the actual AngleSharp.Dom.INode matches the expected markup, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this INode actual, string expected, string? userMessage = null) Parameters actual INode The node to verify. expected string The expected markup. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(INodeList, INode, string?) Verifies that the actual AngleSharp.Dom.INodeList matches the expected AngleSharp.Dom.INode, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this INodeList actual, INode expected, string? userMessage = null) Parameters actual INodeList The list of nodes to verify. expected INode The expected node. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(INodeList, INodeList, string?) Verifies that the actual AngleSharp.Dom.INodeList matches the expected AngleSharp.Dom.INodeList, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this INodeList actual, INodeList expected, string? userMessage = null) Parameters actual INodeList The list of nodes to verify. expected INodeList The expected list of nodes. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(INodeList, RenderFragment, string?) Verifies that the markup from the actual matches the rendered markup from the expected RenderFragment, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this INodeList actual, RenderFragment expected, string? userMessage = null) Parameters actual INodeList The markup to verify. expected RenderFragment The render fragment whose output to compare against. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(INodeList, string, string?) Verifies that the actual AngleSharp.Dom.INodeList matches the expected markup, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this INodeList actual, string expected, string? userMessage = null) Parameters actual INodeList The list of nodes to verify. expected string The expected markup. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(IEnumerable<IElement>, IEnumerable<IRenderedComponent<IComponent>>, string?) Verifies that the rendered markup from the actual elements matches the expected fragments, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this IEnumerable<IElement> actual, IEnumerable<IRenderedComponent<IComponent>> expected, string? userMessage = null) Parameters actual IEnumerable<IElement> A list of elements to verify. expected IEnumerable<IRenderedComponent<IComponent>> A list of fragments. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual elements does not match the expected fragments. MarkupMatches(IEnumerable<IElement>, string, string?) Verifies that the rendered markup from the actual elements the expected markup fragment, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this IEnumerable<IElement> actual, string expected, string? userMessage = null) Parameters actual IEnumerable<IElement> A enumerable of IElements to verify. expected string The expected markup fragment. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(string, INode, string?) Verifies that the rendered markup from the actual markup fragment matches the expected AngleSharp.Dom.INode, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this string actual, INode expected, string? userMessage = null) Parameters actual string The markup fragment to verify. expected INode The expected AngleSharp.Dom.INode. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(string, INodeList, string?) Verifies that the rendered markup from the actual markup fragment matches the expected AngleSharp.Dom.INodeList, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this string actual, INodeList expected, string? userMessage = null) Parameters actual string The markup fragment to verify. expected INodeList The expected AngleSharp.Dom.INodeList. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches(string, string, string?) Verifies that the rendered markup from the actual markup fragment matches the expected markup fragment, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches(this string actual, string expected, string? userMessage = null) Parameters actual string The markup fragment to verify. expected string The expected markup fragment. userMessage string A custom user message to display in case the verification fails. Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches<TComponent>(IElement, IEnumerable<IRenderedComponent<TComponent>>, string?) Verifies that the rendered markup from the actual element matches the expected fragments, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches<TComponent>(this IElement actual, IEnumerable<IRenderedComponent<TComponent>> expected, string? userMessage = null) where TComponent : IComponent Parameters actual IElement An IElement to verify. expected IEnumerable<IRenderedComponent<TComponent>> The expected markup fragments. userMessage string A custom user message to display in case the verification fails. Type Parameters TComponent Exceptions HtmlEqualException Thrown when the actual element does not match the expected fragments. MarkupMatches<TComponent>(INode, IRenderedComponent<TComponent>, string?) Verifies that the actual AngleSharp.Dom.INode matches the rendered markup from the expected IRenderedComponent<TComponent>, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches<TComponent>(this INode actual, IRenderedComponent<TComponent> expected, string? userMessage = null) where TComponent : IComponent Parameters actual INode The node to verify. expected IRenderedComponent<TComponent> The expected rendered fragment. userMessage string A custom user message to display in case the verification fails. Type Parameters TComponent Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches<TComponent>(INodeList, IRenderedComponent<TComponent>, string?) Verifies that the actual AngleSharp.Dom.INodeList matches the rendered markup from the expected IRenderedComponent<TComponent>, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches<TComponent>(this INodeList actual, IRenderedComponent<TComponent> expected, string? userMessage = null) where TComponent : IComponent Parameters actual INodeList The list of nodes to verify. expected IRenderedComponent<TComponent> The expected rendered fragment. userMessage string A custom user message to display in case the verification fails. Type Parameters TComponent Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches<TComponent>(IRenderedComponent<TComponent>, RenderFragment, string?) Verifies that the rendered markup from the actual IRenderedComponent<TComponent> matches the rendered markup from the expected RenderFragment, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches<TComponent>(this IRenderedComponent<TComponent> actual, RenderFragment expected, string? userMessage = null) where TComponent : IComponent Parameters actual IRenderedComponent<TComponent> The rendered fragment to verify. expected RenderFragment The render fragment whose output to compare against. userMessage string A custom user message to display in case the verification fails. Type Parameters TComponent Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches<TComponent>(IRenderedComponent<TComponent>, string, string?) Verifies that the rendered markup from the actual IRenderedComponent<TComponent> matches the expected markup, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches<TComponent>(this IRenderedComponent<TComponent> actual, string expected, string? userMessage = null) where TComponent : IComponent Parameters actual IRenderedComponent<TComponent> The rendered fragment to verify. expected string The expected markup. userMessage string A custom user message to display in case the verification fails. Type Parameters TComponent Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches<TComponent>(IEnumerable<IElement>, IRenderedComponent<TComponent>, string?) Verifies that the rendered markup from the actual elements matches the expected fragment, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches<TComponent>(this IEnumerable<IElement> actual, IRenderedComponent<TComponent> expected, string? userMessage = null) where TComponent : IComponent Parameters actual IEnumerable<IElement> A list of elements to verify. expected IRenderedComponent<TComponent> The expected markup fragment. userMessage string A custom user message to display in case the verification fails. Type Parameters TComponent Exceptions HtmlEqualException Thrown when the actual elements does not match the expected fragment. MarkupMatches<TComponent>(string, IRenderedComponent<TComponent>, string?) Verifies that the rendered markup from the actual markup fragment matches the expected IRenderedComponent<TComponent>, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches<TComponent>(this string actual, IRenderedComponent<TComponent> expected, string? userMessage = null) where TComponent : IComponent Parameters actual string The markup fragment to verify. expected IRenderedComponent<TComponent> The expected IRenderedComponent<TComponent>. userMessage string A custom user message to display in case the verification fails. Type Parameters TComponent Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup. MarkupMatches<TActualComponent, TExpectedComponent>(IRenderedComponent<TActualComponent>, IRenderedComponent<TExpectedComponent>, string?) Verifies that the rendered markup from the actual IRenderedComponent<TComponent> matches the rendered markup from the expected IRenderedComponent<TComponent>, using the HtmlComparer type. [AssertionMethod] public static void MarkupMatches<TActualComponent, TExpectedComponent>(this IRenderedComponent<TActualComponent> actual, IRenderedComponent<TExpectedComponent> expected, string? userMessage = null) where TActualComponent : IComponent where TExpectedComponent : IComponent Parameters actual IRenderedComponent<TActualComponent> The rendered fragment to verify. expected IRenderedComponent<TExpectedComponent> The expected rendered fragment. userMessage string A custom user message to display in case the verification fails. Type Parameters TActualComponent TExpectedComponent Exceptions HtmlEqualException Thrown when the actual markup does not match the expected markup."
  },
  "api/Bunit.MissingEventHandlerException.html": {
    "href": "api/Bunit.MissingEventHandlerException.html",
    "title": "Class MissingEventHandlerException | bUnit",
    "keywords": "Class MissingEventHandlerException Namespace Bunit Assembly bunit.dll Represents an exception that is thrown when triggering an event handler failed because it wasn't available on the targeted AngleSharp.Dom.IElement. public sealed class MissingEventHandlerException : Exception, ISerializable Inheritance object Exception MissingEventHandlerException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors MissingEventHandlerException(IElement, string) Initializes a new instance of the MissingEventHandlerException class. public MissingEventHandlerException(IElement element, string missingEventName) Parameters element IElement missingEventName string"
  },
  "api/Bunit.RenderedComponentExtensions.html": {
    "href": "api/Bunit.RenderedComponentExtensions.html",
    "title": "Class RenderedComponentExtensions | bUnit",
    "keywords": "Class RenderedComponentExtensions Namespace Bunit Assembly bunit.dll Helper methods for querying IRenderedComponent<TComponent>. public static class RenderedComponentExtensions Inheritance object RenderedComponentExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods FindAll<TComponent>(IRenderedComponent<TComponent>, string) Returns a refreshable collection of AngleSharp.Dom.IElements from the rendered fragment or component under test, using the provided cssSelector, in a depth-first pre-order traversal of the rendered nodes. public static IReadOnlyList<IElement> FindAll<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered fragment to search. cssSelector string The group of selectors to use. Returns IReadOnlyList<IElement> An IReadOnlyList<T>, that can be refreshed to execute the search again. Type Parameters TComponent FindAll<TComponent, TElement>(IRenderedComponent<TComponent>, string) Returns a collection of elements of type TElement from the rendered fragment or component under test, using the provided cssSelector, in a depth-first pre-order traversal of the rendered nodes. Only elements matching the type TElement are returned. public static IReadOnlyList<TElement> FindAll<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The rendered fragment to search. cssSelector string The group of selectors to use. Returns IReadOnlyList<TElement> An IReadOnlyList<T> containing only elements matching the specified type. Type Parameters TComponent The type of the component under test. TElement The type of elements to find (e.g., IHtmlInputElement). FindComponent<TChildComponent>(IRenderedComponent<IComponent>) Finds the first component of type TChildComponent in the render tree of this IRenderedComponent<TComponent>. public static IRenderedComponent<TChildComponent> FindComponent<TChildComponent>(this IRenderedComponent<IComponent> renderedComponent) where TChildComponent : IComponent Parameters renderedComponent IRenderedComponent<IComponent> Returns IRenderedComponent<TChildComponent> The RenderedComponent<TComponent>. Type Parameters TChildComponent Type of component to find. Exceptions ComponentNotFoundException Thrown if a component of type TChildComponent was not found in the render tree. FindComponents<TChildComponent>(IRenderedComponent<IComponent>) Finds all components of type TChildComponent in the render tree of this IRenderedComponent<TComponent>, in depth-first order. public static IReadOnlyList<IRenderedComponent<TChildComponent>> FindComponents<TChildComponent>(this IRenderedComponent<IComponent> renderedComponent) where TChildComponent : IComponent Parameters renderedComponent IRenderedComponent<IComponent> Returns IReadOnlyList<IRenderedComponent<TChildComponent>> The RenderedComponent<TComponent>s. Type Parameters TChildComponent Type of components to find. Find<TComponent>(IRenderedComponent<TComponent>, string) Returns the first element from the rendered fragment or component under test, using the provided cssSelector, in a depth-first pre-order traversal of the rendered nodes. public static IElement Find<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered fragment to search. cssSelector string The group of selectors to use. Returns IElement Type Parameters TComponent Find<TComponent, TElement>(IRenderedComponent<TComponent>, string) Returns the first element of type TElement from the rendered fragment or component under test, using the provided cssSelector, in a depth-first pre-order traversal of the rendered nodes. public static TElement Find<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The rendered fragment to search. cssSelector string The group of selectors to use. Returns TElement Type Parameters TComponent The type of the component under test. TElement The type of element to find (e.g., IHtmlInputElement). Exceptions ElementNotFoundException Thrown if no element matches the cssSelector. HasComponent<TChildComponent>(IRenderedComponent<IComponent>) Checks whether the render tree the renderedComponent is the root of contains a component of type TChildComponent. public static bool HasComponent<TChildComponent>(this IRenderedComponent<IComponent> renderedComponent) where TChildComponent : IComponent Parameters renderedComponent IRenderedComponent<IComponent> The render tree to search. Returns bool True if the renderedComponent contains the TChildComponent; otherwise false. Type Parameters TChildComponent The type of component to look for in the render tree."
  },
  "api/Bunit.RenderedComponentInvokeAsyncExtensions.html": {
    "href": "api/Bunit.RenderedComponentInvokeAsyncExtensions.html",
    "title": "Class RenderedComponentInvokeAsyncExtensions | bUnit",
    "keywords": "Class RenderedComponentInvokeAsyncExtensions Namespace Bunit Assembly bunit.dll InvokeAsync extensions methods on IRenderedComponent<TComponent>. public static class RenderedComponentInvokeAsyncExtensions Inheritance object RenderedComponentInvokeAsyncExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods InvokeAsync<TComponent>(IRenderedComponent<TComponent>, Action) Invokes the given workItem in the context of the associated BunitRenderer. public static Task InvokeAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, Action workItem) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered fragment whose dispatcher to invoke with. workItem Action The work item to execute on the renderer's thread. Returns Task A Task that will be completed when the action has finished executing or is suspended by an asynchronous operation. Type Parameters TComponent InvokeAsync<TComponent>(IRenderedComponent<TComponent>, Func<Task>) Invokes the given workItem in the context of the associated BunitRenderer. public static Task InvokeAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, Func<Task> workItem) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered component whose dispatcher to invoke with. workItem Func<Task> The work item to execute on the renderer's thread. Returns Task A Task that will be completed when the action has finished executing. Type Parameters TComponent InvokeAsync<TComponent, T>(IRenderedComponent<TComponent>, Func<Task<T>>) Invokes the given workItem in the context of the associated BunitRenderer. public static Task<T> InvokeAsync<TComponent, T>(this IRenderedComponent<TComponent> renderedComponent, Func<Task<T>> workItem) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered component whose dispatcher to invoke with. workItem Func<Task<T>> The work item to execute on the renderer's thread. Returns Task<T> A Task that will be completed when the action has finished executing, with the return value from workItem. Type Parameters TComponent T InvokeAsync<TComponent, T>(IRenderedComponent<TComponent>, Func<T>) Invokes the given workItem in the context of the associated BunitRenderer. public static Task<T> InvokeAsync<TComponent, T>(this IRenderedComponent<TComponent> renderedComponent, Func<T> workItem) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered component whose dispatcher to invoke with. workItem Func<T> The work item to execute on the renderer's thread. Returns Task<T> A Task that will be completed when the action has finished executing, with the return value from workItem. Type Parameters TComponent T"
  },
  "api/Bunit.RenderedComponentRenderExtensions.html": {
    "href": "api/Bunit.RenderedComponentRenderExtensions.html",
    "title": "Class RenderedComponentRenderExtensions | bUnit",
    "keywords": "Class RenderedComponentRenderExtensions Namespace Bunit Assembly bunit.dll Re-render extension methods, optionally with new parameters, for RenderedComponent<TComponent>. public static class RenderedComponentRenderExtensions Inheritance object RenderedComponentRenderExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods Render<TComponent>(IRenderedComponent<TComponent>, ParameterView) Render the component under test again with the provided parameters. public static void Render<TComponent>(this IRenderedComponent<TComponent> renderedComponent, ParameterView parameters) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered component to re-render with new parameters. parameters ParameterView Parameters to pass to the component upon rendered. Type Parameters TComponent The type of the component. Render<TComponent>(IRenderedComponent<TComponent>, Action<ComponentParameterCollectionBuilder<TComponent>>?) Render the component under test again with the provided parameters from the parameterBuilder. public static void Render<TComponent>(this IRenderedComponent<TComponent> renderedComponent, Action<ComponentParameterCollectionBuilder<TComponent>>? parameterBuilder = null) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered component to re-render with new parameters. parameterBuilder Action<ComponentParameterCollectionBuilder<TComponent>> An action that receives a ComponentParameterCollectionBuilder<TComponent>. Type Parameters TComponent The type of the component."
  },
  "api/Bunit.RenderedComponentWaitForHelperExtensions.html": {
    "href": "api/Bunit.RenderedComponentWaitForHelperExtensions.html",
    "title": "Class RenderedComponentWaitForHelperExtensions | bUnit",
    "keywords": "Class RenderedComponentWaitForHelperExtensions Namespace Bunit Assembly bunit.dll Provides extension methods for waiting on components within a rendered Blazor component. public static class RenderedComponentWaitForHelperExtensions Inheritance object RenderedComponentWaitForHelperExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods WaitForAssertionAsync<TComponent>(IRenderedComponent<TComponent>, Action, TimeSpan?) Wait until the provided assertion passes (i.e. does not throw an exception), or the timeout is reached (default is one second). The assertion is attempted initially, and then each time the renderedComponent renders. [AssertionMethod] public static Task WaitForAssertionAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, Action assertion, TimeSpan? timeout = null) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered fragment to wait for renders from and assert against. assertion Action The verification or assertion to perform. timeout TimeSpan? The maximum time to attempt the verification. Returns Task Type Parameters TComponent Exceptions WaitForFailedException Thrown if the timeout has been reached. See the inner exception to see the captured assertion exception. WaitForAssertion<TComponent>(IRenderedComponent<TComponent>, Action, TimeSpan?) Wait until the provided assertion passes (i.e. does not throw an exception), or the timeout is reached (default is one second). The assertion is attempted initially, and then each time the renderedComponent renders. [AssertionMethod] public static void WaitForAssertion<TComponent>(this IRenderedComponent<TComponent> renderedComponent, Action assertion, TimeSpan? timeout = null) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The rendered fragment to wait for renders from and assert against. assertion Action The verification or assertion to perform. timeout TimeSpan? The maximum time to attempt the verification. Type Parameters TComponent Exceptions WaitForFailedException Thrown if the timeout has been reached. See the inner exception to see the captured assertion exception. WaitForComponent<TComponent>(IRenderedComponent<IComponent>, TimeSpan?) Waits until the specified component is rendered in the DOM. public static IRenderedComponent<TComponent> WaitForComponent<TComponent>(this IRenderedComponent<IComponent> renderedComponent, TimeSpan? timeout = null) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<IComponent> The rendered component to find the component in. timeout TimeSpan? The maximum time to wait for the element to appear. Returns IRenderedComponent<TComponent> See IRenderedComponent<TComponent>. Type Parameters TComponent The target component type to wait for. WaitForComponents<TComponent>(IRenderedComponent<IComponent>, int, TimeSpan?) Waits until the specified number of components are rendered in the DOM and returns their instances. public static IReadOnlyCollection<IRenderedComponent<TComponent>> WaitForComponents<TComponent>(this IRenderedComponent<IComponent> renderedComponent, int matchComponentCount, TimeSpan? timeout = null) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<IComponent> The rendered component in which to search for instances of the specified component. matchComponentCount int The minimum amount component instances to wait for. timeout TimeSpan? The maximum time to wait for the components to appear. Defaults to no specific timeout if not provided. Returns IReadOnlyCollection<IRenderedComponent<TComponent>> A read-only collection of IRenderedComponent<TComponent> instances representing the found components. Type Parameters TComponent The target component type to wait for. WaitForComponents<TComponent>(IRenderedComponent<IComponent>, TimeSpan?) Waits until the specified component is rendered in the DOM and returns all instances of that component when the first instance is found. public static IReadOnlyCollection<IRenderedComponent<TComponent>> WaitForComponents<TComponent>(this IRenderedComponent<IComponent> renderedComponent, TimeSpan? timeout = null) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<IComponent> The rendered component in which to search for instances of the specified component. timeout TimeSpan? The maximum time to wait for the components to appear. Defaults to no specific timeout if not provided. Returns IReadOnlyCollection<IRenderedComponent<TComponent>> A read-only collection of IRenderedComponent<TComponent> instances representing the found components. Type Parameters TComponent The target component type to wait for. WaitForElementAsync<TComponent>(IRenderedComponent<TComponent>, string) Wait until an element matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static Task<IElement> WaitForElementAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for the element. Returns Task<IElement> The AngleSharp.Dom.IElement. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. See the inner exception for details. WaitForElementAsync<TComponent>(IRenderedComponent<TComponent>, string, TimeSpan) Wait until an element matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static Task<IElement> WaitForElementAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, TimeSpan timeout) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for the element. timeout TimeSpan The maximum time to wait for the element to appear. Returns Task<IElement> The AngleSharp.Dom.IElement. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. See the inner exception for details. WaitForElementAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string) Wait until an element of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static Task<TElement> WaitForElementAsync<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for the element. Returns Task<TElement> The TElement. Type Parameters TComponent The type of the component under test. TElement The type of element to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. See the inner exception for details. WaitForElementAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string, TimeSpan) Wait until an element of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static Task<TElement> WaitForElementAsync<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, TimeSpan timeout) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for the element. timeout TimeSpan The maximum time to wait for the element to appear. Returns Task<TElement> The TElement. Type Parameters TComponent The type of the component under test. TElement The type of element to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. See the inner exception for details. WaitForElement<TComponent>(IRenderedComponent<TComponent>, string) Wait until an element matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static IElement WaitForElement<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for the element. Returns IElement The AngleSharp.Dom.IElement. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. See the inner exception for details. WaitForElement<TComponent>(IRenderedComponent<TComponent>, string, TimeSpan) Wait until an element matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static IElement WaitForElement<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, TimeSpan timeout) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for the element. timeout TimeSpan The maximum time to wait for the element to appear. Returns IElement The AngleSharp.Dom.IElement. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. See the inner exception for details. WaitForElement<TComponent, TElement>(IRenderedComponent<TComponent>, string) Wait until an element of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static TElement WaitForElement<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for the element. Returns TElement The TElement. Type Parameters TComponent The type of the component under test. TElement The type of element to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. See the inner exception for details. WaitForElement<TComponent, TElement>(IRenderedComponent<TComponent>, string, TimeSpan) Wait until an element of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static TElement WaitForElement<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, TimeSpan timeout) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for the element. timeout TimeSpan The maximum time to wait for the element to appear. Returns TElement The TElement. Type Parameters TComponent The type of the component under test. TElement The type of element to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. See the inner exception for details. WaitForElementsAsync<TComponent>(IRenderedComponent<TComponent>, string) Wait until at least one element matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static Task<IReadOnlyList<IElement>> WaitForElementsAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. Returns Task<IReadOnlyList<IElement>> The IReadOnlyList<T>. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElementsAsync<TComponent>(IRenderedComponent<TComponent>, string, int) Wait until exactly matchElementCount element(s) matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static Task<IReadOnlyList<IElement>> WaitForElementsAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, int matchElementCount) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. matchElementCount int The exact number of elements to that the cssSelector should match. Returns Task<IReadOnlyList<IElement>> The IReadOnlyList<T>. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElementsAsync<TComponent>(IRenderedComponent<TComponent>, string, int, TimeSpan) Wait until exactly matchElementCount element(s) matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static Task<IReadOnlyList<IElement>> WaitForElementsAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, int matchElementCount, TimeSpan timeout) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. matchElementCount int The exact number of elements to that the cssSelector should match. timeout TimeSpan The maximum time to wait for elements to appear. Returns Task<IReadOnlyList<IElement>> The IReadOnlyList<T>. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElementsAsync<TComponent>(IRenderedComponent<TComponent>, string, TimeSpan) Wait until at least one element matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static Task<IReadOnlyList<IElement>> WaitForElementsAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, TimeSpan timeout) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. timeout TimeSpan The maximum time to wait for elements to appear. Returns Task<IReadOnlyList<IElement>> The IReadOnlyList<T>. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElementsAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string) Wait until at least one element of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static Task<IReadOnlyList<TElement>> WaitForElementsAsync<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. Returns Task<IReadOnlyList<TElement>> The IReadOnlyList<T>. Type Parameters TComponent The type of the component under test. TElement The type of elements to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElementsAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string, int) Wait until exactly matchElementCount element(s) of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static Task<IReadOnlyList<TElement>> WaitForElementsAsync<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, int matchElementCount) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. matchElementCount int The exact number of elements to that the cssSelector should match. Returns Task<IReadOnlyList<TElement>> The IReadOnlyList<T>. Type Parameters TComponent The type of the component under test. TElement The type of elements to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElementsAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string, int, TimeSpan) Wait until exactly matchElementCount element(s) of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static Task<IReadOnlyList<TElement>> WaitForElementsAsync<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, int matchElementCount, TimeSpan timeout) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. matchElementCount int The exact number of elements to that the cssSelector should match. timeout TimeSpan The maximum time to wait for elements to appear. Returns Task<IReadOnlyList<TElement>> The IReadOnlyList<T>. Type Parameters TComponent The type of the component under test. TElement The type of elements to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElementsAsync<TComponent, TElement>(IRenderedComponent<TComponent>, string, TimeSpan) Wait until at least one element of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static Task<IReadOnlyList<TElement>> WaitForElementsAsync<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, TimeSpan timeout) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. timeout TimeSpan The maximum time to wait for elements to appear. Returns Task<IReadOnlyList<TElement>> The IReadOnlyList<T>. Type Parameters TComponent The type of the component under test. TElement The type of elements to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElements<TComponent>(IRenderedComponent<TComponent>, string) Wait until at least one element matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static IReadOnlyList<IElement> WaitForElements<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. Returns IReadOnlyList<IElement> The IReadOnlyList<T>. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElements<TComponent>(IRenderedComponent<TComponent>, string, int) Wait until exactly matchElementCount element(s) matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static IReadOnlyList<IElement> WaitForElements<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, int matchElementCount) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. matchElementCount int The exact number of elements to that the cssSelector should match. Returns IReadOnlyList<IElement> The IReadOnlyList<T>. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElements<TComponent>(IRenderedComponent<TComponent>, string, int, TimeSpan) Wait until exactly matchElementCount element(s) matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static IReadOnlyList<IElement> WaitForElements<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, int matchElementCount, TimeSpan timeout) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. matchElementCount int The exact number of elements to that the cssSelector should match. timeout TimeSpan The maximum time to wait for elements to appear. Returns IReadOnlyList<IElement> The IReadOnlyList<T>. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElements<TComponent>(IRenderedComponent<TComponent>, string, TimeSpan) Wait until at least one element matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static IReadOnlyList<IElement> WaitForElements<TComponent>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, TimeSpan timeout) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. timeout TimeSpan The maximum time to wait for elements to appear. Returns IReadOnlyList<IElement> The IReadOnlyList<T>. Type Parameters TComponent Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElements<TComponent, TElement>(IRenderedComponent<TComponent>, string) Wait until at least one element of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static IReadOnlyList<TElement> WaitForElements<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. Returns IReadOnlyList<TElement> The IReadOnlyList<T>. Type Parameters TComponent The type of the component under test. TElement The type of elements to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElements<TComponent, TElement>(IRenderedComponent<TComponent>, string, int) Wait until exactly matchElementCount element(s) of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached (default is one second). public static IReadOnlyList<TElement> WaitForElements<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, int matchElementCount) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. matchElementCount int The exact number of elements to that the cssSelector should match. Returns IReadOnlyList<TElement> The IReadOnlyList<T>. Type Parameters TComponent The type of the component under test. TElement The type of elements to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElements<TComponent, TElement>(IRenderedComponent<TComponent>, string, int, TimeSpan) Wait until exactly matchElementCount element(s) of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static IReadOnlyList<TElement> WaitForElements<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, int matchElementCount, TimeSpan timeout) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. matchElementCount int The exact number of elements to that the cssSelector should match. timeout TimeSpan The maximum time to wait for elements to appear. Returns IReadOnlyList<TElement> The IReadOnlyList<T>. Type Parameters TComponent The type of the component under test. TElement The type of elements to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForElements<TComponent, TElement>(IRenderedComponent<TComponent>, string, TimeSpan) Wait until at least one element of type TElement matching the cssSelector exists in the renderedComponent, or the timeout is reached. public static IReadOnlyList<TElement> WaitForElements<TComponent, TElement>(this IRenderedComponent<TComponent> renderedComponent, string cssSelector, TimeSpan timeout) where TComponent : IComponent where TElement : class, IElement Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component find the matching element in. cssSelector string The CSS selector to use to search for elements. timeout TimeSpan The maximum time to wait for elements to appear. Returns IReadOnlyList<TElement> The IReadOnlyList<T>. Type Parameters TComponent The type of the component under test. TElement The type of elements to wait for (e.g., IHtmlInputElement). Exceptions WaitForFailedException Thrown if no elements is found matching the cssSelector within the default timeout. WaitForStateAsync<TComponent>(IRenderedComponent<TComponent>, Func<bool>, TimeSpan?) Wait until the provided statePredicate action returns true, or the timeout is reached (default is one second). The statePredicate is evaluated initially, and then each time the renderedComponent renders. public static Task WaitForStateAsync<TComponent>(this IRenderedComponent<TComponent> renderedComponent, Func<bool> statePredicate, TimeSpan? timeout = null) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component to attempt to verify state against. statePredicate Func<bool> The predicate to invoke after each render, which must returns true when the desired state has been reached. timeout TimeSpan? The maximum time to wait for the desired state. Returns Task Type Parameters TComponent Exceptions WaitForFailedException Thrown if the statePredicate throw an exception during invocation, or if the timeout has been reached. See the inner exception for details. WaitForState<TComponent>(IRenderedComponent<TComponent>, Func<bool>, TimeSpan?) Wait until the provided statePredicate action returns true, or the timeout is reached (default is one second). The statePredicate is evaluated initially, and then each time the renderedComponent renders. public static void WaitForState<TComponent>(this IRenderedComponent<TComponent> renderedComponent, Func<bool> statePredicate, TimeSpan? timeout = null) where TComponent : IComponent Parameters renderedComponent IRenderedComponent<TComponent> The render fragment or component to attempt to verify state against. statePredicate Func<bool> The predicate to invoke after each render, which must returns true when the desired state has been reached. timeout TimeSpan? The maximum time to wait for the desired state. Type Parameters TComponent Remarks If a debugger is attached the timeout is set to InfiniteTimeSpan, giving the possibility to debug without the timeout triggering. Exceptions WaitForFailedException Thrown if the statePredicate throw an exception during invocation, or if the timeout has been reached. See the inner exception for details."
  },
  "api/Bunit.Rendering.BunitRenderer.html": {
    "href": "api/Bunit.Rendering.BunitRenderer.html",
    "title": "Class BunitRenderer | bUnit",
    "keywords": "Class BunitRenderer Namespace Bunit.Rendering Assembly bunit.dll Represents a bUnit BunitRenderer used to render Blazor components and fragments during bUnit tests. public sealed class BunitRenderer : Renderer, IDisposable, IAsyncDisposable Inheritance object Renderer BunitRenderer Implements IDisposable IAsyncDisposable Inherited Members Renderer.GetEventArgsType(ulong) Renderer.Dispose() Renderer.DisposeAsync() Renderer.UnhandledSynchronizationException object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitRenderer(BunitServiceProvider, ILoggerFactory) Initializes a new instance of the BunitRenderer class. public BunitRenderer(BunitServiceProvider services, ILoggerFactory loggerFactory) Parameters services BunitServiceProvider loggerFactory ILoggerFactory BunitRenderer(BunitServiceProvider, ILoggerFactory, IComponentActivator) Initializes a new instance of the BunitRenderer class. public BunitRenderer(BunitServiceProvider services, ILoggerFactory loggerFactory, IComponentActivator componentActivator) Parameters services BunitServiceProvider loggerFactory ILoggerFactory componentActivator IComponentActivator Properties Dispatcher Gets the Dispatcher associated with this Renderer. public override Dispatcher Dispatcher { get; } Property Value Dispatcher RendererInfo Gets the RendererInfo associated with this Renderer. protected override RendererInfo RendererInfo { get; } Property Value RendererInfo UnhandledException Gets a Task<TResult>, which completes when an unhandled exception is thrown during the rendering of a component, that is caught by the renderer. public Task<Exception> UnhandledException { get; } Property Value Task<Exception> Methods AddPendingTask(ComponentState?, Task) Notifies the renderer that there is a pending task associated with a component. The renderer is regarded as quiescent when all such tasks have completed. protected override void AddPendingTask(ComponentState? componentState, Task task) Parameters componentState ComponentState The ComponentState for the component associated with this pending task, if any. task Task The Task. CreateComponentState(int, IComponent, ComponentState?) Creates a ComponentState instance to track state associated with a newly-instantiated component. This is called before the component is initialized and tracked within the Renderer. Subclasses may override this method to use their own subclasses of ComponentState. protected override ComponentState CreateComponentState(int componentId, IComponent component, ComponentState? parentComponentState) Parameters componentId int The ID of the newly-created component. component IComponent The component instance. parentComponentState ComponentState The ComponentState associated with the parent component, or null if this is a root component. Returns ComponentState A ComponentState for the new component. DispatchEventAsync(ulong, EventFieldInfo, EventArgs) Notifies the renderer that an event has occurred. public Task DispatchEventAsync(ulong eventHandlerId, EventFieldInfo fieldInfo, EventArgs eventArgs) Parameters eventHandlerId ulong The AttributeEventHandlerId value from the original event attribute. fieldInfo EventFieldInfo Information that the renderer can use to update the state of the existing render tree to match the UI. eventArgs EventArgs Arguments to be passed to the event handler. Returns Task A Task which will complete once all asynchronous processing related to the event has completed. DispatchEventAsync(ulong, EventFieldInfo, EventArgs, bool) Notifies the renderer that an event has occurred. public Task DispatchEventAsync(ulong eventHandlerId, EventFieldInfo fieldInfo, EventArgs eventArgs, bool ignoreUnknownEventHandlers) Parameters eventHandlerId ulong The AttributeEventHandlerId value from the original event attribute. fieldInfo EventFieldInfo Information that the renderer can use to update the state of the existing render tree to match the UI. eventArgs EventArgs Arguments to be passed to the event handler. ignoreUnknownEventHandlers bool Set to true to ignore the UnknownEventHandlerIdException. Returns Task A Task which will complete once all asynchronous processing related to the event has completed. Dispose(bool) Releases all resources currently used by this Renderer instance. protected override void Dispose(bool disposing) Parameters disposing bool true if this method is being invoked by Dispose(), otherwise false. DisposeComponents() Disposes all components rendered by the BunitRenderer. public Task DisposeComponents() Returns Task FindComponent<TComponent>(IRenderedComponent<IComponent>) Performs a depth-first search for the first TComponent child component of the parentComponent. public IRenderedComponent<TComponent> FindComponent<TComponent>(IRenderedComponent<IComponent> parentComponent) where TComponent : IComponent Parameters parentComponent IRenderedComponent<IComponent> Parent component to search. Returns IRenderedComponent<TComponent> Type Parameters TComponent Type of component to find. FindComponents<TComponent>(IRenderedComponent<IComponent>) Performs a depth-first search for all TComponent child components of the parentComponent. public IReadOnlyList<IRenderedComponent<TComponent>> FindComponents<TComponent>(IRenderedComponent<IComponent> parentComponent) where TComponent : IComponent Parameters parentComponent IRenderedComponent<IComponent> Parent component to search. Returns IReadOnlyList<IRenderedComponent<TComponent>> Type Parameters TComponent Type of components to find. GetComponentRenderMode(IComponent) Gets the IComponentRenderMode for a given component if available. protected override IComponentRenderMode? GetComponentRenderMode(IComponent component) Parameters component IComponent The component type Returns IComponentRenderMode HandleException(Exception) Allows derived types to handle exceptions during rendering. Defaults to rethrowing the original exception. protected override void HandleException(Exception exception) Parameters exception Exception The Exception. ProcessPendingRender() Processes pending renders requests from components if there are any. protected override void ProcessPendingRender() RenderFragment(RenderFragment) Renders the renderFragment. public IRenderedComponent<IComponent> RenderFragment(RenderFragment renderFragment) Parameters renderFragment RenderFragment The RenderFragment to render. Returns IRenderedComponent<IComponent> A IRenderedComponent<TComponent> that provides access to the rendered renderFragment. Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) Renders a TComponent with the parameters build with the parameterBuilder passed to it. public IRenderedComponent<TComponent> Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>? parameterBuilder = null) where TComponent : IComponent Parameters parameterBuilder Action<ComponentParameterCollectionBuilder<TComponent>> The a builder to create parameters to pass to the component. Returns IRenderedComponent<TComponent> A RenderedComponent<TComponent> that provides access to the rendered component. Type Parameters TComponent The type of component to render. ResolveComponentForRenderMode(Type, int?, IComponentActivator, IComponentRenderMode) Determines how to handle an IComponentRenderMode when obtaining a component instance. This is only called when a render mode is specified either at the call site or on the component type. Subclasses may override this method to return a component of a different type, or throw, depending on whether the renderer supports the render mode and how it implements that support. protected override IComponent ResolveComponentForRenderMode(Type componentType, int? parentComponentId, IComponentActivator componentActivator, IComponentRenderMode renderMode) Parameters componentType Type The type of component that was requested. parentComponentId int? The parent component ID, or null if it is a root component. componentActivator IComponentActivator An IComponentActivator that should be used when instantiating component objects. renderMode IComponentRenderMode The IComponentRenderMode declared on componentType or at the call site (for example, by the parent component). Returns IComponent An IComponent instance. SetRendererInfo(RendererInfo?) public void SetRendererInfo(RendererInfo? rendererInfo) Parameters rendererInfo RendererInfo UpdateDisplayAsync(in RenderBatch) Updates the visible UI. protected override Task UpdateDisplayAsync(in RenderBatch renderBatch) Parameters renderBatch RenderBatch The changes to the UI since the previous call. Returns Task A Task to represent the UI update process."
  },
  "api/Bunit.Rendering.ComponentDisposedException.html": {
    "href": "api/Bunit.Rendering.ComponentDisposedException.html",
    "title": "Class ComponentDisposedException | bUnit",
    "keywords": "Class ComponentDisposedException Namespace Bunit.Rendering Assembly bunit.dll Represents an exception that is thrown when a IRenderedComponent<TComponent>'s properties is accessed after the underlying component has been disposed by the renderer. public sealed class ComponentDisposedException : Exception, ISerializable Inheritance object Exception ComponentDisposedException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ComponentDisposedException(int) Initializes a new instance of the ComponentDisposedException class. public ComponentDisposedException(int componentId) Parameters componentId int Id of the disposed component."
  },
  "api/Bunit.Rendering.ComponentNotFoundException.html": {
    "href": "api/Bunit.Rendering.ComponentNotFoundException.html",
    "title": "Class ComponentNotFoundException | bUnit",
    "keywords": "Class ComponentNotFoundException Namespace Bunit.Rendering Assembly bunit.dll Represents an exception that is thrown when a search for a component did not succeed. public sealed class ComponentNotFoundException : Exception, ISerializable Inheritance object Exception ComponentNotFoundException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ComponentNotFoundException(Type) Initializes a new instance of the ComponentNotFoundException class. public ComponentNotFoundException(Type componentType) Parameters componentType Type The type of component that was not found."
  },
  "api/Bunit.Rendering.ContainerFragment.html": {
    "href": "api/Bunit.Rendering.ContainerFragment.html",
    "title": "Class ContainerFragment | bUnit",
    "keywords": "Class ContainerFragment Namespace Bunit.Rendering Assembly bunit.dll Creates an instance of the ContainerFragment, which is used when a fragment is rendered inside a test contexts render tree. It is primarily used to be able to find the starting point to return. public sealed class ContainerFragment : IComponent Inheritance object ContainerFragment Implements IComponent Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ContainerFragment() public ContainerFragment() Methods Attach(RenderHandle) Attaches the component to a RenderHandle. public void Attach(RenderHandle renderHandle) Parameters renderHandle RenderHandle A RenderHandle that allows the component to be rendered. SetParametersAsync(ParameterView) Sets parameters supplied by the component's parent in the render tree. public Task SetParametersAsync(ParameterView parameters) Parameters parameters ParameterView The parameters. Returns Task A Task that completes when the component has finished updating and rendering itself. Remarks The SetParametersAsync(ParameterView) method should be passed the entire set of parameter values each time SetParametersAsync(ParameterView) is called. It not required that the caller supply a parameter value for all parameters that are logically understood by the component. Wrap(RenderFragment) Wraps the wrappingTarget in a ContainerFragment. public static RenderFragment Wrap(RenderFragment wrappingTarget) Parameters wrappingTarget RenderFragment Returns RenderFragment"
  },
  "api/Bunit.Rendering.MissingRendererInfoException.html": {
    "href": "api/Bunit.Rendering.MissingRendererInfoException.html",
    "title": "Class MissingRendererInfoException | bUnit",
    "keywords": "Class MissingRendererInfoException Namespace Bunit.Rendering Assembly bunit.dll Represents an exception that is thrown when a component under test is trying to access the 'RendererInfo' property, which has not been specified. public sealed class MissingRendererInfoException : Exception, ISerializable Inheritance object Exception MissingRendererInfoException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors MissingRendererInfoException() Initializes a new instance of the MissingRendererInfoException class. public MissingRendererInfoException()"
  },
  "api/Bunit.Rendering.RenderModeMisMatchException.html": {
    "href": "api/Bunit.Rendering.RenderModeMisMatchException.html",
    "title": "Class RenderModeMisMatchException | bUnit",
    "keywords": "Class RenderModeMisMatchException Namespace Bunit.Rendering Assembly bunit.dll Represents an exception that is thrown when a component under test has mismatching render modes assigned between parent and child components. public sealed class RenderModeMisMatchException : Exception, ISerializable Inheritance object Exception RenderModeMisMatchException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors RenderModeMisMatchException() Initializes a new instance of the MissingRendererInfoException class. public RenderModeMisMatchException()"
  },
  "api/Bunit.Rendering.RootRenderTree.html": {
    "href": "api/Bunit.Rendering.RootRenderTree.html",
    "title": "Class RootRenderTree | bUnit",
    "keywords": "Class RootRenderTree Namespace Bunit.Rendering Assembly bunit.dll Represents a root render tree, wherein components under tests will be rendered. Components added to the render tree must have either a ChildContent or Body parameter. public sealed class RootRenderTree : IReadOnlyCollection<RootRenderTreeRegistration>, IEnumerable<RootRenderTreeRegistration>, IEnumerable Inheritance object RootRenderTree Implements IReadOnlyCollection<RootRenderTreeRegistration> IEnumerable<RootRenderTreeRegistration> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors RootRenderTree() public RootRenderTree() Properties Count public int Count { get; } Property Value int Methods Add<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) Adds a component to the render tree. This method can be called multiple times, with each invocation adding a component to the render tree. The TComponent must have a ChildContent or Body parameter. public void Add<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>? parameterBuilder = null) where TComponent : IComponent Parameters parameterBuilder Action<ComponentParameterCollectionBuilder<TComponent>> An optional parameter builder, used to pass parameters to TComponent. Type Parameters TComponent The type of the component to add to the render tree. GetCountOf<TComponent>() Gets the number of registered components of type TComponent in the render tree. public int GetCountOf<TComponent>() where TComponent : IComponent Returns int Number of components of type TComponent in render tree. Type Parameters TComponent Component type to count. GetEnumerator() public IEnumerator<RootRenderTreeRegistration> GetEnumerator() Returns IEnumerator<RootRenderTreeRegistration> TryAdd<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) Try to add a component to the render tree if it has not already been added. This method can be called multiple times, with each invocation adding a component to the render tree. The TComponent must have a ChildContent or Body parameter. public bool TryAdd<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>? parameterBuilder = null) where TComponent : IComponent Parameters parameterBuilder Action<ComponentParameterCollectionBuilder<TComponent>> An optional parameter builder, used to pass parameters to TComponent. Returns bool True if component was added, false if it was previously added and not added again. Type Parameters TComponent The type of the component to add to the render tree. Remarks This method will only add the component to the render tree if it has not already been added. Use Add<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) to add the same component multiple times. Wrap(RenderFragment) Creates a new RenderFragment that wraps target inside the components registered in this RootRenderTree. public RenderFragment Wrap(RenderFragment target) Parameters target RenderFragment RenderFragment to render inside the render tree. Returns RenderFragment A RenderFragment that renders the target inside this RootRenderTree render tree."
  },
  "api/Bunit.Rendering.RootRenderTreeRegistration.html": {
    "href": "api/Bunit.Rendering.RootRenderTreeRegistration.html",
    "title": "Class RootRenderTreeRegistration | bUnit",
    "keywords": "Class RootRenderTreeRegistration Namespace Bunit.Rendering Assembly bunit.dll Represents an added component with parameters in an RootRenderTree. public sealed class RootRenderTreeRegistration Inheritance object RootRenderTreeRegistration Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Properties ComponentType Gets the type of component registered. public Type ComponentType { get; } Property Value Type RenderFragmentBuilder Gets the render fragment builder that renders the component of type ComponentType with the specified parameters and the provided RenderFragment passed to its ChildContent or Body parameter. public RenderFragment<RenderFragment> RenderFragmentBuilder { get; } Property Value RenderFragment<RenderFragment>"
  },
  "api/Bunit.Rendering.UnknownEventHandlerIdException.html": {
    "href": "api/Bunit.Rendering.UnknownEventHandlerIdException.html",
    "title": "Class UnknownEventHandlerIdException | bUnit",
    "keywords": "Class UnknownEventHandlerIdException Namespace Bunit.Rendering Assembly bunit.dll Represents an exception that is thrown when the Blazor Renderer does not have any event handler with the specified a given ID. public sealed class UnknownEventHandlerIdException : Exception, ISerializable Inheritance object Exception UnknownEventHandlerIdException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors UnknownEventHandlerIdException(ulong, EventFieldInfo, Exception) Initializes a new instance of the UnknownEventHandlerIdException class. public UnknownEventHandlerIdException(ulong eventHandlerId, EventFieldInfo fieldInfo, Exception innerException) Parameters eventHandlerId ulong fieldInfo EventFieldInfo innerException Exception"
  },
  "api/Bunit.Rendering.html": {
    "href": "api/Bunit.Rendering.html",
    "title": "Namespace Bunit.Rendering | bUnit",
    "keywords": "Namespace Bunit.Rendering Classes BunitRenderer Represents a bUnit BunitRenderer used to render Blazor components and fragments during bUnit tests. ComponentDisposedException Represents an exception that is thrown when a IRenderedComponent<TComponent>'s properties is accessed after the underlying component has been disposed by the renderer. ComponentNotFoundException Represents an exception that is thrown when a search for a component did not succeed. ContainerFragment Creates an instance of the ContainerFragment, which is used when a fragment is rendered inside a test contexts render tree. It is primarily used to be able to find the starting point to return. MissingRendererInfoException Represents an exception that is thrown when a component under test is trying to access the 'RendererInfo' property, which has not been specified. RenderModeMisMatchException Represents an exception that is thrown when a component under test has mismatching render modes assigned between parent and child components. RootRenderTree Represents a root render tree, wherein components under tests will be rendered. Components added to the render tree must have either a ChildContent or Body parameter. RootRenderTreeRegistration Represents an added component with parameters in an RootRenderTree. UnknownEventHandlerIdException Represents an exception that is thrown when the Blazor Renderer does not have any event handler with the specified a given ID."
  },
  "api/Bunit.StubComponentFactoryCollectionExtensions.html": {
    "href": "api/Bunit.StubComponentFactoryCollectionExtensions.html",
    "title": "Class StubComponentFactoryCollectionExtensions | bUnit",
    "keywords": "Class StubComponentFactoryCollectionExtensions Namespace Bunit Assembly bunit.dll Extension methods for using component doubles. public static class StubComponentFactoryCollectionExtensions Inheritance object StubComponentFactoryCollectionExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods AddStub(ComponentFactoryCollection, Predicate<Type>) Configures bUnit to use replace all components whose type make the componentTypePredicate predicate return true with a Stub<TComponent> component in the render tree. public static ComponentFactoryCollection AddStub(this ComponentFactoryCollection factories, Predicate<Type> componentTypePredicate) Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. componentTypePredicate Predicate<Type> The predicate which decides if a component should be replaced with a Stub<TComponent> component. Returns ComponentFactoryCollection A ComponentFactoryCollection. AddStub(ComponentFactoryCollection, Predicate<Type>, RenderFragment) Configures bUnit to use replace all components whose type make the componentTypePredicate predicate return true with a Stub<TComponent> component in the render tree. public static ComponentFactoryCollection AddStub(this ComponentFactoryCollection factories, Predicate<Type> componentTypePredicate, RenderFragment replacementFragment) Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. componentTypePredicate Predicate<Type> The predicate which decides if a component should be replaced with a Stub<TComponent> component. replacementFragment RenderFragment Replacement RenderFragment that will be used to render output instead of the stubbed out components. Returns ComponentFactoryCollection A ComponentFactoryCollection. AddStub(ComponentFactoryCollection, Predicate<Type>, string) Configures bUnit to use replace all components whose type make the componentTypePredicate predicate return true with a Stub<TComponent> component in the render tree. public static ComponentFactoryCollection AddStub(this ComponentFactoryCollection factories, Predicate<Type> componentTypePredicate, string replacementMarkup) Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. componentTypePredicate Predicate<Type> The predicate which decides if a component should be replaced with a Stub<TComponent> component. replacementMarkup string Replacement markup that will be used to render output instead of the stubbed out components. Returns ComponentFactoryCollection A ComponentFactoryCollection. AddStub<TComponent>(ComponentFactoryCollection) Configures bUnit to use replace all components of type TComponent (including derived components) with a Stub<TComponent> component in the render tree. public static ComponentFactoryCollection AddStub<TComponent>(this ComponentFactoryCollection factories) where TComponent : IComponent Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. Returns ComponentFactoryCollection A ComponentFactoryCollection. Type Parameters TComponent The type of component to replace with a Stub<TComponent> component. Remarks NOTE: This will replace any component of type TComponent or components that derives/inherits from it. AddStub<TComponent>(ComponentFactoryCollection, RenderFragment) Configures bUnit to use replace all components of type TComponent (including derived components) with a Stub<TComponent> component in the render tree. public static ComponentFactoryCollection AddStub<TComponent>(this ComponentFactoryCollection factories, RenderFragment replacementFragment) where TComponent : IComponent Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. replacementFragment RenderFragment Replacement render fragment that will be used as render output instead of the stubbed out component. Returns ComponentFactoryCollection A ComponentFactoryCollection. Type Parameters TComponent The type of component to replace with a Stub<TComponent> component. Remarks NOTE: This will replace any component of type TComponent or components that derives/inherits from it. AddStub<TComponent>(ComponentFactoryCollection, RenderFragment<CapturedParameterView<TComponent>>) Configures bUnit to use replace all components of type TComponent (including derived components) with a Stub<TComponent> component in the render tree. public static ComponentFactoryCollection AddStub<TComponent>(this ComponentFactoryCollection factories, RenderFragment<CapturedParameterView<TComponent>> replacementTemplate) where TComponent : IComponent Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. replacementTemplate RenderFragment<CapturedParameterView<TComponent>> Replacement template that will be used to render output instead of the stubbed out component. Returns ComponentFactoryCollection A ComponentFactoryCollection. Type Parameters TComponent The type of component to replace with a Stub<TComponent> component. Remarks NOTE: This will replace any component of type TComponent or components that derives/inherits from it. AddStub<TComponent>(ComponentFactoryCollection, Func<CapturedParameterView<TComponent>, string>) Configures bUnit to use replace all components of type TComponent (including derived components) with a Stub<TComponent> component in the render tree. public static ComponentFactoryCollection AddStub<TComponent>(this ComponentFactoryCollection factories, Func<CapturedParameterView<TComponent>, string> replacementTemplate) where TComponent : IComponent Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. replacementTemplate Func<CapturedParameterView<TComponent>, string> Replacement template that will be used to render output instead of the stubbed out component. Returns ComponentFactoryCollection A ComponentFactoryCollection. Type Parameters TComponent The type of component to replace with a Stub<TComponent> component. Remarks NOTE: This will replace any component of type TComponent or components that derives/inherits from it. AddStub<TComponent>(ComponentFactoryCollection, string) Configures bUnit to use replace all components of type TComponent (including derived components) with a Stub<TComponent> component in the render tree. public static ComponentFactoryCollection AddStub<TComponent>(this ComponentFactoryCollection factories, string replacementMarkup) where TComponent : IComponent Parameters factories ComponentFactoryCollection The bUnit ComponentFactoryCollection to configure. replacementMarkup string Markup that will be used as render output instead of the stubbed out component. Returns ComponentFactoryCollection A ComponentFactoryCollection. Type Parameters TComponent The type of component to replace with a Stub<TComponent> component. Remarks NOTE: This will replace any component of type TComponent or components that derives/inherits from it."
  },
  "api/Bunit.TestContext.html": {
    "href": "api/Bunit.TestContext.html",
    "title": "Class TestContext | bUnit",
    "keywords": "Class TestContext Namespace Bunit Assembly bunit.dll A test context is a factory that makes it possible to create components under tests. [Obsolete(\"Use BunitContext instead. TestContext will be removed in a future release.\", false, UrlFormat = \"https://bunit.dev/docs/migrations\")] public class TestContext : BunitContext, IDisposable, IAsyncDisposable Inheritance object BunitContext TestContext Implements IDisposable IAsyncDisposable Inherited Members BunitContext.Dispose() BunitContext.DisposeAsync() BunitContext.DisposeAsyncCore() BunitContext.Dispose(bool) BunitContext.DisposeComponentsAsync() BunitContext.Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>) BunitContext.Render<TComponent>(RenderFragment) BunitContext.Render(RenderFragment) BunitContext.SetRendererInfo(RendererInfo) BunitContext.BuildRenderTree(RenderTreeBuilder) BunitContext.RenderComponent<TComponent>() BunitContext.RenderComponent<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>) BunitContext.AddAuthorization() BunitContext.AddBunitPersistentComponentState() BunitContext.DefaultWaitTimeout BunitContext.Renderer BunitContext.JSInterop BunitContext.Services BunitContext.RenderTree BunitContext.ComponentFactories object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors TestContext() public TestContext()"
  },
  "api/Bunit.TestDoubles.AuthorizationState.html": {
    "href": "api/Bunit.TestDoubles.AuthorizationState.html",
    "title": "Enum AuthorizationState | bUnit",
    "keywords": "Enum AuthorizationState Namespace Bunit.TestDoubles Assembly bunit.dll Enumeration that represents the user's authorization state. public enum AuthorizationState Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Fields Authorized = 1 Represents authorized user state. Authorizing = 2 Represents authorizing user state. Unauthorized = 0 Represents unauthorized user state."
  },
  "api/Bunit.TestDoubles.BunitAuthenticationStateProvider.html": {
    "href": "api/Bunit.TestDoubles.BunitAuthenticationStateProvider.html",
    "title": "Class BunitAuthenticationStateProvider | bUnit",
    "keywords": "Class BunitAuthenticationStateProvider Namespace Bunit.TestDoubles Assembly bunit.dll Represents a implementation of AuthenticationStateProvider for testing purposes that allows user to test components that use authentication and authorization. public class BunitAuthenticationStateProvider : AuthenticationStateProvider Inheritance object AuthenticationStateProvider BunitAuthenticationStateProvider Inherited Members AuthenticationStateProvider.NotifyAuthenticationStateChanged(Task<AuthenticationState>) AuthenticationStateProvider.AuthenticationStateChanged object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitAuthenticationStateProvider() Initializes a new instance of the BunitAuthenticationStateProvider class. public BunitAuthenticationStateProvider() BunitAuthenticationStateProvider(string, IEnumerable<string>?, IEnumerable<Claim>?, string?) Initializes a new instance of the BunitAuthenticationStateProvider class with an initial AuthenticationState. public BunitAuthenticationStateProvider(string userName, IEnumerable<string>? roles = null, IEnumerable<Claim>? claims = null, string? authenticationType = null) Parameters userName string Identity's user name. roles IEnumerable<string> Roles that this user principal has. claims IEnumerable<Claim> Claims to add to user principal. authenticationType string The authentication type for the user principal. Methods GetAuthenticationStateAsync() Overridden method to get the current authentication state. public override Task<AuthenticationState> GetAuthenticationStateAsync() Returns Task<AuthenticationState> Current authentication state. TriggerAuthenticationStateChanged(string, IEnumerable<string>?, IEnumerable<Claim>?, string?) Method to sets the authentication state and authenticated user. public void TriggerAuthenticationStateChanged(string userName, IEnumerable<string>? roles = null, IEnumerable<Claim>? claims = null, string? authenticationType = null) Parameters userName string Identity's user name. roles IEnumerable<string> Roles that this user principal has. claims IEnumerable<Claim> Claims to add to user principal. authenticationType string The authentication type for the user principal. TriggerAuthorizingStateChanged() Method to sets the authentication state to authorizing state. public void TriggerAuthorizingStateChanged() TriggerUnauthenticationStateChanged() Method to sets the authentication state to unauthenticated. public void TriggerUnauthenticationStateChanged()"
  },
  "api/Bunit.TestDoubles.BunitAuthorizationContext.html": {
    "href": "api/Bunit.TestDoubles.BunitAuthorizationContext.html",
    "title": "Class BunitAuthorizationContext | bUnit",
    "keywords": "Class BunitAuthorizationContext Namespace Bunit.TestDoubles Assembly bunit.dll Root authorization service that manages different authentication/authorization state in the system. public class BunitAuthorizationContext Inheritance object BunitAuthorizationContext Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Properties Claims Gets the set of principal claims for the current user. public IEnumerable<Claim> Claims { get; } Property Value IEnumerable<Claim> IsAuthenticated Gets a value indicating whether user is authenticated. public bool IsAuthenticated { get; } Property Value bool Policies Gets the set of authentication policies for the current user. public IEnumerable<string> Policies { get; } Property Value IEnumerable<string> PolicySchemeName Gets or sets the policy schemeName. Defaults to TestScheme and usually doesn't need to be changed by user. public string PolicySchemeName { get; set; } Property Value string Roles Gets the set of roles for the current user. public IEnumerable<string> Roles { get; } Property Value IEnumerable<string> State Gets the authorization state for the user. public AuthorizationState State { get; } Property Value AuthorizationState UserName Gets the authorization context user name. public string UserName { get; } Property Value string Methods SetAuthenticationType(string) Sets the Identity.AuthenticationType for the current user/principa;. public BunitAuthorizationContext SetAuthenticationType(string authenticationType) Parameters authenticationType string The authentication type to set. Returns BunitAuthorizationContext SetAuthorized(string, AuthorizationState) Authenticates the user with specified name and authorization state. public BunitAuthorizationContext SetAuthorized(string userName, AuthorizationState state = AuthorizationState.Authorized) Parameters userName string User name for the principal identity. state AuthorizationState Authorization state. Returns BunitAuthorizationContext SetAuthorizing() Puts the authorization services into the authorizing state. public BunitAuthorizationContext SetAuthorizing() Returns BunitAuthorizationContext SetClaims(params Claim[]) Sets the claims on the current user/principal. public BunitAuthorizationContext SetClaims(params Claim[] claims) Parameters claims Claim[] Claims to set. Returns BunitAuthorizationContext SetNotAuthorized() Puts the authorization services into an unauthenticated and unauthorized state. public BunitAuthorizationContext SetNotAuthorized() Returns BunitAuthorizationContext SetPolicies(params string[]) Sets the authorization policies supported for the current user. public BunitAuthorizationContext SetPolicies(params string[] policies) Parameters policies string[] Supported authorization policies. Returns BunitAuthorizationContext SetRoles(params string[]) Sets the user roles in this context.. public BunitAuthorizationContext SetRoles(params string[] roles) Parameters roles string[] Roles for the claims principal. Returns BunitAuthorizationContext"
  },
  "api/Bunit.TestDoubles.BunitAuthorizationPolicyProvider.html": {
    "href": "api/Bunit.TestDoubles.BunitAuthorizationPolicyProvider.html",
    "title": "Class BunitAuthorizationPolicyProvider | bUnit",
    "keywords": "Class BunitAuthorizationPolicyProvider Namespace Bunit.TestDoubles Assembly bunit.dll Test class that provides an implementation of IAuthorizationPolicyProvider that assists user in testing components that use authentication and authorization. public class BunitAuthorizationPolicyProvider : IAuthorizationPolicyProvider Inheritance object BunitAuthorizationPolicyProvider Implements IAuthorizationPolicyProvider Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitAuthorizationPolicyProvider() public BunitAuthorizationPolicyProvider() Methods GetDefaultPolicyAsync() Gets the default authorization policy. public Task<AuthorizationPolicy> GetDefaultPolicyAsync() Returns Task<AuthorizationPolicy> Default policy. GetFallbackPolicyAsync() Gets the fallback authorization policy. public Task<AuthorizationPolicy?> GetFallbackPolicyAsync() Returns Task<AuthorizationPolicy> Fallback policy. GetPolicyAsync(string) Get the current policy, which in this implementation just returns a test policy. public Task<AuthorizationPolicy?> GetPolicyAsync(string policyName) Parameters policyName string Policy name. Returns Task<AuthorizationPolicy> Test policy for the specified name. SetPolicyScheme(string) Sets the currently supported policies for this provider. public void SetPolicyScheme(string policySchemeName) Parameters policySchemeName string Policy scheme name to use."
  },
  "api/Bunit.TestDoubles.BunitAuthorizationService.html": {
    "href": "api/Bunit.TestDoubles.BunitAuthorizationService.html",
    "title": "Class BunitAuthorizationService | bUnit",
    "keywords": "Class BunitAuthorizationService Namespace Bunit.TestDoubles Assembly bunit.dll Test class that provides an implementation of IAuthorizationService that assists user in testing components by allowing them to set the authorization expected authorization response. public class BunitAuthorizationService : IAuthorizationService Inheritance object BunitAuthorizationService Implements IAuthorizationService Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitAuthorizationService(AuthorizationState) Initializes a new instance of the BunitAuthorizationService class. public BunitAuthorizationService(AuthorizationState state = AuthorizationState.Authorized) Parameters state AuthorizationState Initial authorization state. Methods AuthorizeAsync(ClaimsPrincipal, object?, IEnumerable<IAuthorizationRequirement>) Authorizes the Principal user based solely on the current authorization state. public Task<AuthorizationResult> AuthorizeAsync(ClaimsPrincipal user, object? resource, IEnumerable<IAuthorizationRequirement> requirements) Parameters user ClaimsPrincipal Principal user to authorize. resource object Resource being authorized. requirements IEnumerable<IAuthorizationRequirement> Authorization requirements. Returns Task<AuthorizationResult> Result of authorize request. AuthorizeAsync(ClaimsPrincipal, object?, string) Authorizes the Principal user based solely on the current authorization state. public Task<AuthorizationResult> AuthorizeAsync(ClaimsPrincipal user, object? resource, string policyName) Parameters user ClaimsPrincipal Principal user to authorize. resource object Resource being authorized. policyName string Policy to use for authorization. Returns Task<AuthorizationResult> Result of authorize request. SetAuthorizationState(AuthorizationState) Method to explicitly set the authorization state. public void SetAuthorizationState(AuthorizationState state) Parameters state AuthorizationState New state to set. SetPolicies(IEnumerable<string>) Sets the supported policies in the Authorization service for current user. public void SetPolicies(IEnumerable<string> policies) Parameters policies IEnumerable<string> List of supported policies. SetRoles(IEnumerable<string>) Sets the supported roles in the Authorization service for current user. public void SetRoles(IEnumerable<string> roles) Parameters roles IEnumerable<string> List of supported roles."
  },
  "api/Bunit.TestDoubles.BunitNavigationManager.html": {
    "href": "api/Bunit.TestDoubles.BunitNavigationManager.html",
    "title": "Class BunitNavigationManager | bUnit",
    "keywords": "Class BunitNavigationManager Namespace Bunit.TestDoubles Assembly bunit.dll Represents a NavigationManager that captures calls to NavigateTo(string, bool) for testing purposes. public sealed class BunitNavigationManager : NavigationManager Inheritance object NavigationManager BunitNavigationManager Inherited Members NavigationManager.NavigateTo(string, bool) NavigationManager.NavigateTo(string, bool, bool) NavigationManager.NavigateTo(string, NavigationOptions) NavigationManager.Refresh(bool) NavigationManager.NotFound() NavigationManager.ToAbsoluteUri(string) NavigationManager.ToBaseRelativePath(string) NavigationManager.RegisterLocationChangingHandler(Func<LocationChangingContext, ValueTask>) NavigationManager.BaseUri NavigationManager.Uri NavigationManager.HistoryEntryState NavigationManager.LocationChanged NavigationManager.OnNotFound object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitNavigationManager(BunitContext) Initializes a new instance of the BunitNavigationManager class. public BunitNavigationManager(BunitContext bunitContext) Parameters bunitContext BunitContext Properties History The navigation history captured by the BunitNavigationManager. This is a stack based collection, so the first element is the latest/current navigation target. public IReadOnlyCollection<NavigationHistory> History { get; } Property Value IReadOnlyCollection<NavigationHistory> Remarks The initial Uri is not added to the history. Methods HandleLocationChangingHandlerException(Exception, LocationChangingContext) Handles exceptions thrown in location changing handlers. protected override void HandleLocationChangingHandlerException(Exception ex, LocationChangingContext context) Parameters ex Exception The exception to handle. context LocationChangingContext The context passed to the handler. NavigateToCore(string, NavigationOptions) Navigates to the specified URI. protected override void NavigateToCore(string uri, NavigationOptions options) Parameters uri string The destination URI. This can be absolute, or relative to the base URI (as returned by BaseUri). options NavigationOptions Provides additional NavigationOptions. SetNavigationLockState(bool) Sets whether navigation is currently locked. If it is, then implementations should not update Uri and call NotifyLocationChanged(bool) until they have first confirmed the navigation by calling NotifyLocationChangingAsync(string, string, bool). protected override void SetNavigationLockState(bool value) Parameters value bool Whether navigation is currently locked."
  },
  "api/Bunit.TestDoubles.BunitPersistentComponentState.html": {
    "href": "api/Bunit.TestDoubles.BunitPersistentComponentState.html",
    "title": "Class BunitPersistentComponentState | bUnit",
    "keywords": "Class BunitPersistentComponentState Namespace Bunit.TestDoubles Assembly bunit.dll Represents a PersistentComponentState, that can be used to the real PersistentComponentState in the Blazor runtime. public sealed class BunitPersistentComponentState Inheritance object BunitPersistentComponentState Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Methods Persist<TValue>(string, TValue) Persists instance under the given key in the store. public void Persist<TValue>(string key, TValue instance) Parameters key string The key to use to persist the state. instance TValue The instance to persist. Type Parameters TValue The instance type. Remarks Only call this method after all services has been registered with the Services. Calling this method will lookup dependencies of the BunitPersistentComponentState from the BunitServiceProvider, which means no other services can be registered after this point. TriggerOnPersisting() Triggers any listeners registered to the RegisterOnPersisting(Func<Task>) method. Use this method to emulate the Blazor runtime invoking the OnPersisting callbacks during component persistence. public void TriggerOnPersisting() Remarks Only call this method after all services has been registered with the Services. Calling this method will lookup dependencies of the BunitPersistentComponentState from the BunitServiceProvider, which means no other services can be registered after this point. TryTake<TValue>(string, out TValue?) Tries to retrieve the persisted state with the given key. When the key is present, the state is successfully returned via instance. public bool TryTake<TValue>(string key, out TValue? instance) Parameters key string The key used to persist the instance. instance TValue The persisted instance. Returns bool true if the state was found; false otherwise. Type Parameters TValue Remarks Only call this method after all services has been registered with the Services. Calling this method will lookup dependencies of the BunitPersistentComponentState from the BunitServiceProvider, which means no other services can be registered after this point."
  },
  "api/Bunit.TestDoubles.BunitSignOutSessionStateManager.html": {
    "href": "api/Bunit.TestDoubles.BunitSignOutSessionStateManager.html",
    "title": "Class BunitSignOutSessionStateManager | bUnit",
    "keywords": "Class BunitSignOutSessionStateManager Namespace Bunit.TestDoubles Assembly bunit.dll Represents bUnit's own SignOutSessionStateManager that captures calls to SetSignOutState() that will help later to assert if the user was logged out public class BunitSignOutSessionStateManager : SignOutSessionStateManager Inheritance object SignOutSessionStateManager BunitSignOutSessionStateManager Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitSignOutSessionStateManager(IJSRuntime) Initializes a new instance of BunitSignOutSessionStateManager public BunitSignOutSessionStateManager(IJSRuntime jsRuntime) Parameters jsRuntime IJSRuntime Properties IsSignedOut Returns true when SetSignOutState() was called, otherwise false public bool IsSignedOut { get; set; } Property Value bool Methods SetSignOutState() Sets up some state in session storage to allow for logouts from within the LogoutPath page. public override ValueTask SetSignOutState() Returns ValueTask A ValueTask that completes when the state has been saved to session storage. ValidateSignOutState() Validates the existence of some state previously setup by SetSignOutState() in session storage to allow logouts from within the LogoutPath page. public override Task<bool> ValidateSignOutState() Returns Task<bool> A Task that completes when the state has been validated and indicates the validity of the state."
  },
  "api/Bunit.TestDoubles.BunitWebAssemblyHostEnvironment.html": {
    "href": "api/Bunit.TestDoubles.BunitWebAssemblyHostEnvironment.html",
    "title": "Class BunitWebAssemblyHostEnvironment | bUnit",
    "keywords": "Class BunitWebAssemblyHostEnvironment Namespace Bunit.TestDoubles Assembly bunit.dll Represents bUnit's own IWebAssemblyHostEnvironment that makes the Environment and BaseAddress settable. public class BunitWebAssemblyHostEnvironment : IWebAssemblyHostEnvironment Inheritance object BunitWebAssemblyHostEnvironment Implements IWebAssemblyHostEnvironment Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors BunitWebAssemblyHostEnvironment() public BunitWebAssemblyHostEnvironment() Properties BaseAddress Gets or sets the base address. Default is /. public string BaseAddress { get; set; } Property Value string Environment Gets or sets the name of the environment. Default is Production. public string Environment { get; set; } Property Value string Methods SetEnvironmentToDevelopment() Sets the Environment property to Development. public void SetEnvironmentToDevelopment() SetEnvironmentToProduction() Sets the Environment property to Production. public void SetEnvironmentToProduction() SetEnvironmentToStaging() Sets the Environment property to Staging. public void SetEnvironmentToStaging()"
  },
  "api/Bunit.TestDoubles.CapturedParameterView-1.html": {
    "href": "api/Bunit.TestDoubles.CapturedParameterView-1.html",
    "title": "Class CapturedParameterView<TComponent> | bUnit",
    "keywords": "Class CapturedParameterView<TComponent> Namespace Bunit.TestDoubles Assembly bunit.dll Represents a view of parameters captured by a ComponentDoubleBase<TComponent>. public class CapturedParameterView<TComponent> : IReadOnlyDictionary<string, object>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable where TComponent : IComponent Type Parameters TComponent Inheritance object CapturedParameterView<TComponent> Implements IReadOnlyDictionary<string, object> IReadOnlyCollection<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>> IEnumerable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Properties Count public int Count { get; } Property Value int Empty Gets a empty CapturedParameterView<TComponent>. public static CapturedParameterView<TComponent> Empty { get; } Property Value CapturedParameterView<TComponent> this[string] Gets the value of the parameter with the key. public object this[string key] { get; } Parameters key string Name of the parameter to get. Property Value object The value of the parameter Keys public IEnumerable<string> Keys { get; } Property Value IEnumerable<string> Values public IEnumerable<object> Values { get; } Property Value IEnumerable<object> Methods ContainsKey(string) public bool ContainsKey(string key) Parameters key string Returns bool From(ParameterView) Create an instances of the CapturedParameterView<TComponent> from the parameters ParameterView. public static CapturedParameterView<TComponent> From(ParameterView parameters) Parameters parameters ParameterView Parameters to create from. Returns CapturedParameterView<TComponent> An instance of CapturedParameterView<TComponent>. GetEnumerator() public IEnumerator<KeyValuePair<string, object>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, object>> Get<TValue>(Expression<Func<TComponent, TValue>>) Gets the value of a parameter passed to the captured TComponent, using the parameterSelector. public TValue Get<TValue>(Expression<Func<TComponent, TValue>> parameterSelector) Parameters parameterSelector Expression<Func<TComponent, TValue>> A parameter selector that selects the parameter property of TComponent. Returns TValue The TValue. Type Parameters TValue The type of the parameter to find. Exceptions ArgumentNullException Thrown when parameterSelector is null. ArgumentException Thrown when the member of TComponent selected by the parameterSelector is not a Blazor parameter. ParameterNotFoundException Thrown when the selected parameter was not passed to the captured TComponent. InvalidCastException Throw when the type of the value passed to the selected parameter is not the same as the selected parameters type, i.e. TValue. TryGetValue(string, out object) public bool TryGetValue(string key, out object value) Parameters key string value object Returns bool"
  },
  "api/Bunit.TestDoubles.ComponentDoubleBase-1.html": {
    "href": "api/Bunit.TestDoubles.ComponentDoubleBase-1.html",
    "title": "Class ComponentDoubleBase<TComponent> | bUnit",
    "keywords": "Class ComponentDoubleBase<TComponent> Namespace Bunit.TestDoubles Assembly bunit.dll Represents a component that doubles as another component in the render tree. public abstract class ComponentDoubleBase<TComponent> : IComponent where TComponent : IComponent Type Parameters TComponent Inheritance object ComponentDoubleBase<TComponent> Implements IComponent Derived Stub<TComponent> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ComponentDoubleBase() protected ComponentDoubleBase() Fields DoubledType The type of the doubled component. protected static readonly Type DoubledType Field Value Type Properties Parameters Gets the parameters that was passed to the TComponent that this stub replaced in the component tree. [Parameter(CaptureUnmatchedValues = true)] public CapturedParameterView<TComponent> Parameters { get; set; } Property Value CapturedParameterView<TComponent> Methods BuildRenderTree(RenderTreeBuilder) Override to generate a DOM tree from the doubled component. protected virtual void BuildRenderTree(RenderTreeBuilder builder) Parameters builder RenderTreeBuilder A RenderTreeBuilder to build DOM tree. SetParametersAsync(ParameterView) Sets parameters supplied by the component's parent in the render tree. public virtual Task SetParametersAsync(ParameterView parameters) Parameters parameters ParameterView The parameters. Returns Task A Task that completes when the component has finished updating and rendering itself. Remarks The SetParametersAsync(ParameterView) method should be passed the entire set of parameter values each time SetParametersAsync(ParameterView) is called. It not required that the caller supply a parameter value for all parameters that are logically understood by the component."
  },
  "api/Bunit.TestDoubles.MissingBunitAuthorizationException.html": {
    "href": "api/Bunit.TestDoubles.MissingBunitAuthorizationException.html",
    "title": "Class MissingBunitAuthorizationException | bUnit",
    "keywords": "Class MissingBunitAuthorizationException Namespace Bunit.TestDoubles Assembly bunit.dll Exception used to indicate that the bunit authorization services are required by a test but provided in BunitContext.Services. public sealed class MissingBunitAuthorizationException : Exception, ISerializable Inheritance object Exception MissingBunitAuthorizationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors MissingBunitAuthorizationException(string) Initializes a new instance of the MissingBunitAuthorizationException class with the arguments used in the invocation. public MissingBunitAuthorizationException(string serviceName) Parameters serviceName string The service being used. Properties ServiceName Gets the invoking service name. public string ServiceName { get; } Property Value string"
  },
  "api/Bunit.TestDoubles.MissingMockHttpClientException.html": {
    "href": "api/Bunit.TestDoubles.MissingMockHttpClientException.html",
    "title": "Class MissingMockHttpClientException | bUnit",
    "keywords": "Class MissingMockHttpClientException Namespace Bunit.TestDoubles Assembly bunit.dll Exception use to indicate that a mock HttpClient is required by a test but was not provided. public sealed class MissingMockHttpClientException : Exception, ISerializable Inheritance object Exception MissingMockHttpClientException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors MissingMockHttpClientException(HttpRequestMessage) Initializes a new instance of the MissingMockHttpClientException class with the request that would have been handled. public MissingMockHttpClientException(HttpRequestMessage request) Parameters request HttpRequestMessage The request being handled by the client. Properties Request Gets the request that was sent via the HTTP client. public HttpRequestMessage? Request { get; } Property Value HttpRequestMessage"
  },
  "api/Bunit.TestDoubles.MissingMockStringLocalizationException.html": {
    "href": "api/Bunit.TestDoubles.MissingMockStringLocalizationException.html",
    "title": "Class MissingMockStringLocalizationException | bUnit",
    "keywords": "Class MissingMockStringLocalizationException Namespace Bunit.TestDoubles Assembly bunit.dll Exception use to indicate that a IStringLocalizer is required by a test but was not provided. public sealed class MissingMockStringLocalizationException : Exception, ISerializable Inheritance object Exception MissingMockStringLocalizationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors MissingMockStringLocalizationException(string, params object?[]) Initializes a new instance of the MissingMockStringLocalizationException class with the method name and arguments used in the invocation. public MissingMockStringLocalizationException(string methodName, params object?[] arguments) Parameters methodName string The method that was called on the localizer. arguments object[] The arguments that were passed in. Properties Arguments Gets the arguments that were passed into the localizer. public IReadOnlyList<object?> Arguments { get; } Property Value IReadOnlyList<object>"
  },
  "api/Bunit.TestDoubles.NavigationHistory.html": {
    "href": "api/Bunit.TestDoubles.NavigationHistory.html",
    "title": "Class NavigationHistory | bUnit",
    "keywords": "Class NavigationHistory Namespace Bunit.TestDoubles Assembly bunit.dll Represents a navigation to a Uri with a set of specific navigation Options. public sealed record NavigationHistory : IEquatable<NavigationHistory> Inheritance object NavigationHistory Implements IEquatable<NavigationHistory> Inherited Members object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors NavigationHistory(string, NavigationOptions, NavigationState, Exception?) Initializes a new instance of the NavigationHistory class. public NavigationHistory(string uri, NavigationOptions options, NavigationState navigationState, Exception? exception = null) Parameters uri string options NavigationOptions navigationState NavigationState exception Exception Properties Exception Gets the exception thrown from the OnBeforeInternalNavigation handler, if any. public Exception? Exception { get; } Property Value Exception Remarks Will not be null when State is Faulted. Options Gets the options that was specified when the was navigated to. public NavigationOptions Options { get; } Property Value NavigationOptions State Gets the NavigationState associated with this history entry. public NavigationState State { get; } Property Value NavigationState Uri Gets the Uri that was navigated to. public string Uri { get; } Property Value string Methods Equals(NavigationHistory?) public bool Equals(NavigationHistory? other) Parameters other NavigationHistory Returns bool Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int StateFromJson<T>(JsonSerializerOptions?) Deserialize the content of Options.HistoryEntryState into T if it is not null. public T? StateFromJson<T>(JsonSerializerOptions? options = null) Parameters options JsonSerializerOptions The JsonSerializerOptions used when deserializing. If not provided, Default is used. Returns T The target type of the JSON value. Type Parameters T The type to deserialize the content of Options.HistoryEntryState to. Exceptions InvalidOperationException When Options.HistoryEntryState is null. ToString() public override string ToString() Returns string <Clone>$() public NavigationHistory <Clone>$() Returns NavigationHistory Operators operator ==(NavigationHistory?, NavigationHistory?) public static bool operator ==(NavigationHistory? left, NavigationHistory? right) Parameters left NavigationHistory right NavigationHistory Returns bool operator !=(NavigationHistory?, NavigationHistory?) public static bool operator !=(NavigationHistory? left, NavigationHistory? right) Parameters left NavigationHistory right NavigationHistory Returns bool"
  },
  "api/Bunit.TestDoubles.NavigationState.html": {
    "href": "api/Bunit.TestDoubles.NavigationState.html",
    "title": "Enum NavigationState | bUnit",
    "keywords": "Enum NavigationState Namespace Bunit.TestDoubles Assembly bunit.dll Describes the possible enumerations when a navigation gets intercepted. public enum NavigationState Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Fields Faulted = 2 The OnBeforeInternalNavigation event handler threw an exception and the navigation did not complete. Prevented = 1 The navigation was prevented. Succeeded = 0 The navigation was successfully executed."
  },
  "api/Bunit.TestDoubles.ParameterNotFoundException.html": {
    "href": "api/Bunit.TestDoubles.ParameterNotFoundException.html",
    "title": "Class ParameterNotFoundException | bUnit",
    "keywords": "Class ParameterNotFoundException Namespace Bunit.TestDoubles Assembly bunit.dll Represents an exception which is thrown when the Get<TValue>(Expression<Func<TComponent, TValue>>) is used to get a parameter that was not passed to the doubled component. public sealed class ParameterNotFoundException : Exception, ISerializable Inheritance object Exception ParameterNotFoundException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors ParameterNotFoundException(string, string) Initializes a new instance of the ParameterNotFoundException class. public ParameterNotFoundException(string parameterName, string componentName) Parameters parameterName string componentName string"
  },
  "api/Bunit.TestDoubles.Stub-1.html": {
    "href": "api/Bunit.TestDoubles.Stub-1.html",
    "title": "Class Stub<TComponent> | bUnit",
    "keywords": "Class Stub<TComponent> Namespace Bunit.TestDoubles Assembly bunit.dll Represents a test double stub of a component of type TComponent. public sealed class Stub<TComponent> : ComponentDoubleBase<TComponent>, IComponent where TComponent : IComponent Type Parameters TComponent The stub type. Inheritance object ComponentDoubleBase<TComponent> Stub<TComponent> Implements IComponent Inherited Members ComponentDoubleBase<TComponent>.SetParametersAsync(ParameterView) ComponentDoubleBase<TComponent>.Parameters object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors Stub() Initializes a new instance of the Stub<TComponent> class. public Stub() Stub(object?) Initializes a new instance of the Stub<TComponent> class that uses the provided replacement when rendering. public Stub(object? replacement) Parameters replacement object The replacement template to use when rendering. Methods BuildRenderTree(RenderTreeBuilder) Override to generate a DOM tree from the doubled component. protected override void BuildRenderTree(RenderTreeBuilder builder) Parameters builder RenderTreeBuilder A RenderTreeBuilder to build DOM tree. ToString() public override string ToString() Returns string"
  },
  "api/Bunit.TestDoubles.TestPolicyRequirement.html": {
    "href": "api/Bunit.TestDoubles.TestPolicyRequirement.html",
    "title": "Class TestPolicyRequirement | bUnit",
    "keywords": "Class TestPolicyRequirement Namespace Bunit.TestDoubles Assembly bunit.dll Test requirement that supports the minimum requirement - just a policy name. public class TestPolicyRequirement : IAuthorizationRequirement Inheritance object TestPolicyRequirement Implements IAuthorizationRequirement Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors TestPolicyRequirement() public TestPolicyRequirement() Properties PolicyName Gets or sets the policy name for this requirement. public string PolicyName { get; set; } Property Value string"
  },
  "api/Bunit.TestDoubles.html": {
    "href": "api/Bunit.TestDoubles.html",
    "title": "Namespace Bunit.TestDoubles | bUnit",
    "keywords": "Namespace Bunit.TestDoubles Classes BunitAuthenticationStateProvider Represents a implementation of AuthenticationStateProvider for testing purposes that allows user to test components that use authentication and authorization. BunitAuthorizationContext Root authorization service that manages different authentication/authorization state in the system. BunitAuthorizationPolicyProvider Test class that provides an implementation of IAuthorizationPolicyProvider that assists user in testing components that use authentication and authorization. BunitAuthorizationService Test class that provides an implementation of IAuthorizationService that assists user in testing components by allowing them to set the authorization expected authorization response. BunitNavigationManager Represents a NavigationManager that captures calls to NavigateTo(string, bool) for testing purposes. BunitPersistentComponentState Represents a PersistentComponentState, that can be used to the real PersistentComponentState in the Blazor runtime. BunitSignOutSessionStateManager Represents bUnit's own SignOutSessionStateManager that captures calls to SetSignOutState() that will help later to assert if the user was logged out BunitWebAssemblyHostEnvironment Represents bUnit's own IWebAssemblyHostEnvironment that makes the Environment and BaseAddress settable. CapturedParameterView<TComponent> Represents a view of parameters captured by a ComponentDoubleBase<TComponent>. ComponentDoubleBase<TComponent> Represents a component that doubles as another component in the render tree. MissingBunitAuthorizationException Exception used to indicate that the bunit authorization services are required by a test but provided in BunitContext.Services. MissingMockHttpClientException Exception use to indicate that a mock HttpClient is required by a test but was not provided. MissingMockStringLocalizationException Exception use to indicate that a IStringLocalizer is required by a test but was not provided. NavigationHistory Represents a navigation to a Uri with a set of specific navigation Options. ParameterNotFoundException Represents an exception which is thrown when the Get<TValue>(Expression<Func<TComponent, TValue>>) is used to get a parameter that was not passed to the doubled component. Stub<TComponent> Represents a test double stub of a component of type TComponent. TestPolicyRequirement Test requirement that supports the minimum requirement - just a policy name. Enums AuthorizationState Enumeration that represents the user's authorization state. NavigationState Describes the possible enumerations when a navigation gets intercepted."
  },
  "api/Bunit.TriggerEventDispatchExtensions.html": {
    "href": "api/Bunit.TriggerEventDispatchExtensions.html",
    "title": "Class TriggerEventDispatchExtensions | bUnit",
    "keywords": "Class TriggerEventDispatchExtensions Namespace Bunit Assembly bunit.dll General event dispatch helper extension methods. public static class TriggerEventDispatchExtensions Inheritance object TriggerEventDispatchExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods TriggerEvent(IElement, string, EventArgs) Raises the event eventName on the element element passing the eventArgs to the event handler. public static void TriggerEvent(this IElement element, string eventName, EventArgs eventArgs) Parameters element IElement The element to raise the event on. eventName string The name of the event to raise (using on-form, e.g. onclick). eventArgs EventArgs The event arguments to pass to the event handler. Use Empty to pass an empty EventArgs. TriggerEventAsync(IElement, string, EventArgs) Raises the event eventName on the element element passing the eventArgs to the event handler. public static Task TriggerEventAsync(this IElement element, string eventName, EventArgs eventArgs) Parameters element IElement The element to raise the event on. eventName string The name of the event to raise (using on-form, e.g. onclick). eventArgs EventArgs The event arguments to pass to the event handler. Returns Task A Task that completes when the render caused by the triggering of the event finishes."
  },
  "api/Bunit.Web.AngleSharp.IElementWrapper-1.html": {
    "href": "api/Bunit.Web.AngleSharp.IElementWrapper-1.html",
    "title": "Interface IElementWrapper<TElement> | bUnit",
    "keywords": "Interface IElementWrapper<TElement> Namespace Bunit.Web.AngleSharp Assembly bunit.dll Represents a wrapper around an TElement. public interface IElementWrapper<out TElement> where TElement : class, IElement Type Parameters TElement Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Properties WrappedElement Gets the wrapped element. TElement WrappedElement { get; } Property Value TElement"
  },
  "api/Bunit.Web.AngleSharp.IElementWrapperFactory.html": {
    "href": "api/Bunit.Web.AngleSharp.IElementWrapperFactory.html",
    "title": "Interface IElementWrapperFactory | bUnit",
    "keywords": "Interface IElementWrapperFactory Namespace Bunit.Web.AngleSharp Assembly bunit.dll Represents an AngleSharp.Dom.IElement factory, used by a WrapperBase<TElement>. public interface IElementWrapperFactory Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Properties OnElementReplaced Subscribe to updates to the wrapped elements. Action? OnElementReplaced { get; set; } Property Value Action Methods GetElement<TElement>() A method that returns the latest version of the element to wrap. TElement GetElement<TElement>() where TElement : class, IElement Returns TElement Type Parameters TElement Remarks This method should throw if the element is not found or is not of the correct type (TElement)."
  },
  "api/Bunit.Web.AngleSharp.WrapperBase-1.html": {
    "href": "api/Bunit.Web.AngleSharp.WrapperBase-1.html",
    "title": "Class WrapperBase<TElement> | bUnit",
    "keywords": "Class WrapperBase<TElement> Namespace Bunit.Web.AngleSharp Assembly bunit.dll Represents a wrapper AngleSharp.Dom.IElement. public abstract class WrapperBase<TElement> : IElementWrapper<TElement> where TElement : class, IElement Type Parameters TElement Inheritance object WrapperBase<TElement> Implements IElementWrapper<TElement> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Extension Methods JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) JSRuntimeAssertExtensions.ShouldBeElementReferenceTo(object?, IElement) Constructors WrapperBase(TElement, IElementWrapperFactory) Creates an instance of the WrapperBase<TElement> class. protected WrapperBase(TElement element, IElementWrapperFactory elementFactory) Parameters element TElement elementFactory IElementWrapperFactory Properties WrappedElement Gets the wrapped element. public TElement WrappedElement { get; } Property Value TElement Methods Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int Operators operator ==(WrapperBase<TElement>, TElement) public static bool operator ==(WrapperBase<TElement> x, TElement y) Parameters x WrapperBase<TElement> y TElement Returns bool operator ==(TElement, WrapperBase<TElement>) public static bool operator ==(TElement x, WrapperBase<TElement> y) Parameters x TElement y WrapperBase<TElement> Returns bool operator !=(WrapperBase<TElement>, TElement) public static bool operator !=(WrapperBase<TElement> x, TElement y) Parameters x WrapperBase<TElement> y TElement Returns bool operator !=(TElement, WrapperBase<TElement>) public static bool operator !=(TElement x, WrapperBase<TElement> y) Parameters x TElement y WrapperBase<TElement> Returns bool"
  },
  "api/Bunit.Web.AngleSharp.WrapperExtensions.html": {
    "href": "api/Bunit.Web.AngleSharp.WrapperExtensions.html",
    "title": "Class WrapperExtensions | bUnit",
    "keywords": "Class WrapperExtensions Namespace Bunit.Web.AngleSharp Assembly bunit.dll Provide helpers for wrapped HTML elements. public static class WrapperExtensions Inheritance object WrapperExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods WrapUsing<TElementFactory>(IElement, TElementFactory) Provide wrapper to be used when elements re-render. public static IElement WrapUsing<TElementFactory>(this IElement element, TElementFactory elementFactory) where TElementFactory : IElementWrapperFactory Parameters element IElement elementFactory TElementFactory Returns IElement Type Parameters TElementFactory"
  },
  "api/Bunit.Web.AngleSharp.html": {
    "href": "api/Bunit.Web.AngleSharp.html",
    "title": "Namespace Bunit.Web.AngleSharp | bUnit",
    "keywords": "Namespace Bunit.Web.AngleSharp Classes WrapperBase<TElement> Represents a wrapper AngleSharp.Dom.IElement. WrapperExtensions Provide helpers for wrapped HTML elements. Interfaces IElementWrapperFactory Represents an AngleSharp.Dom.IElement factory, used by a WrapperBase<TElement>. IElementWrapper<TElement> Represents a wrapper around an TElement."
  },
  "api/Bunit.html": {
    "href": "api/Bunit.html",
    "title": "Namespace Bunit | bUnit",
    "keywords": "Namespace Bunit Classes BunitContext A test context is a factory that makes it possible to create components under tests. BunitJSInterop Represents an bUnit's implementation of Blazor's JSInterop. BunitJSInteropSetupExtensions Helper methods for creating invocation handlers and adding the to a BunitJSInterop. BunitJSModuleInterop Represents a bUnit JSInterop module. BunitServiceProvider Represents a IServiceProvider and IServiceCollection as a single type used for test purposes. CompareToExtensions Extension methods that allows different rendered fragments to be compared to others or strings. ComponentFactoryCollection Represents a collection of IComponentFactory. ComponentFactoryCollectionExtensions Extension methods for using component doubles. ComponentParameterCollectionBuilder<TComponent> A ComponentParameterCollection builder for a specific TComponent component under test. ElementNotFoundException Represents a failure to find an element in the searched target using a CSS selector. ElementRemovedFromDomException Represents an exception that is thrown when trying to access an element that was previously found in the DOM. EventHandlerDispatchExtensions Input event dispatch helper extension methods. FocusAsyncAssertJSInteropExtensions Extensions methods for verifying FocusAsync(ElementReference) method calls. FocusOnNavigateAssertJSInteropExtensions Extensions methods for verifying FocusOnNavigate focus calls. HtmlEqualException Represents an differences between pieces of markup. InputFileContent Represents a file which can be uploaded. InputFileExtensions Extensions for the InputFile component. JSInvokeCountExpectedException Represents a number of unexpected invocation to a BunitJSInterop. JSRuntimeAssertExtensions Assert extensions for JSRuntimeMock. JSRuntimeInvocationDictionary Represents a dictionary of JSRuntimeInvocation, keyed by their identifier. JSRuntimeInvocationHandler Represents a handler for an invocation of a JavaScript function which returns nothing, with specific arguments. JSRuntimeInvocationHandlerBase<TResult> Represents an invocation handler for JSRuntimeInvocation instances. JSRuntimeInvocationHandler<TResult> Represents a handler for an invocation of a JavaScript function with specific arguments and returns TResult. JSRuntimeInvocationNotSetException Exception used to indicate that an invocation was received by a JSRuntime invocation handler, but the handler was not configured with a result (via SetResult, SetVoidResult, SetCanceled, or SetException). This causes the invocation to hang indefinitely. JSRuntimeUnhandledInvocationException Exception use to indicate that an invocation was received by the BunitJSInterop running in Strict mode, which didn't contain a matching invocation handler. Key Representation of keyboard key that can be argument of keyboard events. MarkupMatchesAssertExtensions Assert helpers for comparing markup. MissingEventHandlerException Represents an exception that is thrown when triggering an event handler failed because it wasn't available on the targeted AngleSharp.Dom.IElement. RenderedComponentExtensions Helper methods for querying IRenderedComponent<TComponent>. RenderedComponentInvokeAsyncExtensions InvokeAsync extensions methods on IRenderedComponent<TComponent>. RenderedComponentRenderExtensions Re-render extension methods, optionally with new parameters, for RenderedComponent<TComponent>. RenderedComponentWaitForHelperExtensions Provides extension methods for waiting on components within a rendered Blazor component. StubComponentFactoryCollectionExtensions Extension methods for using component doubles. TestContext A test context is a factory that makes it possible to create components under tests. TriggerEventDispatchExtensions General event dispatch helper extension methods. Structs JSRuntimeInvocation Represents an invocation of JavaScript via the JSRuntime Mock. Interfaces IComponentFactory Represents a component factory. IRenderedComponent<TComponent> Represents a rendered component. Enums JSRuntimeMode The execution mode of the BunitJSInterop. Delegates InvocationMatcher Represents a invocation matcher / predicate, that is used to determine if a JSRuntimeInvocationHandler<TResult> matches a specific JSRuntimeInvocation."
  },
  "docs/code-of-conduct.html": {
    "href": "docs/code-of-conduct.html",
    "title": "Contributor covenant code of conduct | bUnit",
    "keywords": "Contributor covenant code of conduct Our pledge In the interests of fostering an open and welcoming environment, we as contributors and maintainers pledge to make our project and community a harassment-free experience for everyone, regardless of age, size, disability, ethnicity, sexuality, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, or religion. Our standards Examples of behavior that contribute towards creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned with this Code of Conduct, or to temporarily or permanently ban any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abuse, harassment, or otherwise unacceptable behavior may be reported by contacting the project leader at egil@assimilated.dk. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq"
  },
  "docs/contribute.html": {
    "href": "docs/contribute.html",
    "title": "Contribute | bUnit",
    "keywords": "How to contribute One of the easiest ways to contribute is to participate in discussions on GitHub issues. You can also contribute by submitting pull requests with code changes. General feedback and discussions Start a discussion on the bUnit discussion list. Bugs and feature requests For bugs or feature requests, log a new issue on the issues list. Be sure to use the right template. Contributing code and content bUnit accepts fixes and features. Here is what you should do when writing code for bUnit: Follow the coding conventions used throughout the bUnit project. In general, they align with the AspNetCore teams coding guidelines. Add, remove, or delete unit tests to cover your changes. Make sure tests are specific to the changes you are making. Tests need to be provided for every bug/feature that is completed. This repository follow the truck-based development approach, meaning changes should be based on the main branch Any code or documentation you share with the bUnit projects should fall under the projects license agreement. Here are some resources to help you get started on how to contribute code or new content: \"Help wanted\" issues - these issues are up for grabs if you want to create a fix. To do this, simply comment on the issue you want to fix. \"Good first issue\" issues - these are good for newcomers. Good first issues are small, usually require just a few hours of work, and do not require a deep technical knowledge of bUnit. This is a good place to start if you want to become familiar with bUnits inner workings and maybe take on bigger issues later. Identifying the Scale of a Contribution If you would like to contribute to bUnit, first identify the scale of what you would like to contribute. If it is small (grammar/spelling or a bug fix), feel free to start working on a fix. If you are submitting a feature or substantial code contribution, please discuss it with us first. You might also read these two blogs posts on contributing code: Open Source Contribution Etiquette by Miguel de Icaza and Don't \"Push\" Your Pull Requests by Ilya Grigorik. These blog posts highlight good open source collaboration etiquette and help align expectations between you and us. All code submissions will be reviewed and tested, and only those that meet the expected quality and design/roadmap appropriateness will be merged into the project. Fear not though, you will be given plenty of constructive feedback as needed. Submitting a pull request If you don't know what a pull request is, read this article: https://help.github.com/articles/using-pull-requests. Make sure the repository can build and all tests pass. It is also a good idea to familiarize yourself with the project workflow and our coding conventions. Code of conduct See Contributor covenant code of conduct"
  },
  "docs/extensions/bunit-generators.html": {
    "href": "docs/extensions/bunit-generators.html",
    "title": "bUnit Generators | bUnit",
    "keywords": "bUnit Generators The bunit.generators package contains a set of source generators that can be used to generate code likes stubs for Blazor components. The generators are designed to be used with the bUnit testing framework for Blazor components. To use the generators, you must install the bunit.generators NuGet package in test project. This page will describe the generators and their usage. Component stub generator via AddStub This generator adds the ability to automatically generate stubs for a given type with no setup involved. The generator sits on top of the already present AddStub method. This comes in handy, when dealing with 3rd party components that might need an extensive setup. Here a small example: Given the following component <ThirdPartyText Text=\"@count\" /> <button @onclick=\"IncrementCount\">Increase by one</button> @code { private int count; private void IncrementCount() { count++; } } If ThirdPartyText is a 3rd party component, that needs a lot of setup, it might be easier to just stub it out: [Fact] public void Text_button_gets_initial_count() { // This call will automatically generate a stub for the ThirdPartyButton component // with the name \"ThirdPartyButtonStub\" ComponentFactories.AddStub<ThirdPartyText>(); var cut = Render<Counter>(@<Counter />); cut.Find(\"button\").Click(); // Retrieves the stub from the render tree and checks if the text is \"1\" cut.FindComponent<ThirdPartyTextStub>().Instance.Text.Should().Be(\"1\"); } Setup To use the generator, the Interceptor feature has to be used inside the csproj file: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <!-- This line is required to enable the generator and interceptor --> <InterceptorsPreviewNamespaces>$(InterceptorsPreviewNamespaces);Bunit</InterceptorsPreviewNamespaces> Due to the usage of Interceptors the generator is only available for .NET 8.0 and above. The generator does create a partial class, so it can be extended with custom logic if needed. Component stub generator via ComponentStubAttribute This generator adds the ability to automatically generate stubs for a given type via an attribute. The general setup for the given component above looks like this: namespace MyTest; public class FeatureTests : BunitContext { [Fact] public void Test() { ComponentFactories.Add<ThirdPartyText, ThirdPartyStub>(); ... } } [ComponentStub<ThirdPartyText>] internal partial class ThirdPartyStub { } Current limitations of this approach is that he stubbed type is not allowed to be nested inside the test class. Reported Diagnostics The generators will report a range of diagnostics to help understanding what issue is present. The following table shows the diagnostics that are reported. Diagnostic ID Error Severity Description BUNIT0001 Stubbing nested classes ({0}) is not supported. Warning Types annotated with ComponentStub can not be nested inside another class. BUNIT0002 Class ({0}) is not partial. Warning Types annotated with ComponentStub must be partial."
  },
  "docs/extensions/index.html": {
    "href": "docs/extensions/index.html",
    "title": "Extensions for bUnit | bUnit",
    "keywords": "Extensions for bUnit This section covers the various extensions available for bUnit. These extensions are not part of the core bUnit package, but are instead available as separate NuGet packages. The extensions are listed below, and each has its own documentation page. bunit.generators - A set of source generators that can be used to generate code like stubs for Blazor components"
  },
  "docs/external-resources.html": {
    "href": "docs/external-resources.html",
    "title": "External Resources | bUnit",
    "keywords": "Presentations, guides, articles, tutorials, and blog posts Here is a list of some web content that covers bUnit. If you produce something you think can be useful to bUnit's users, feel free to add it to this page and send a pull request. Podcasts/Twitch/YouTube/Live coding Best practices unit testing Blazor components with bUnit Content is based on 1.3.42 of bUnit. Whats new in bUnit for .NET 6 Content is based on 1.3.42 of bUnit. Test Driving the Blazing Pizza Workshop with bUnit (multiple videos) Content is based on 1.0.0 of bUnit. .NET Rocks! - Testing Blazor Apps with Egil Hansen Content is based on beta-7 of bUnit. CSharpFritz's Twitch Show: Egil Hansen joins us for Blazor Testing and Component Design Content is based on beta-6 of bUnit. Blazor StateHasChanged: Blazor Component Unit Testing with Egil Hansen Content is based on beta-5.1 of bUnit. Presentations Testing Blazor Components - session from .NET Conf - Focus on Blazor Content is based on beta-5.1 of bUnit. Articles and blog posts bUnit for Blazor and How to Integrate it in Azure Pipeline by Ramkumar Shanmugam Content is based on beta-8 of bUnit. Unit Testing Blazor Components with bUnit and JustMock by Mihail Vladov Content is based on beta-6 of bUnit. Books Microsoft Blazor: Building Web Applications in .NET 6 and Beyond Blazor in Action Others bUnit on Stackoverflow"
  },
  "docs/getting-started/create-test-project.html": {
    "href": "docs/getting-started/create-test-project.html",
    "title": "Creating a new bUnit test project | bUnit",
    "keywords": "Creating a new bUnit test project To write tests, you need a place to put them - a test project. bUnit is not a unit test runner, so a general-purpose test framework like xUnit, NUnit, or MSTest is needed in addition to bUnit in order to write and run tests. To use bUnit, the easiest approach is to use the bUnit project template described in the following section. To create a test project manually and in a general-purpose testing frameworks agnostic way, read the section Creating a test project manually section further down the page. Creating a test project with bUnit template To quickly get started with bUnit, install and use the bUnit test project template. The steps for creating a test project with the bUnit template are as follows: Install the template (only needed the first time) Create a new bUnit test project Add the test project to your solution These steps look like this from the dotnet CLI: 1. Install the template Install the template from NuGet using this command: dotnet new install bunit.template 2. Create a new test project If you successfully installed the template listed in the previous section, you can create a new project directly from the \"Create new project\" wizard in Visual Studio (or Rider), where the bUnit project type will also show up. Otherwise, use one of the following command to create a bUnit test project with the framework of your choice: xUnit xUnit v3 NUnit MSTest TUnit dotnet new bunit --framework xunit -o <NAME OF TEST PROJECT> dotnet new bunit --framework xunitv3 -o <NAME OF TEST PROJECT> dotnet new bunit --framework nunit -o <NAME OF TEST PROJECT> dotnet new bunit --framework mstest -o <NAME OF TEST PROJECT> There is no prebuilt template for TUnit. More information on how to set up a TUnit project can be found down below. The --framework option in the dotnet new command above is used to specify the unit testing framework used by the test project. If the --framework option is omitted, the default test framework xunit will be configured. Currently supported options are the following: xunit and xunitv3 - xUnit, nunit - NUnit, mstest - MSTest 3. Add the test project to your solution If using Visual Studio, add the test project to your solution (.sln), and add a reference between the test project and the project containing the components that should be tested: dotnet sln <NAME OF PROJECT>.sln add <NAME OF TEST PROJECT> dotnet add <NAME OF TEST PROJECT>.csproj reference <NAME OF COMPONENT PROJECT>.csproj This will allow the test project to see and test the components in the component project. Creating a test project manually This section will take you through the steps required to create a project for testing Blazor components using bUnit. Any of the three general-purpose test frameworks shown in step 1 below can be used. Briefly, here is what we will do: Create a new xUnit/NUnit/MSTest/TUnit testing project Add bUnit to the test project Configure project settings Add the test project to your existing solution Let's look at these in more detail. These steps look like this from the 'dotnet' CLI: 1. Create a new test project Use the following command (click on the tab for the test framework of choice): xUnit xUnit v3 NUnit MSTest TUnit dotnet new xunit -o <NAME OF TEST PROJECT> dotnet new xunit3 -o <NAME OF TEST PROJECT> dotnet new nunit -o <NAME OF TEST PROJECT> dotnet new mstest -o <NAME OF TEST PROJECT> dotnet new TUnit -o <NAME OF TEST PROJECT> The -o option in the dotnet new command above is used to specify the name of the test project. 2. Add bUnit to the test project To add bUnit to the test project, change to the newly created test projects folder and use the following command: cd <NAME OF PROJECT> dotnet add package bunit --version 2.6.2 3. Configure project settings The test projects setting needs to be set to the following: the project's SDK needs to be set to Microsoft.NET.Sdk.Razor (this does not work with TUnit - a more detailed explanation can be found below) set the <TargetFramework> to net8.0 Note bUnit works with net8.0 and above as well. To do so, change the first part of the test projects .csproj file to look like this.: <Project Sdk=\"Microsoft.NET.Sdk.Razor\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> </PropertyGroup> ... </Project> 4. Add the test project to your solution If using Visual Studio, add the test project to your solution (.sln), and add a reference between the test project and the project containing the components that are to be tested: dotnet sln <NAME OF PROJECT>.sln add <NAME OF TEST PROJECT> dotnet add <NAME OF TEST PROJECT>.csproj reference <NAME OF COMPONENT PROJECT>.csproj The result should be a test project with a .csproj that looks like this (non bUnit packages may have different version numbers): xUnit xUnit v3 NUnit MSTest TUnit <Project Sdk=\"Microsoft.NET.Sdk.Razor\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <Nullable>enable</Nullable> <IsPackable>false</IsPackable> </PropertyGroup> <ItemGroup> <PackageReference Include=\"bunit\" Version=\"2.5.3\" /> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.12.0\" /> <PackageReference Include=\"xunit\" Version=\"2.9.4\" /> <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"3.0.1\"> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> <PrivateAssets>all</PrivateAssets> </PackageReference> <PackageReference Include=\"coverlet.collector\" Version=\"6.0.4\" /> </ItemGroup> <ItemGroup> <ProjectReference Include=\"<PATH TO COMPONENT LIB>.csproj\" /> </ItemGroup> </Project> <Project Sdk=\"Microsoft.NET.Sdk.Razor\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <Nullable>enable</Nullable> <IsPackable>false</IsPackable> <OutputType>Exe</OutputType> </PropertyGroup> <ItemGroup> <PackageReference Include=\"bunit\" Version=\"2.5.3\" /> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.12.0\" /> <PackageReference Include=\"xunit.v3\" Version=\"1.0.1\" /> <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"3.0.1\"> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> <PrivateAssets>all</PrivateAssets> </PackageReference> <PackageReference Include=\"coverlet.collector\" Version=\"6.0.4\" /> </ItemGroup> <ItemGroup> <ProjectReference Include=\"<PATH TO COMPONENT LIB>.csproj\" /> </ItemGroup> </Project> <Project Sdk=\"Microsoft.NET.Sdk.Razor\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <Nullable>enable</Nullable> <IsPackable>false</IsPackable> </PropertyGroup> <ItemGroup> <PackageReference Include=\"bunit\" Version=\"2.5.3\" /> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.12.0\" /> <PackageReference Include=\"NUnit\" Version=\"4.3.2\" /> <PackageReference Include=\"NUnit3TestAdapter\" Version=\"4.6.0\" /> <PackageReference Include=\"coverlet.collector\" Version=\"6.0.4\" /> </ItemGroup> <ItemGroup> <ProjectReference Include=\"<PATH TO COMPONENT LIB>.csproj\" /> </ItemGroup> </Project> <Project Sdk=\"Microsoft.NET.Sdk.Razor\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <Nullable>enable</Nullable> <IsPackable>false</IsPackable> </PropertyGroup> <ItemGroup> <PackageReference Include=\"bunit\" Version=\"2.5.3\" /> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.12.0\" /> <PackageReference Include=\"MSTest.TestAdapter\" Version=\"3.7.1\" /> <PackageReference Include=\"MSTest.TestFramework\" Version=\"3.7.1\" /> <PackageReference Include=\"coverlet.collector\" Version=\"6.0.4\" /> </ItemGroup> <ItemGroup> <ProjectReference Include=\"<PATH TO COMPONENT LIB>.csproj\" /> </ItemGroup> </Project> <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <Nullable>enable</Nullable> <IsPackable>false</IsPackable> <IsTestingPlatformApplication>false</IsTestingPlatformApplication> </PropertyGroup> <ItemGroup> <PackageReference Include=\"bunit\" Version=\"2.5.3\" /> <PackageReference Include=\"TUnit\" Version=\"0.6.154\" /> <PackageReference Include=\"coverlet.collector\" Version=\"6.0.4\" /> </ItemGroup> <ItemGroup> <ProjectReference Include=\"<PATH TO COMPONENT LIB>.csproj\" /> </ItemGroup> </Project> Warning TUnit and the Microsoft.NET.Sdk.Razor both utilize source code generators. Source generators can not see or interact with the output of another generator. Therefore TUnit does not work with razor files. Using cs based tests is working perfectly fine. For more information regarding the setup of TUnit head over to: https://github.com/thomhurst/TUnit Further reading To start creating tests, continue reading the Writing tests for Blazor components page."
  },
  "docs/getting-started/index.html": {
    "href": "docs/getting-started/index.html",
    "title": "Getting started with bUnit | bUnit",
    "keywords": "Getting started with bUnit To start writing tests for Blazor components, first set up a test project and then you can start adding tests. The basic getting started topics are as follows: Creating a new bUnit test project covers setting up a bUnit test project. Writing tests for Blazor components covers the basics of writing tests for Blazor components. The next level topics are: Providing different types of input to a component under test, e.g. passing parameters or injecting services. Verifying output in various ways from a component under test, e.g. inspecting the rendered markup. Mocking dependencies a component under test has, e.g. the IJsRuntime or HttpClient. Introduction video This video gives an introduction to bUnit, what it is, why its needed, and how to use it. It covers different testing strategies, and how to build maintainable test and maintainable components. Getting help Can't figure out how to write a test for a testing scenario? Do you have a testing scenario that is hard to write or cannot be written elegantly with bUnit? Have you found a bug in bUnit? Head over to bUnits discussion forum to ask a question, give feedback, or suggest a new feature. Alternatively, join bUnits Gitter channel and let us know. There are no stupid questions - all are welcome!"
  },
  "docs/getting-started/writing-tests.html": {
    "href": "docs/getting-started/writing-tests.html",
    "title": "Writing tests for Blazor components | bUnit",
    "keywords": "Writing tests for Blazor components Testing Blazor components is a little different from testing regular C# classes: Blazor components are rendered, they have the Blazor component life cycle during which we can provide input to them, and they can produce output. Use bUnit to render the component under test, pass in its parameters, inject required services, and access the rendered component instance and the markup it has produced. Rendering a component happens through bUnit's BunitContext. The result of the rendering is an RenderedComponent, referred to as a \"rendered component\", that provides access to the component instance and the markup produced by the component. Write tests in .cs or .razor files bUnit works with MSTest, NUnit, and xUnit, and it allows you to write the unit tests in either .cs or .razor files. The latter, writing tests in .razor files, provides an easier way to declare component markup and HTML markup in the tests, so it will most likely be the go-to for many people in the future. However, the current Razor editor in Visual Studio 2022 does not offer all the code editing features available in the C# editor, so that is something to consider if you choose to write tests in .razor files. The following sections show how to get started writing tests in either .cs or .razor files. Creating basic tests in .razor files Before writing tests in .razor files, a few things needs to be in place: Make sure the test project has the SDK type set to Microsoft.NET.Sdk.Razor. Otherwise the Blazor compiler will not translate your .razor files into runnable code. Add an _Imports.razor file to the test project. It serves the same purpose as _Imports.razor files in regular Blazor projects. These using statements are useful to add right away: @using Microsoft.AspNetCore.Components.Forms @using Microsoft.AspNetCore.Components.Web @using Microsoft.JSInterop @using Microsoft.Extensions.DependencyInjection @using AngleSharp.Dom @using Bunit @using Bunit.TestDoubles Also add an using statement for your general purpose testing framework, e.g. @using Xunit for xUnit. With that in place, lets look at a simple example that tests the following <HelloWorld> component: <h1>Hello world from Blazor</h1> xUnit NUnit MSTest @inherits BunitContext @code { [Fact] public void HelloWorldComponentRendersCorrectly() { // Act var cut = Render(@<HelloWorld/>); // Assert cut.MarkupMatches(@<h1>Hello world from Blazor</h1>); } } The test above does the following: Inherits from the bUnit BunitContext. This base class offers the majority of functions. Renders the <HelloWorld> component using BunitContext, which is done through the Render(RenderFragment) method. We cover passing parameters to components on the Passing parameters to components page. Verifies the rendered markup from the <HelloWorld> component using the MarkupMatches method. The MarkupMatches method performs a semantic comparison of the expected markup with the rendered markup. @inherits BunitContext @code { [Test] public void HelloWorldComponentRendersCorrectly() { // Act var cut = Render(@<HelloWorld />); // Assert cut.MarkupMatches(@<h1>Hello world from Blazor</h1>); } } Use the LifeCycle.InstancePerTestCase attribute (introduced in NUnit 3.13) so that a new instance of the test class is created for each test removing the need for the wrapper. [FixtureLifeCycle(LifeCycle.InstancePerTestCase)] public class HelloWorldInstancePerTestCase : Bunit.BunitContext { [Test] public void HelloWorldComponentRendersCorrectly() { // Act var cut = Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } @attribute [TestClass] @inherits BunitContext @code { [TestMethod] public void HelloWorldComponentRendersCorrectly() { // Act var cut = Render(@<HelloWorld/>); // Assert cut.MarkupMatches(@<h1>Hello world from Blazor</h1>); } } Tip Learn more about how the semantic HTML/markup comparison in bUnit works, and how to customize it, on the Customizing the semantic HTML comparison page. Tip In bUnit tests, we like to use the abbreviation CUT, short for \"component under test\", to indicate the component that is being tested. This is inspired by the common testing abbreviation SUT, short for \"system under test\". Secret sauce of '.razor' files tests The trick employed in these tests is the \"inline Razor templates syntax\", i.e. where a render fragment is simply created using the @<{HTML tag}>...</{HTML tag}> notation. In that notation there is no need to do any escaping of e.g. the quotation mark (\"), that is usually associated with working with markup in C# code. One small caveat to be aware of is that the inline Razor templates syntax only supports one outer element, e.g. this is OK: @<Foo> <Bar> <Baz>...</Baz> </Bar> </Foo> However, this will not work: @<Foo></Foo> <Bar></Bar> There is a simple workaround though: wrap all elements in the special Blazor element <text>. The <text> element will not be part of the rendered output, but it provides a simple way to group multiple root elements into a single inline Razor template. E.g.: @<text> <Foo></Foo> <Bar></Bar> </text> Creating basic tests in .cs files This is a simple example of writing tests in .cs files which tests the following <HelloWorld> component: <h1>Hello world from Blazor</h1> xUnit NUnit MSTest using Xunit; using Bunit; public class HelloWorldTest : BunitContext { [Fact] public void HelloWorldComponentRendersCorrectly() { // Act var cut = Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } The test above does the following: Inherits from the bUnit's BunitContext. This base class offers the majority of functions. Renders the <HelloWorld> component using BunitContext, which is done through the Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) method. We cover passing parameters to components on the Passing parameters to components page. Verifies the rendered markup from the <HelloWorld> component using the MarkupMatches method. The MarkupMatches method performs a semantic comparison of the expected markup with the rendered markup. using Bunit; using NUnit.Framework; public class HelloWorldTest : BunitContext { [Test] public void HelloWorldComponentRendersCorrectly() { // Act var cut = Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } The test above does the following: Inherits from the BunitContext listed above. This base class offers the majority of functions. Renders the <HelloWorld> component using BunitContext, which is done through the Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) method. We cover passing parameters to components on the Passing parameters to components page. Verifies the rendered markup from the <HelloWorld> component using the MarkupMatches method. The MarkupMatches method performs a semantic comparison of the expected markup with the rendered markup. Alternatively, use the LifeCycle.InstancePerTestCase attribute (introduced in NUnit 3.13) so that a new instance of the test class is created for each test removing the need for the wrapper. using NUnit.Framework; namespace Bunit.Docs.Samples; [FixtureLifeCycle(LifeCycle.InstancePerTestCase)] public class HelloWorldInstancePerTestCase : Bunit.BunitContext { [Test] public void HelloWorldComponentRendersCorrectly() { // Act var cut = Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } using Microsoft.VisualStudio.TestTools.UnitTesting; using Bunit; [TestClass] public class HelloWorldTest : BunitContext { [TestMethod] public void HelloWorldComponentRendersCorrectly() { // Act var cut = Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } The test above does the following: Inherits from the BunitContext listed above. This base class offers the majority of functions. Renders the <HelloWorld> component using BunitContext, which is done through the Render<TComponent>(Action<ComponentParameterCollectionBuilder<TComponent>>?) method. We cover passing parameters to components on the Passing parameters to components page. Verifies the rendered markup from the <HelloWorld> component using the MarkupMatches method. The MarkupMatches method performs a semantic comparison of the expected markup with the rendered markup. Tip Learn more about how the semantic HTML/markup comparison in bUnit works, and how to customize it, on the Customizing the semantic HTML comparison page. Tip In bUnit tests, we like to use the abbreviation CUT, short for \"component under test\", to indicate the component that is being tested. This is inspired by the common testing abbreviation SUT, short for \"system under test\". Instantiate BunitContext in each test If you prefer to instantiate BunitContext in each test, instead of inheriting from it, you can do so. This can be useful if you have your own base class that you want to inherit from, or if you want to use a different test framework than the ones listed here. Just be aware that all examples in the rest of the documentation assumes that you are inheriting from BunitContext, so adjust accordingly. xUnit NUnit MSTest public class HelloWorldExplicitContext { [Fact] public void HelloWorldComponentRendersCorrectly() { // Arrange using var ctx = new BunitContext(); // Act var cut = ctx.Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } public class HelloWorldExplicitContext { [Test] public void HelloWorldComponentRendersCorrectly() { // Arrange using var ctx = new Bunit.BunitContext(); // Act var cut = ctx.Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } [TestClass] public class HelloWorldExplicitContext { [TestMethod] public void HelloWorldComponentRendersCorrectly() { // Arrange using var ctx = new Bunit.BunitContext(); // Act var cut = ctx.Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } Further reading With the basics out of the way, next we will look at how to pass parameters and inject services into our component under test. After that, we will cover the ways in which we can verify the outcome of a rendering in more detail Passing parameters to components Injecting services into components under test Verifying markup from a component Verifying the state of a component under test Triggering event handlers in components"
  },
  "docs/interaction/awaiting-async-state.html": {
    "href": "docs/interaction/awaiting-async-state.html",
    "title": "Awaiting an asynchronous state change in a component under test | bUnit",
    "keywords": "Awaiting an asynchronous state change A test can fail if a component performs asynchronous renders. This may be due to a reason such as waiting for an asynchronous operation to complete before continuing its render life-cycle. For example, if a component is waiting for an async web service to return data to it in the OnInitializedAsync() life-cycle method before rendering it to the render tree. You need to handle this specifically in your tests because tests execute in the test framework's synchronization context and the test renderer executes renders in its own synchronization context. If you do not, you will likely experience tests that sometimes pass and sometimes fail. bUnit comes with several methods that help to deal with this issue: the WaitForState() method, the WaitForAssertion() method covered on the Assertion of asynchronous changes page, and the component-specific waiting methods WaitForComponent() and WaitForComponents() that are covered later on this page. Let's start by taking a look at the WaitForState method in more detail. Waiting for state using WaitForState The WaitForState(Func<Boolean>, TimeSpan?) method can be used to block and wait in a test method, until the provided predicate returns true or the timeout is reached. (The default timeout is one second.) Note The WaitForState() method will try the predicate passed to it when the WaitForState() method is called, and every time the component under test renders. Let us look at an example. Consider the following <AsyncData> component which awaits an async TextService in its OnInitializedAsync() life-cycle method. When the service returns the data, the component will automatically re-render to update its rendered markup: <p>@text</p> @code { string text = string.Empty; [Parameter] public Task<string> TextService { get; set; } protected override async Task OnInitializedAsync() { text = await TextService; } } To test the <AsyncData> component, do the following: var textService = new TaskCompletionSource<string>(); var cut = Render<AsyncData>(parameters => parameters .Add(p => p.TextService, textService.Task) ); // Act - set the awaited result from the text service textService.SetResult(\"Hello World\"); // Wait for state before continuing test cut.WaitForState(() => cut.Find(\"p\").TextContent == \"Hello World\"); // Assert - verify result has been set cut.MarkupMatches(\"<p>Hello World</p>\"); This is what happens in the test: The test uses a TaskCompletionSource<string> to simulate an async web service. In the second highlighted line, the result is provided to the component through the textService. This causes the component to re-render. In the third highlighted line, the WaitForState() method is used to block the test until the predicate provided to it returns true. Finally, the tests assertion step can execute, knowing that the desired state has been reached. Warning The wait predicate and an assertion should not verify the same thing. Instead, use the WaitForAssertion(...) method covered on the Assertion of asynchronous changes page instead. Controlling wait timeout The timeout, which defaults to one second, can be controlled by passing a TimeSpan as the second argument to the WaitForState() method, e.g.: cut.WaitForState(() => cut.Find(\"p\").TextContent == \"Long time\", TimeSpan.FromSeconds(2)); If the timeout is reached, a WaitForFailedException exception is thrown with the following error message: The state predicate did not pass before the timeout period passed. Waiting for components using WaitForComponent and WaitForComponents bUnit provides specialized methods for waiting for child components to appear in the render tree. These methods are useful when testing scenarios where components are rendered asynchronously based on some state change or data loading. Waiting for a single component The WaitForComponent<TComponent>(TimeSpan?) method waits until the specified component type is rendered in the DOM and returns the first instance found. Consider the following <AsyncComponentLoader> component that loads child components asynchronously: @if (isLoading) { <p>Loading...</p> } else { @foreach (var item in Items) { <ListItem Value=\"@item\" /> } } @code { [Parameter] public List<string> Items { get; set; } = new(); private bool isLoading = true; protected override async Task OnInitializedAsync() { // Simulate async loading await Task.Delay(100); isLoading = false; } } To test that the <ListItem> components are rendered correctly, the WaitForComponent<TComponent>() method can be used: var cut = Render<AsyncComponentLoader>(parameters => parameters .Add(p => p.Items, [\"Item 1\"])); var listItem = cut.WaitForComponent<ListItem>(); Assert.Equal(\"Item 1\", listItem.Find(\".list-item\").TextContent); Waiting for multiple components The WaitForComponents<TComponent>(TimeSpan?) method waits until at least one instance of the specified component type is rendered in the DOM and returns all instances found: var items = new List<string> { \"Item 1\", \"Item 2\", \"Item 3\" }; var cut = Render<AsyncComponentLoader>(parameters => parameters .Add(p => p.Items, items)); var listItems = cut.WaitForComponents<ListItem>(); Assert.Equal(3, listItems.Count); Assert.Equal(\"Item 1\", listItems.ElementAt(0).Find(\".list-item\").TextContent); Assert.Equal(\"Item 2\", listItems.ElementAt(1).Find(\".list-item\").TextContent); Waiting for a specific number of components The WaitForComponents<TComponent>(int, TimeSpan?) overload waits until at least the specified number of component instances are rendered: var items = new List<string> { \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\" }; var cut = Render<AsyncComponentLoader>(parameters => parameters .Add(p => p.Items, items)); var listItems = cut.WaitForComponents<ListItem>(5); Assert.Equal(5, listItems.Count); Note This method waits for at least the specified number of components, not exactly that number. If more components are rendered than requested, the method will still succeed and return all found instances. Note These component wait methods use the same underlying mechanism as WaitForState() and will retry their checks every time the component under test renders. If the timeout is reached, a WaitForFailedException exception is thrown with an appropriate error message indicating that the expected component(s) were not found within the timeout period. Debugging code that uses WaitForState, WaitForAssertion, WaitForComponent, WaitForComponents, or WaitForElement When bUnit detects that a debugger is attached (Debugger.IsAttached), it will automatically disable the timeout functionality of the \"wait for\" methods."
  },
  "docs/interaction/dispose-components.html": {
    "href": "docs/interaction/dispose-components.html",
    "title": "Disposing components and their children | bUnit",
    "keywords": "Disposing components To dispose all components rendered with a BunitContext, use the DisposeComponents method. Calling this method will dispose all rendered components, calling any IDisposable.Dispose or/and IAsyncDisposable.DisposeAsync methods they might have, and remove the components from the render tree, starting with the root components and then walking down the render tree to all the child components. Disposing rendered components enables testing of logic in Dispose methods, e.g., event handlers, that should be detached to avoid memory leaks. The following example of this: var calledTimes = 0; var cut = Render<DisposableComponent>(parameters => parameters .Add(p => p.LocationChangedCallback, url => calledTimes++) ); await DisposeComponentsAsync(); Services.GetRequiredService<NavigationManager>().NavigateTo(\"newurl\"); Assert.Equal(0, calledTimes); Warning For IAsyncDisposable (since .net5) relying on WaitForState() or WaitForAssertion() will not work as a disposed component will not trigger a new render cycle. Disposing components asynchronously If a component implements IAsyncDisposable, DisposeComponentsAsync can be awaited to wait for all asynchronous DisposeAsync methods. Sometimes interacting with JavaScript in Blazor WebAssembly requires disposing or resetting state in DisposeAsync. JSInterop.SetupVoid(\"dispose\").SetVoidResult(); Render<AsyncDisposableComponent>(); await DisposeComponentsAsync(); JSInterop.VerifyInvoke(\"dispose\"); To omit this behavior, discard the returned task _ = DisposeComponentsAsync(); Checking for exceptions Both Dispose and DisposeAsync can throw exceptions, which can be asserted during tests. When a component under test throws an exception in either Dispose or DisposeAsync, the exception is caught by the renderer and made available via the Renderer.UnhandledException task. The DisposeComponentsAsync method itself will not throw the exception. This allows for consistent testing of exceptions during disposal, regardless of whether the disposal is synchronous or asynchronous. The following examples demonstrate how to assert that an exception was thrown during disposal: Asserting exception in Dispose: [Fact] public async Task ShouldCatchExceptionInDispose() { Render<ExceptionInDisposeComponent>(); await DisposeComponentsAsync(); var exception = await Renderer.UnhandledException; Assert.IsType<NotSupportedException>(exception); Asserting exception in DisposeAsync: [Fact] public async Task ShouldCatchExceptionInDisposeAsync() { Render<ExceptionInDisposeAsyncComponent>(); await DisposeComponentsAsync(); var exception = await Renderer.UnhandledException; Assert.IsType<NotSupportedException>(exception);"
  },
  "docs/interaction/index.html": {
    "href": "docs/interaction/index.html",
    "title": "Interacting with a component under test | bUnit",
    "keywords": "Interacting with a component under test This section covers the various ways to interact with a component under test, e.g. trigger event handlers. This  and more  is covered in the following sub sections: Triggering event handlers in components: This covers how to invoke event handlers bound to elements rendered by a component under test. Triggering a render life cycle on a component: This covers how to manually trigger a render cycle for a component under test. Awaiting an asynchronous state change in a component under test: This covers how to await one or more asynchronous changes to the state of a component under test before continuing the test. Disposing components and their children: This covers how to dispose components and their children. Render modes and RendererInfo: This covers the different render modes and their interaction with bUnit."
  },
  "docs/interaction/render-modes.html": {
    "href": "docs/interaction/render-modes.html",
    "title": "Render modes and RendererInfo | bUnit",
    "keywords": "Support for render modes and RendererInfo This article explains how to emulate different render modes and RendererInfo in bUnit tests. Render modes in Blazor Web Apps determine the hosting model and interactivity of components. A render mode can be applied to a component using the @rendermode directive. The RendererInfo allows the application to determine the interactivity and location of the component. For more details, see the Blazor render modes documentation. Setting the render mode for a component under test Setting the render mode can be done via the SetAssignedRenderMode(IComponentRenderMode?) method when writing in a C# file. In a razor file use the @rendermode directive. Both take an IComponentRenderMode object as a parameter. Normally this is one of the following types: InteractiveAutoRenderMode InteractiveServerRendeMode InteractiveWebAssemblyRenderMode For ease of use the RenderMode class defines all three of them. For example MovieComponent.razor: @if (AssignedRenderMode is null) { // The render mode is Static Server <form action=\"/movies\"> <input type=\"text\" name=\"titleFilter\" /> <input type=\"submit\" value=\"Search\" /> </form> } else { // The render mode is Interactive Server, WebAssembly, or Auto <input @bind=\"titleFilter\" /> <button @onclick=\"FilterMovies\">Search</button> } The following example shows how to test the above component to check both render modes: C# test code Razor test code [Fact] public void InteractiveServer() { // Act var cut = RenderComponent<MovieComponent>(ps => ps .SetAssignedRenderMode(RenderMode.InteractiveServer)); // Assert cut.MarkupMatches(\"\"\" <input diff:ignoreAttributes /> <button>Search</button> \"\"\"); } [Fact] public void StaticRendering() { // Act var cut = RenderComponent<MovieComponent>(); // This is the same behavior as: // var cut = RenderComponent<MovieComponent>(ps => ps // .SetAssignedRenderMode(null)); // Assert cut.MarkupMatches(\"\"\" <form action=\"/movies\"> <input type=\"text\" name=\"titleFilter\" /> <input type=\"submit\" value=\"Search\" /> </form> \"\"\"); } @inherits TestContext @code { [Fact] public void InteractiveServer() { // Act var cut = Render(@<MovieComponent @rendermode=\"RenderMode.InteractiveServer\" />); // Assert cut.MarkupMatches(@<text> <input diff:ignoreAttributes /> <button>Search</button> </text>); } [Fact] public void StaticRendering() { // Act var cut = Render(@<MovieComponent />); // Assert cut.MarkupMatches(@<form action=\"/movies\"> <input type=\"text\" name=\"titleFilter\" /> <input type=\"submit\" value=\"Search\" /> </form>); } } Setting the RendererInfo during testing To control the ComponentBase.RendererInfo property during testing, use the SetRendererInfo(RendererInfo?) method on the TestContext class. The SetRendererInfo method takes an nullable RendererInfo object as a parameter. Passing null will set the ComponentBase.RendererInfo to null. A component (AssistentComponent.razor) might check if interactivity is given to enable a button: @if (RendererInfo.IsInteractive) { <p>Hey I am your assistant</p> } else { <p>Loading...</p> } In the test, you can set the RendererInfo to enable or disable the button: [Fact] public void SimulatingPreRenderingOnBlazorServer() { // Arrange SetRendererInfo(new RendererInfo(rendererName: \"Static\", isInteractive: false)); // Act var cut = RenderComponent<AssistentComponent>(); // Assert cut.MarkupMatches(\"<p>Loading...</p>\"); } [Fact] public void SimulatingInteractiveServerRendering() { // Arrange SetRendererInfo(new RendererInfo(rendererMode: \"Server\", isInteractive: true)); // Act var cut = RenderComponent<AssistentComponent>(); // Assert cut.MarkupMatches(\"<p>Hey I am your assistant</p>\"); } Note If a component under test uses the ComponentBase.RendererInfo property and the SetRendererInfo on TestContext hasn't been passed in a RendererInfo object, the renderer will throw an exception."
  },
  "docs/interaction/trigger-event-handlers.html": {
    "href": "docs/interaction/trigger-event-handlers.html",
    "title": "Triggering event handlers in components | bUnit",
    "keywords": "Triggering event handlers in components Blazor makes it possible to bind many event handlers to elements in a Blazor component using the @onXXXX syntax, e.g. @onclick=\"MyClickHandler\". bUnit comes with event dispatch helper methods that makes it possible to invoke event handlers for all event types supported by Blazor. The built-in dispatch event helpers are: here. To use these, first find the element in the component under test where the event handler is bound. This is usually done with the Find(string cssSelector) method. Next, invoke the event dispatch helper method of choice. The following section demonstrates how to do this... Invoking an event handler on an element To invoke an event handler on an element, first find the element in the component under test, and then call the desired event dispatch helper method. Let's look at a common example where an @onclick event handler is invoked. The example will use the <ClickMe> component listed here: <button @onclick=\"ClickHandler\">Click ME!</button> @code { void ClickHandler(MouseEventArgs args) { // ... } } To trigger the @onclick ClickHandler event handler method in the <ClickMe> component, do the following: C# test code Razor test code public class ClickMeTest : BunitContext { [Fact] public void Test() { // Arrange var cut = Render<ClickMe>(); var buttonElement = cut.Find(\"button\"); // Act buttonElement.Click(); buttonElement.Click(new MouseEventArgs { Detail = 3, CtrlKey = true }); buttonElement.Click(new MouseEventArgs()); // Assert // ... } } @inherits BunitContext @code { [Fact] public void Test() { // Arrange var cut = Render(@<ClickMe />); var buttonElement = cut.Find(\"button\"); // Act buttonElement.Click(); buttonElement.Click(new MouseEventArgs { Detail = 3, CtrlKey = true }); buttonElement.Click(new MouseEventArgs()); // Assert // ... } } This is what happens in the test: In the arrange step of the test, the <ClickMe> component is rendered and the <button> element is found using the Find(string cssSelector) method. The act step of the test is the <button>'s click event handler. In this case, the ClickHandler event handler method is invoked by calling the Click extension method on the found <button> element. The method takes an optional MouseEventArgs argument, which, if not supplied, will be initialized with default values. All the event dispatch helper methods have the same two overloads: one that takes a number of optional arguments, and one that takes one of the EventArgs types provided by Blazor. Triggering custom events bUnit support triggering custom events through the TriggerEvent method. Lets try to test the <CustomPasteSample> component below: <p>Try pasting into the following text box:</p> <input @oncustompaste=\"HandleCustomPaste\" /> <p>@message</p> @code { string message = string.Empty; void HandleCustomPaste(CustomPasteEventArgs eventArgs) { message = $\"You pasted: {eventArgs.PastedData}\"; } } Here are the custom event types: [EventHandler(\"oncustompaste\", typeof(CustomPasteEventArgs), enableStopPropagation: true, enablePreventDefault: true)] public static class EventHandlers { // This static class doesn't need to contain any members. It's just a place where we can put // [EventHandler] attributes to configure event types on the Razor compiler. This affects the // compiler output as well as code completions in the editor. } public class CustomPasteEventArgs : EventArgs { // Data for these properties will be supplied by custom JavaScript logic public DateTime EventTimestamp { get; set; } public string PastedData { get; set; } } To trigger the @oncustompaste event callback, do the following: // Arrange var cut = Render<CustomPasteSample>(); // Atc - find the input element and trigger the oncustompaste event cut.Find(\"input\").TriggerEvent(\"oncustompaste\", new CustomPasteEventArgs { EventTimestamp = DateTime.Now, PastedData = \"FOO\" }); // Assert that the custom event data was passed correctly cut.Find(\"p:last-child\").MarkupMatches(\"<p>You pasted: FOO</p>\"); Using the Async version All event dispatch helper methods have an Async version that returns a Task. Important to note is that the Async version will await the event handler callback but not the rendercycle that may be triggered by the event handler. Example: await cut.Find(\"button\").ClickAsync();"
  },
  "docs/interaction/trigger-renders.html": {
    "href": "docs/interaction/trigger-renders.html",
    "title": "Triggering a render life cycle on a component | bUnit",
    "keywords": "Triggering a render life cycle on a component To trigger a re-render of a component under test, a reference to it through a IRenderedComponent<TComponent> type is needed. When using the BunitContext's Render<TComponent>() method, this is the type returned. In .razor based tests, using the BunitContext's Render(RenderFragment) method also returns an IRenderedComponent<TComponent> (as opposed to the Render(RenderFragment) method which returns the more simple IRenderedComponent<TComponent>). If you have a IRenderedComponent<TComponent> in a test, but need a child component's IRenderedComponent<TComponent>, then use the FindComponent<TComponent>() or the FindComponents<TComponent>() methods, which traverse down the render tree and finds rendered components. With a IRenderedComponent<TComponent>, it is possible to cause the component to render again directly through the Render() method or one of the Render() methods, or indirectly through the InvokeAsync() method. Let's look at how to use each of these methods to cause a re-render. Render The Render() method tells the renderer to re-render the component, i.e. go through its life-cycle methods (except for OnInitialized() and OnInitializedAsync() methods). To use it, do the following: var cut = Render<Heading>(); Assert.Equal(1, cut.RenderCount); // Re-render without new parameters cut.Render(); Assert.Equal(2, cut.RenderCount); The highlighted line shows the call to Render(). Tip The number of renders a component has been through can be inspected and verified using the RenderCount property. Render The Render(...) methods tells the renderer to re-render the component with new parameters, i.e. go through its life-cycle methods (except for OnInitialized() and OnInitializedAsync() methods), passing the new parameters  but only the new parameters  to the SetParametersAsync() method. To use it, do the following: var cut = Render<Item>(parameters => parameters .Add(p => p.Value, \"Foo\") ); cut.MarkupMatches(\"<span>Foo</span>\"); // Re-render with new parameters cut.Render(parameters => parameters .Add(p => p.Value, \"Bar\") ); cut.MarkupMatches(\"<span>Bar</span>\"); The highlighted line shows the call to Render(), which is also available as a version that takes the zero or more component parameters, e.g. created through the component parameter factory helper methods, if you prefer that method of passing parameters. Note Passing parameters to components through the Render(...) methods is identical to doing it with the Render<TComponent>(...) methods, described in detail on the Passing parameters to components page. InvokeAsync Invoking methods on a component under test, which causes a render, e.g. by calling StateHasChanged, can result in the following error, if the caller is running on another thread than the renderer's thread: The current thread is not associated with the Dispatcher. Use InvokeAsync() to switch execution to the Dispatcher when triggering rendering or component state. If you receive this error, you need to invoke your method inside an Action delegate passed to the InvokeAsync() method. Lets look at an example of this, using the <Calc> component listed below: <output>@result</output> @code { int result = 0; public void Calculate(int x, int y) { result = x + y; StateHasChanged(); } } To invoke the Calculate() method on the component instance, do the following: var cut = Render<Calc>(); // Indirectly re-renders through the call to StateHasChanged // in the Calculate(x, y) method. cut.InvokeAsync(() => cut.Instance.Calculate(1, 2)); cut.MarkupMatches(\"<output>3</output>\"); The highlighted line shows the call to InvokeAsync(), which is passed an Action delegate that calls the Calculate method. Tip The instance of a component under test is available through the Instance property. Advanced use cases In some scenarios, the method being invoked may also return a value, as demonstrated in the following example. <output>@result</output> @code { int result = 0; public int Calculate(int x, int y) { result = x + y; StateHasChanged(); return result; } } Testing this scenario follows the same procedure as before, with the addition of using the return value from InvokeAsync(): var cut = Render<CalcWithReturnValue>(); // Indirectly re-renders and returns a value. var result = await cut.InvokeAsync(() => cut.Instance.Calculate(1, 2)); Assert.Equal(3, result); cut.MarkupMatches(\"<output>3</output>\"); This can also be used to assert intermediate states during an asynchronous operation, like the example below: <output>@(result is null ? \"Loading\" : result.ToString())</output> @code { int? result = 0; public async Task Calculate(int x, int y) { result = null; StateHasChanged(); // Simulate an asynchronous operation, like fetching data. await Task.Delay(500); result = x + y; StateHasChanged(); } } // Arrange - renders the CalcWithLoading component var cut = Render<CalcWithLoading>(); // Indirectly re-renders and returns the task returned by Calculate(). // The explicit <Task> here is important, otherwise the call to Calculate() // will be awaited automatically. var task = await cut.InvokeAsync<CalcWithLoading, Task>(() => cut.Instance.Calculate(1, 2)); cut.MarkupMatches(\"<output>Loading</output>\"); // Wait for the task to complete. await task; cut.WaitForAssertion(() => cut.MarkupMatches(\"<output>3</output>\"));"
  },
  "docs/migrations/1to2.html": {
    "href": "docs/migrations/1to2.html",
    "title": "Migrating from 1.x to 2.x | bUnit",
    "keywords": "Migrating from bUnit 1.x to 2.x This document describes the changes made in bUnit 2.x that may affect existing tests written for bUnit 1.x. The old documentation for bUnit 1.x is available at: https://v1.bunit.dev. One package to rule them all bunit.core and bunit.web have be merged into a single package called bunit. The seperation was used to allow for extensibitlity, which isn't used anymore. Therefore bunit.core and bunit.web will stay on version 1.x, while bunit will be the only package going forward. To migrate, simply remove the bunit.core and bunit.web packages and add the bunit package. We don't expect many users to have used the bunit.core or bunit.web package directly, but may hit 3rd party packages that depend on them. TestContext renamed to BunitContext The TestContext class has been renamed to BunitContext. To migrate tests, rename all instances of TestContext to BunitContext: - public class MyTestClass : TestContext + public class MyTestClass : BunitContext BunitContext offers Dispose and DisposeAsync methods In version 1, the TestContext class only implemented IDisposable, but in version 2, it also implements IAsyncDisposable. Therefore, if there are asynchronous disposable inside the container for example, the asynchronous version should be used. The Fake prefix was renamed to Bunit (e.g. FakeNavigationManager to BunitNavigationManager) The Fake prefix used for various fake implementations has been renamed to Bunit. This includes the following types: FakeNavigationManager to BunitNavigationManager FakeJSRuntime to BunitJSRuntime FakeAuthenticationStateProvider to BunitAuthenticationStateProvider FakeAuthrozitationContext to BunitAuthorizationContext FakeuthorizationPolicyProvider to BunitAuthorizationPolicyProvider Unified the Render methods In v1 there were multiple RenderXXXmethods (like RenderComponent, Render and SetParametersAndRender) that were used to render components and markup. In v2, these methods have been unified into a single Render method that can handle both components and markup) via the simple Render method: - var cut = RenderComponent<MyComponent>(); + var cut = Render<MyComponent>(); Removed some abstraction Many types were removed in favor of one public type: IRenderedComponent<TComponent> - where TComponent is the type of the component rendered (or the a ContainerFragment if markup was rendered). The removed types were: IRenderedFragment IRenderedComponent IRenderedMarkup IRenderedComponentBase If any of the types were used (for example in extensions methods), they should be replaced with IRenderedComponent. Removed of IsNullOrEmpty extension method on IEnumerable<T> and CreateLogger on IServiceProvider The IsNullOrEmpty extension method on IEnumerable<T> has been removed, as well as the CreateLogger extension method on IServiceProvider. These extension methods are pretty common and conflict with other libraries. These methods can be recreated like this: public static class Extensions { public static bool IsNullOrEmpty<T>(this IEnumerable<T> enumerable) => enumerable == null || !enumerable.Any(); public static ILogger<T> CreateLogger<T>(this IServiceProvider serviceProvider) { var loggerFactory = serviceProvider.GetRequiredService<ILoggerFactory>() ?? NullLoggerFactory.Instance; return loggerFactory.CreateLogger<T>(); } } Event dispatcher does not offer overload with all parameters In version 1.x, bUnit offered for example the following methods to invoke onclick on a component: cut.Find(\"button\").Click(); cut.Find(\"button\").ClickAsync(new MouseEventArgs()); cut.Find(\"button\").Click(detail: 2, ctrlKey: true); The last one was a method with all parameters of MouseEventArgs as optional parameters. This method has been removed in favor of using the MouseEventArgs directly. Also ClickAsync - to align with its synchronous counterpart - doesn't take MouseEventArgs as mandatory parameter anymore. If not set, a default instance will be created. DisposeComponents is now async and called DisposeComponentsAsync The DisposeComponents method has been renamed to DisposeComponentsAsync and is now asynchronous. To migrate, simply rename the method and add await: - DisposeComponents(); + await DisposeComponentsAsync(); ## The ComponentParameterFactory and ComponentParameter has been removed The ComponentParameterFactory class has been removed (and therefore the usage of ComponentParameter). Instead, use the Render method (and its overloads) to pass parameters to components. IRefreshableElementCollection was removed The IRefreshableElementCollection interface has been removed. With that, the overload in FindAll doesn't accept a bool refresh parameter anymore. Instead, simply call FindAll again to get a refreshed collection. var items = cut.FindAll(\"li\", refresh: true); items.Count.ShouldBe(3); cut.Find(\"button\").Click(); // This changes the list items items.Count.ShouldBe(4); Should be changed to: var items = cut.FindAll(\"li\"); items.Count.ShouldBe(3); cut.Find(\"button\").Click(); // This changes the list items items = cut.FindAll(\"li\"); // Call FindAll again to refresh items.Count.ShouldBe(4);"
  },
  "docs/migrations/index.html": {
    "href": "docs/migrations/index.html",
    "title": "Migrations | bUnit",
    "keywords": "Migrations This section covers the migration across major versions of bUnit. The mirations themselves also list the link to the old version of the documentation (including the old API documentation). Migrating from 1.x to 2.x"
  },
  "docs/misc-test-tips.html": {
    "href": "docs/misc-test-tips.html",
    "title": "Miscellaneous testing tips | bUnit",
    "keywords": "Miscellaneous bUnit testing tips Here are a few testing tips and tricks that have proven useful to us. These dont fit naturally on other pages but are useful enough to be highlighted here. Projects structure and tips and tricks The recommended solution/project structure for a test and production code project set-up is as follows: src | MyComponentLib.csproj (namespace e.g. \"Company.MyComponentLib\") | _Imports.razor | Component1.razor | SubFolder | SubComponent1.razor test | MyComponentLibTests.csproj (with project reference to MyComponentLib.csproj) | _Imports.razor | Component1Test.cs | SubFolder | SubComponent1Test.cs Using the same root namespace and folder structure A neat trick, which will limit the number of import statements needed in your test project, is to set the root namespace to the same as that of the production code project, AND use the same folder structure as shown above. Following the example above, the MyComponentLibTests.csproj file should contain this: <PropertyGroup> <RootNamespace>Company.MyComponentLib</RootNamespace> </PropertyGroup> This makes the tooling in Visual Studio and other IDEs automatically assign the same namespaces to new test classes and test components when they are created. Capturing logs from ILogger in test output It can sometimes be helpful to capture log messages sent to ILogger types in the components under test and/or the bUnit and Blazor internals. With xUnit, this can be done as follows: Add the following packages to your test project: Serilog, Serilog.Extensions.Logging, Serilog.Expressions, and Serilog.Sinks.XUnit. Add the following class/extension method to your test project (which replicates the signature of the removed AddXunitLogger method): using Microsoft.Extensions.Logging; using Serilog; using Serilog.Events; using Serilog.Templates; using Xunit.Abstractions; namespace Xunit; public static class ServiceCollectionLoggingExtensions { public static IServiceCollection AddXunitLogger(this IServiceCollection services, ITestOutputHelper outputHelper) { var serilogLogger = new LoggerConfiguration() .MinimumLevel.Verbose() .WriteTo.TestOutput( testOutputHelper: outputHelper, formatter: new ExpressionTemplate(\"[{UtcDateTime(@t):mm:ss.ffffff} | {@l:u3} | {Substring(SourceContext, LastIndexOf(SourceContext, '.') + 1)} | {Coalesce(EventId.Name, '<none>')}] {@m}\\n{@x}\"), restrictedToMinimumLevel: LogEventLevel.Verbose) .CreateLogger(); services.AddSingleton<ILoggerFactory>(_ => new LoggerFactory().AddSerilog(serilogLogger, dispose: true)); services.AddSingleton(typeof(ILogger<>), typeof(Logger<>)); return services; } } In each test class whose tests should capture log messages, add a constructor that takes the ITestOutputHelper as input, and pass that to the AddXunitLogger extension method created in the previous step, e.g.: using System; using Microsoft.Extensions.DependencyInjection; using Bunit; using Xunit; using Xunit.Abstractions; namespace MyTests; public class MyComponenTest : BunitContext { public MyComponenTest(ITestOutputHelper outputHelper) { Services.AddXunitLogger(outputHelper); } [Fact] public void Test() ... } Easier HTML copying/pasting When writing tests in .cs files, you may want to copy/paste HTML into C# strings from something like a Razor file, for example. This is tedious to do manually as you have to escape quotes and other special characters, for example <div class=\"alert\"> needs to be written as \"<div class=\\\"alert\\\">\". The extension SmartPaster automatically escapes any characters that need to be escaped when it is used to copy strings."
  },
  "docs/providing-input/configure-3rd-party-libs.html": {
    "href": "docs/providing-input/configure-3rd-party-libs.html",
    "title": "Configure 3rd party libraries for testing | bUnit",
    "keywords": "Configure 3rd Party Libraries for Testing Testing a component that is built using a third-party component library can require additional setup steps in each test to ensure that the third-party components work correctly in a test context. For example, if a third-party component requires services to be registered in production code, it is likely that this is needed in a test context as well. See the Injecting services into components under test page for more info on this. Similarly, if a root component is needed to provide cascading values to the third-party components, that is likely to be needed as well. For more on this, see the Passing parameters to components page. bUnit Friendly Component Libraries This section contains a table of third-party component libraries that are known for allowing their users to test their components with bUnit. If additional setup or configuration is needed, a link is provided to the component library's own documentation which shows how to test a component that uses components from the library. Component Library bUnit compatibility notes Test context setup guide Telerik UI for Blazor Feedback is appreciated Telerik Grid Setup Tip If you are a Blazor component vendor and have instructions on how to setup a bUnit test context for testing components that use your components, please add a link to your documentation and component library to the table above. Just submit a pull-request to this page with the relevant links added, share the relevant links in bUnit's gitter chat, or add an issue on bUnit's github page with the relevant links."
  },
  "docs/providing-input/controlling-component-instantiation.html": {
    "href": "docs/providing-input/controlling-component-instantiation.html",
    "title": "Controlling component instantiation | bUnit",
    "keywords": "Controlling component instantiation Components are, by default in bUnit, instantiated in the exact same way the regular Blazor runtime does it. For example, if the component under test has a <Counter /> component inside it, an instance of the Counter class will be created at runtime and added to the render tree below the component under test. It is however possible to control how Blazor components build using .NET 5 or newer are instantiated by bUnit. This enables the possibility to replace one component during testing with another, e.g., to replace a 3rd party component during testing with a \"stub component\", to make the test easier to write and maintain. The following sections will describe how to use component factories to control the instantiation of components during testing. Using component factories to control instantiation To take control of how components are instantiated during testing, add one or more IComponentFactory types to the ComponentFactories collection. The added component factories CanCreate(Type) methods will be called in a last- to first-added order, e.g., the last one added will be called first, then the second-to-last, and so on, and the first that returns true will have its Create(Type) method invoked. If none of the factories can create the requested type, the default Blazor factory will be used. Example  replacing <Foo> with <Bar> To create a component factory that replaces <Foo> with <Bar> create the following component factory: using System; using Microsoft.AspNetCore.Components; using Bunit; public class FooBarComponentFactory : IComponentFactory { public bool CanCreate(Type componentType) => typeof(Foo) == componentType; public IComponent Create(Type componentType) => new Bar(); } Make sure that the replacement component is compatible with the component it replaces, i.e., has the same parameters. This can be done by copying all parameters from the replacee to the replacer, or by using attribute splatting and arbitrary parameters in the replacer. Then, before rendering the component under test, add the FooBarComponentFactory to the test contexts component factories collection: [Fact] public void ReplacesFooWithBarDuringTest() { // Arrange ComponentFactories.Add(new FooBarComponentFactory()); // Act var cut = Render<Wrapper>(parameters => parameters .AddChildContent<Foo>()); // Assert that there are no <Foo> in render tree, // but there is one <Bar> in the render tree. Assert.Empty(cut.FindComponents<Foo>()); Assert.Single(cut.FindComponents<Bar>()); } } } Built-in factories bUnit comes with several built-in factories that allow shallow rendering or replacing components with test dummies and test stubs. See the Substituting (mocking) component page for details."
  },
  "docs/providing-input/index.html": {
    "href": "docs/providing-input/index.html",
    "title": "Providing input to a component under test | bUnit",
    "keywords": "Providing input to a component under test This section covers the various ways to provide input to a component under test. Its split into four sub sections: Passing parameters to components: This covers passing regular parameters, child content, cascading values, event callbacks, etc. Injecting services into components under test: This covers injecting services into components under test. Controlling the root render tree: This covers how to modify the root render tree in which components under tests are rendered. Configure 3rd party libraries for testing: This covers setting up third-party libraries in a bUnit testing scenario so that components under test that use them can be tested easily."
  },
  "docs/providing-input/inject-services-into-components.html": {
    "href": "docs/providing-input/inject-services-into-components.html",
    "title": "Injecting services into components under test | bUnit",
    "keywords": "Injecting services into components under test It is common for components under test to have a dependency on services, injected into them through the @inject IMyService MyService syntax in .razor files, or the [Inject] private IMyService MyService { get; set; } syntax in .cs files. This is supported in bUnit through the Services collection available through the test context. The Services collection is just an IServiceCollection, which means services can be registered in the same manner as done for production code in Startup.cs in Blazor Server projects and in Program.cs in Blazor WASM projects. In bUnit, you register the services in the Services collection before you render a component under test. Note The AddSingleton() method is only available on the Services collection if you import the Microsoft.Extensions.DependencyInjection namespace in your test class. The following sections demonstrate how to do this. The examples we will cover will test the <WeatherForecasts> component listed below, which depends on the IWeatherForecastService service, injected in line 1: @inject IWeatherForecastService ForecastService <h1>Weather forecast</h1> <p>This component demonstrates fetching data from a service.</p> @if (Forecasts is null) { <p><em>Loading...</em></p> } else { <WeatherForecastTabel Forecasts=@Forecasts /> } @code { public WeatherForecast[] Forecasts { get; private set; } protected override async Task OnInitializedAsync() { Forecasts = await ForecastService.GetForecastAsync(DateTime.Now); } } Injecting services in tests Here is a test that registers the IWeatherForecastService in the Services collection, which is a requirement of the <WeatherForecasts> component listed above. Services.AddSingleton<IWeatherForecastService>(new WeatherForecastService()); // Render will inject the service in the WeatherForecasts component // when it is instantiated and rendered. var cut = Render<WeatherForecasts>(); // Assert that service is injected Assert.NotNull(cut.Instance.Forecasts); } The highlighted line shows how the IWeatherForecastService is registered in the test context's Services collection, which is just a standard IServiceCollection, using the standard .NET Core dependency injection (DI) services method, AddSingleton. Fallback service provider A fallback service provider can be registered with the built-in BunitServiceProvider. This enables a few interesting use cases, such as using an alternative IoC container (which should implement the IServiceProvider interface), or automatically creating mock services for your Blazor components. The latter can be achieved by using a combination of AutoFixture and your favorite mocking framework, e.g. Moq, NSubsitute, or Telerik JustMock. When is the fallback service provider used? The logic inside the BunitServiceProvider for using the fallback service provider is as follows: Try resolving the requested service from the standard service provider in bUnit. If that fails, try resolving from a fallback service provider, if one exists. In other words, the fallback service provider will always be tried after the default service provider has had a chance to fulfill a request for a service. Registering a fallback service provider This is an example of how to implement and use a fallback service provider: public class FallbackServiceProvider : IServiceProvider { public object GetService(Type serviceType) { return new DummyService(); } } public class DummyService Here is a test where the fallback service provider is used: Services.AddFallbackServiceProvider(new FallbackServiceProvider()); var dummyService = Services.GetService<DummyService>(); Assert.NotNull(dummyService); In this example, the DummyService is provided by the fallback service provider, since it is not registered in the default service provider. Using a custom IServiceProvider implementation A custom service provider factory can be registered with the built-in BunitServiceProvider. It is used to create the underlying IServiceProvider. This enables a few interesting use cases, such as using an alternative IoC container (which should implement the IServiceProvider interface). This approach can be useful if the fallback service provider is not an option. For example, if you have dependencies in the fallback container, that rely on dependencies which are in the main container and vice versa. Registering Autofac service provider factory The example makes use of AutofacServiceProviderFactory and AutofacServiceProvider from the package Autofac.Extensions.DependencyInjection and shows how to use an Autofac dependency container with bUnit. Here is a test where the Autofac service provider factory is used: [Fact] public void AutofacServiceProviderViaFactoryReturns() { void ConfigureContainer(ContainerBuilder containerBuilder) { containerBuilder .RegisterType<DummyService>() .AsSelf(); } Services.UseServiceProviderFactory(new AutofacServiceProviderFactory(ConfigureContainer)); //get a service which was installed in the Autofac ContainerBuilder var dummyService = Services.GetService<DummyService>(); Assert.NotNull(dummyService); //get a service which was installed in the bUnit ServiceCollection var BunitContext = Services.GetService<BunitContext>(); Assert.NotNull(BunitContext); Assert.Equal(this, BunitContext); } Here is a test where the Autofac service provider is used via delegate: [Fact] public void AutofacServiceProviderViaDelegateReturns() { ILifetimeScope ConfigureContainer(IServiceCollection services) { var containerBuilder = new ContainerBuilder(); containerBuilder .RegisterType<DummyService>() .AsSelf(); containerBuilder.Populate(services); return containerBuilder.Build(); } Services.UseServiceProviderFactory(x => new AutofacServiceProvider(ConfigureContainer(x))); //get a service which was installed in the Autofac ContainerBuilder var dummyService = Services.GetService<DummyService>(); Assert.NotNull(dummyService); //get a service which was installed in the bUnit ServiceCollection var BunitContext = Services.GetService<BunitContext>(); Assert.NotNull(BunitContext); Assert.Equal(this, BunitContext); } Registering a custom service provider factory The examples contain dummy implementations of IServiceProvider and IServiceProviderFactory<TContainerBuilder>. Normally those implementations are supplied by the creator of your custom dependency injection solution (e.g. Autofac example above). This dummy implementations are not intended to use as is. This is an example of how to implement and use a dummy custom service provider factory. public sealed class CustomServiceProvider : IServiceProvider, IServiceScopeFactory, IServiceScope { private readonly IServiceProvider _serviceProvider; public CustomServiceProvider(IServiceCollection serviceDescriptors) => _serviceProvider = serviceDescriptors.BuildServiceProvider(); public object GetService(Type serviceType) { if (serviceType == typeof(IServiceScope) || serviceType == typeof(IServiceScopeFactory)) return this; if (serviceType == typeof(DummyService)) return new DummyService(); return _serviceProvider.GetService(serviceType); } void IDisposable.Dispose() { } public IServiceScope CreateScope() => this; IServiceProvider IServiceScope.ServiceProvider => this; } public sealed class CustomServiceProviderFactoryContainerBuilder { private readonly IServiceCollection _serviceDescriptors; public CustomServiceProviderFactoryContainerBuilder(IServiceCollection serviceDescriptors) => this._serviceDescriptors = serviceDescriptors; public IServiceProvider Build() => new CustomServiceProvider(_serviceDescriptors); } public sealed class CustomServiceProviderFactory : IServiceProviderFactory<CustomServiceProviderFactoryContainerBuilder> { public CustomServiceProviderFactoryContainerBuilder CreateBuilder(IServiceCollection services) => new CustomServiceProviderFactoryContainerBuilder(services); public IServiceProvider CreateServiceProvider(CustomServiceProviderFactoryContainerBuilder containerBuilder) => containerBuilder.Build(); } Here is a test where the custom service provider factory is used: Services.UseServiceProviderFactory(new CustomServiceProviderFactory()); var dummyService = Services.GetService<DummyService>(); Assert.NotNull(dummyService); Here is a test where the custom service provider is used via delegate: Services.UseServiceProviderFactory(x => new CustomServiceProvider(x)); var dummyService = Services.GetService<DummyService>(); Assert.NotNull(dummyService); Using libraries like AutoMocker as fallback provider It is possible to use libraries that automatically create mock services as fallback service providers. Here is an example implementation that utilizes the AutoMocker public class MockServiceProvider : IServiceProvider { private readonly AutoMocker _autoMocker = new AutoMocker(); public object? GetService(Type serviceType) { return _autoMocker.Get(serviceType); } } Warning An exception has to be made for IComponentActivator, if \"Loose\" mode is used. Otherwise, runtime exception can be thrown. public class MockServiceProvider : IServiceProvider { private readonly AutoMocker _autoMocker = new AutoMocker(MockBehavior.Loose); public object? GetService(Type serviceType) { if (serviceType == typeof(IComponentActivator)) { return null; } return _autoMocker.Get(serviceType); } } Further reading A closely related topic is mocking. To learn more about mocking in bUnit, go to the Mocking and faking component dependencies page."
  },
  "docs/providing-input/passing-parameters-to-components.html": {
    "href": "docs/providing-input/passing-parameters-to-components.html",
    "title": "Passing parameters to components | bUnit",
    "keywords": "Passing parameters to components bUnit comes with a number of ways to pass parameters to components under test: In tests written in .razor files, passing parameters is most easily done with inside an inline Razor template passed to the Render method, although the parameter passing option available in tests written in C# files is also available here. In tests written in .cs files, bUnit includes a strongly typed builder. There are two methods in bUnit that allow passing parameters in C#-based test code: Render method on the test context, which is used to render a component initially. Render method on a rendered component, which is used to pass new parameters to an already rendered component. In the following sub sections, we will show both .cs- and .razor-based test code; just click between them using the tabs. Note The examples below are written using xUnit, but the code is the same with NUnit and MSTest. The example tests are inheriting from the BunitContext as described in the Writing tests for Blazor components page. If your test class is not inheriting from the BunitContext, then you should explicitly instantiate the BunitContext in your tests. The recommended way is to inherit from the BunitContext. An example below will demonstrate how to instantiate a BunitContext per test method. Regular parameters A regular parameter is one that is declared using the [Parameter] attribute. The following subsections will cover both non-Blazor type parameters, e.g. int and List<string>, and the special Blazor types like EventCallback and RenderFragment. Non-Blazor type parameters Let's look at an example of passing parameters that takes types which are not special to Blazor, i.e.: public class NonBlazorTypesParams : ComponentBase { [Parameter] public int Numbers { get; set; } [Parameter] public List<string> Lines { get; set; } } This can be done like this: C# test code Razor test code public class NonBlazorTypesParamsTest : BunitContext { [Fact] public void Test() { var lines = new List<string> { \"Hello\", \"World\" }; var cut = Render<NonBlazorTypesParams>(parameters => parameters .Add(p => p.Numbers, 42) .Add(p => p.Lines, lines) ); } } The example uses the ComponentParameterCollectionBuilder<TComponent>'s Add method, which takes a parameter selector expression that selects the parameter using a lambda, and forces you to provide the correct type for the value. This makes the builder's methods strongly typed and refactor-safe. @inherits BunitContext @code { [Fact] public void Test() { var lines = new List<string> { \"Hello\", \"World\" }; var cut = Render(@<NonBlazorTypesParams Numbers=\"42\" Lines=\"lines\" />); } } The example passes a inline Razor template to the Render() method. The parameters to the component is just passed like normal in Razor code. EventCallback parameters This example will pass parameters to the following two EventCallback parameters: public class EventCallbackParams : ComponentBase { [Parameter] public EventCallback<MouseEventArgs> OnClick { get; set; } [Parameter] public EventCallback OnSomething { get; set; } } This can be done like this: C# test code Razor test code public class EventCallbackParamsTest : BunitContext { [Fact] public void Test() { Action<MouseEventArgs> onClickHandler = _ => { }; Action onSomethingHandler = () => { }; var cut = Render<EventCallbackParams>(parameters => parameters .Add(p => p.OnClick, onClickHandler) .Add(p => p.OnSomething, onSomethingHandler) ); } } The example uses the ComponentParameterCollectionBuilder<TComponent>'s Add method, which takes a parameter selector expression that selects the parameter using a lambda, and forces you to provide the correct type of callback method. This makes the builder's methods strongly typed and refactor-safe. @inherits BunitContext @code { [Fact] public void Test() { Action<MouseEventArgs> onClickHandler = _ => { }; Action onSomethingHandler = () => { }; var cut = Render(@<EventCallbackParams OnClick=\"onClickHandler\" OnSomething=\"onSomethingHandler\" />); } } The example passes a inline Razor template to the Render(RenderFragment) method. The parameters to the component is just passed like normal in Razor code. ChildContent parameters The ChildContent parameter in Blazor is represented by a RenderFragment. In Blazor, this can be regular HTML markup, it can be Razor markup, e.g. other component declarations, or a mix of the two. If it is another component, then that component can also receive child content, and so forth. The following subsections have different examples of child content being passed to the following component: public class ChildContentParams : ComponentBase { [Parameter] public RenderFragment ChildContent { get; set; } } Passing HTML to the ChildContent parameter C# test code Razor test code public class ChildContentParams1Test : BunitContext { [Fact] public void Test() { var cut = Render<ChildContentParams>(parameters => parameters .AddChildContent(\"<h1>Hello World</h1>\") ); } } The example uses the ComponentParameterCollectionBuilder<TComponent>'s AddChildContent method to pass an HTML markup string as the input to the ChildContent parameter. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<ChildContentParams> <h1>Hello World</h1> </ChildContentParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child content, some HTML markup, is just passed like normal in Razor code. Passing a component without parameters to the ChildContent parameter To pass a component, e.g. the classic <Counter> component, which does not take any parameters itself, to a ChildContent parameter, do the following: C# test code Razor test code public class ChildContentParams2Test : BunitContext { [Fact] public void Test() { var cut = Render<ChildContentParams>(parameters => parameters .AddChildContent<Counter>() ); } } The example uses the ComponentParameterCollectionBuilder<TComponent>'s AddChildContent<TChildComponent> method, where TChildComponent is the (child) component that should be passed to the component under test's ChildContent parameter. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<ChildContentParams> <Counter /> </ChildContentParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child content, some Razor markup, is just passed like normal in Razor code. Passing a component with parameters to the ChildContent parameter To pass a component with parameters to a component under test, e.g. the <Alert> component with the following parameters, do the following: [Parameter] public string Heading { get; set; } [Parameter] public AlertType Type { get; set; } [Parameter] public RenderFragment ChildContent { get; set; } C# test code Razor test code public class ChildContentParams3Test : BunitContext { [Fact] public void Test() { var cut = Render<ChildContentParams>(parameters => parameters .AddChildContent<Alert>(alertParameters => alertParameters .Add(p => p.Heading, \"Alert heading\") .Add(p => p.Type, AlertType.Warning) .AddChildContent(\"<p>Hello World</p>\") ) ); } } The example uses the ComponentParameterCollectionBuilder<TComponent>'s AddChildContent<TChildComponent> method, where TChildComponent is the (child) component that should be passed to the component under test. The AddChildContent<TChildComponent> method takes an optional ComponentParameterCollectionBuilder<TComponent> as input, which can be used to pass parameters to the TChildComponent component, which in this case is the <Alert> component. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<ChildContentParams> <Alert Heading=\"Alert heading\" Type=@AlertType.Warning> <p>Hello World</p> </Alert> </ChildContentParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child content, some Razor markup, and parameters to the child component, is just passed like normal in Razor code. Passing a mix of Razor and HTML to a ChildContent parameter Some times you need to pass multiple different types of content to a ChildContent parameter, e.g. both some markup and a component. This can be done in the following way: C# test code Razor test code public class ChildContentParams4Test : BunitContext { [Fact] public void Test() { var cut = Render<ChildContentParams>(parameters => parameters .AddChildContent(\"<h1>Below you will find a most interesting alert!</h1>\") .AddChildContent<Alert>(childParams => childParams .Add(p => p.Heading, \"Alert heading\") .Add(p => p.Type, AlertType.Warning) .AddChildContent(\"<p>Hello World</p>\") ) ); } } Passing a mix of markup and components to a ChildContent parameter is done by simply calling the ComponentParameterCollectionBuilder<TComponent>'s AddChildContent() methods as seen here. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<ChildContentParams> <h1>Below you will find a most interesting alert!</h1> <Alert Heading=\"Alert heading\" Type=@AlertType.Warning> <p>Hello World</p> </Alert> </ChildContentParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child content, some Razor markup, and parameters to the child component, is just passed like normal in Razor code. RenderFragment parameters A RenderFragment parameter is very similar to the special ChildContent parameter described in the previous section, since a ChildContent parameter is of type RenderFragment. The only difference is the name, which must be anything other than ChildContent. In Blazor, a RenderFragment parameter can be regular HTML markup, it can be Razor markup, e.g. other component declarations, or it can be a mix of the two. If it is another component, then that component can also receive child content, and so forth. The following subsections have different examples of content being passed to the following component's RenderFragment parameter: public class RenderFragmentParams : ComponentBase { [Parameter] public RenderFragment Content { get; set; } } Passing HTML to a RenderFragment parameter C# test code Razor test code public class RenderFragmentParams1Test : BunitContext { [Fact] public void Test() { var cut = Render<RenderFragmentParams>(parameters => parameters .Add(p => p.Content, \"<h1>Hello World</h1>\") ); } } The example uses the ComponentParameterCollectionBuilder<TComponent>'s Add method to pass an HTML markup string as the input to the RenderFragment parameter. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<RenderFragmentParams> <Content><h1>Hello World</h1></Content> </RenderFragmentParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child content, some HTML markup, is just passed like normal in Razor code. Passing a component without parameters to a RenderFragment parameter To pass a component such as the classic <Counter> component, which does not take any parameters, to a RenderFragment parameter, do the following: C# test code Razor test code public class RenderFragmentParams2Test : BunitContext { [Fact] public void Test() { var cut = Render<RenderFragmentParams>(parameters => parameters .Add<Counter>(p => p.Content) ); } } The example uses the ComponentParameterCollectionBuilder<TComponent>'s Add<TChildComponent> method, where TChildComponent is the (child) component that should be passed to the RenderFragment parameter. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<RenderFragmentParams> <Content><Counter /></Content> </RenderFragmentParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child content, some Razor markup, is just passed like normal in Razor code. Passing a component with parameters to a RenderFragment parameter To pass a component with parameters to a RenderFragment parameter, e.g. the <Alert> component with the following parameters, do the following: [Parameter] public string Heading { get; set; } [Parameter] public AlertType Type { get; set; } [Parameter] public RenderFragment ChildContent { get; set; } C# test code Razor test code public class RenderFragmentParams3Test : BunitContext { [Fact] public void Test() { var cut = Render<RenderFragmentParams>(parameters => parameters .Add<Alert>(p => p.Content, alertParameters => alertParameters .Add(p => p.Heading, \"Alert heading\") .Add(p => p.Type, AlertType.Warning) .AddChildContent(\"<p>Hello World</p>\") ) ); } } The example uses the ComponentParameterCollectionBuilder<TComponent>'s Add<TChildComponent> method, where TChildComponent is the (child) component that should be passed to the RenderFragment parameter. The Add<TChildComponent> method takes an optional ComponentParameterCollectionBuilder<TComponent> as input, which can be used to pass parameters to the TChildComponent component, which in this case is the <Alert> component. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<RenderFragmentParams> <Content> <Alert Heading=\"Alert heading\" Type=@AlertType.Warning> <p>Hello World</p> </Alert> </Content> </RenderFragmentParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child content, some Razor markup, and parameters to the child component, is just passed like normal in Razor code. Passing a mix of Razor and HTML to a RenderFragment parameter Some times you need to pass multiple different types of content to a RenderFragment parameter, e.g. both markup and and a component. This can be done in the following way: C# test code Razor test code public class RenderFragmentParams4Test : BunitContext { [Fact] public void Test() { var cut = Render<RenderFragmentParams>(parameters => parameters .Add(p => p.Content, \"<h1>Below you will find a most interesting alert!</h1>\") .Add<Alert>(p => p.Content, childParams => childParams .Add(p => p.Heading, \"Alert heading\") .Add(p => p.Type, AlertType.Warning) .AddChildContent(\"<p>Hello World</p>\") ) ); } } Passing a mix of markup and components to a RenderFragment parameter is simply done by calling the ComponentParameterCollectionBuilder<TComponent>'s Add() methods or using the AddChildContent factory methods. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<RenderFragmentParams> <Content> <h1>Below you will find a most interesting alert!</h1> <Alert Heading=\"Alert heading\" Type=@AlertType.Warning> <p>Hello World</p> </Alert> </Content> </RenderFragmentParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child content, some HTML and Razor markup, and parameters to the child component, is just passed like normal in Razor code. Templates parameters Template parameters are closely related to the RenderFragment parameters described in the previous section. The difference is that a template parameter is of type RenderFragment<TValue>. As with a regular RenderFragment, a RenderFragment<TValue> template parameter can consist of regular HTML markup, it can be Razor markup, e.g. other component declarations, or it can be a mix of the two. If it is another component, then that component can also receive child content, and so forth. The following examples renders a template component which has a RenderFragment<TValue> template parameter: @typeparam TItem <div id=\"generic-list\"> @foreach (var item in Items) { @Template(item) } </div> @code { [Parameter] public IEnumerable<TItem> Items { get; set; } [Parameter] public RenderFragment<TItem> Template { get; set; } } Passing HTML-based templates To pass a template into a RenderFragment<TValue> parameter that just consists of regular HTML markup, do the following: C# test code Razor test code public class TemplateParams1Test : BunitContext { [Fact] public void Test() { var cut = Render<TemplateParams<string>>(parameters => parameters .Add(p => p.Items, new[] { \"Foo\", \"Bar\", \"Baz\" }) .Add(p => p.Template, item => $\"<span>{item}</span>\") ); } } The examples pass a HTML markup template into the component under test. This is done with the help of a Func<TValue, string> delegate which takes whatever the template value is as input, and returns a (markup) string. The delegate is automatically turned into a RenderFragment<TValue> type and passed to the template parameter. The example uses the ComponentParameterCollectionBuilder<TComponent>'s Add method to first add the data to the Items parameter and then to a Func<TValue, string> delegate. The delegate creates a simple markup string in the example. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<TemplateParams Items=@(new[] { \"Foo\", \"Bar\", \"Baz\" }) TItem=\"string\"> <Template> <span>@context</span> </Template> </TemplateParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child template content, some HTML markup, is just passed like normal in Razor code. NOTE: Before the .NET 6 version of the Blazor compiler, this example does not work. Passing a component-based template To pass a template into a RenderFragment<TValue> parameter, which is based on a component that receives the template value as input (in this case, the <Item> component listed below), do the following: <span>@Value</span> @code { [Parameter] public string Value { get; set; } } C# test code Razor test code public class TemplateParams2Test : BunitContext { [Fact] public void Test() { var cut = Render<TemplateParams<string>>(parameters => parameters .Add(p => p.Items, new[] { \"Foo\", \"Bar\", \"Baz\" }) .Add<Item, string>(p => p.Template, value => itemParams => itemParams .Add(p => p.Value, value) ) ); } } The example creates a template with the <Item> component listed above. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<TemplateParams Items=@(new string[]{ \"Foo\", \"Bar\", \"Baz\" }) TItem=\"string\"> <Template> <Item Value=@context></Item> </Template> </TemplateParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The child template content, some HTML and Razor markup, is just passed like normal in Razor code. NOTE: Before the .NET 6 version of the Blazor compiler, this example does not work. Unmatched parameters An unmatched parameter is a parameter that is passed to a component under test, and which does not have an explicit [Parameter] parameter but instead is captured by a [Parameter(CaptureUnmatchedValues = true)] parameter. In the follow examples, we will pass an unmatched parameter to the following component: public class UnmatchedParams : ComponentBase { [Parameter(CaptureUnmatchedValues = true)] public Dictionary<string, object> InputAttributes { get; set; } } C# test code Razor test code public class UnmatchedParamsTest : BunitContext { [Fact] public void Test() { var cut = Render<UnmatchedParams>(parameters => parameters .AddUnmatched(\"some-unknown-param\", \"a value\") ); } } The examples passes in the parameter some-unknown-param with the value a value to the component under test. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<UnmatchedParams some-unknown-param=\"a value\"></UnmatchedParams>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The parameter is just passed like normal in Razor code. Cascading Parameters and Cascading Values Cascading parameters are properties with the [CascadingParameter] attribute. There are two variants: named and unnamed cascading parameters. In Blazor, the <CascadingValue> component is used to provide values to cascading parameters, which we also do in tests written in .razor files. However, for tests written in .cs files we need to do it a little differently. The following examples will pass cascading values to the <CascadingParams> component listed below: @code { [CascadingParameter] public bool IsDarkTheme { get; set; } [CascadingParameter(Name = \"LoggedInUser\")] public string UserName { get; set; } [CascadingParameter(Name = \"LoggedInEmail\")] public string Email { get; set; } } Passing unnamed cascading values To pass the unnamed IsDarkTheme cascading parameter to the <CascadingParams> component, do the following: C# test code Razor test code public class CascadingParams1Test : BunitContext { [Fact] public void Test() { var isDarkTheme = true; var cut = Render<CascadingParams>(parameters => parameters .Add(p => p.IsDarkTheme, isDarkTheme) ); } } The example pass the variable isDarkTheme to the cascading parameter IsDarkTheme using the Add method on the ComponentParameterCollectionBuilder<TComponent> with the parameter selector to explicitly select the desired cascading parameter and pass the unnamed parameter value that way. @inherits BunitContext @code { [Fact] public void Test() { var isDarkTheme = true; var cut = Render(@<CascadingValue Value=\"isDarkTheme\"> <CascadingParams /> </CascadingValue>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The cascading value is just passed like normal in Razor code. Passing named cascading values To pass a named cascading parameter to the <CascadingParams> component, do the following: C# test code Razor test code public class CascadingParams2Test : BunitContext { [Fact] public void Test() { var cut = Render<CascadingParams>(parameters => parameters .Add(p => p.UserName, \"Name of User\") ); } } The example pass in the value Name of User to the cascading parameter with the name LoggedInUser. Note that the name of the parameter is not the same as the property of the parameter, e.g. LoggedInUser vs. UserName. The example uses the Add method on the ComponentParameterCollectionBuilder<TComponent> with the parameter selector to select the cascading parameter property and pass the parameter value that way. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render(@<CascadingValue Name=\"LoggedInUser\" Value=@(\"Name of User\")> <CascadingParams /> </CascadingValue>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The cascading value is just passed like normal in Razor code. Passing multiple, named and unnamed, cascading values To pass all cascading parameters to the <CascadingParams> component, do the following: C# test code Razor test code public class CascadingParams3Test : BunitContext { [Fact] public void Test() { var isDarkTheme = true; var cut = Render<CascadingParams>(parameters => parameters .Add(p => p.IsDarkTheme, isDarkTheme) .Add(p => p.UserName, \"Name of User\") .Add(p => p.Email, \"user@example.com\") ); } } The example passes both the unnamed IsDarkTheme cascading parameter and the two named cascading parameters (LoggedInUser, LoggedInEmail). It does this using the Add method on the ComponentParameterCollectionBuilder<TComponent> with the parameter selector to select both the named and unnamed cascading parameters and pass values to them that way. @inherits BunitContext @code { [Fact] public void Test() { var isDarkTheme = true; var cut = Render(@<CascadingValue Name=\"LoggedInUser\" Value=@(\"Name of User\")> <CascadingValue Name=\"LoggedInEmail\" Value=@(\"user@example.com\")> <CascadingValue Value=\"isDarkTheme\"> <CascadingParams /> </CascadingValue> </CascadingValue> </CascadingValue>); } } The example passes a inline Razor template to the Render(RenderFragment) method. The cascading value is just passed like normal in Razor code. Rendering a component under test inside other components It is possible to nest a component under tests inside other components, if that is required to test it. For example, to nest the <HelloWorld> component inside the <Wrapper> component do the following: C# test code Razor test code [Fact] public void Test() { var wrapper = Render<Wrapper>(parameters => parameters .AddChildContent<HelloWorld>() ); var cut = wrapper.FindComponent<HelloWorld>(); } The example renders the <HelloWorld> component inside the <Wrapper> component. What is special in both cases is the use of the FindComponent<HelloWorld>() that returns a RenderedComponent<HelloWorld>. This is needed because the Render<Wrapper> method call returns an RenderedComponent<Wrapper> instance, that provides access to the instance of the <Wrapper> component, but not the <HelloWorld>-component instance. @inherits BunitContext @code { [Fact] public void Test() { var cut = Render<HelloWorld>(@<Wrapper> <HelloWorld /> </Wrapper>); } } The example passes a inline Razor template to the Render<TComponent>() method. What is different here from the previous examples is that we use the generic version of the Render<TComponent> method, which is a shorthand for Render(...).FindComponent<TComponent>(). Configure two-way with component parameters (@bind directive) To set up two-way binding to a pair of component parameters on a component under test, e.g. the Value and ValueChanged parameter pair on the component below, do the following: @code { [Parameter] public string Value { get; set; } = string.Empty; [Parameter] public EventCallback<string> ValueChanged { get; set; } } C# test code Razor test code public class TwoWayBindingTest : BunitContext { [Fact] public void Test() { var currentValue = string.Empty; Render<TwoWayBinding>(parameters => parameters.Bind( p => p.Value, currentValue, newValue => currentValue = newValue)); } } The example uses the Bind method to setup two-way binding between the Value parameter and ValueChanged parameter, and the local variable in the test method (currentValue). The Bind method is a shorthand for calling the the Add method for the Value parameter and ValueChanged parameter individually. @inherits BunitContext @code { [Fact] public void Test() { var currentValue = string.Empty; var cut = Render(@<TwoWayBinding @bind-Value=\"currentValue\"></TwoWayBinding>); } } The example uses the standard @bind-Value directive in Blazor to set up two way binding between the Value parameter and ValueChanged parameter and the local variable in the test method (currentValue). Warning When using @bind in conjunction with razor test-files the razor component should not inherit from ComponentBase (which is the default). The simplest solution would be to inherit from BunitContext (as seen in the example above) which also brings the benefits as described on top of this page. BunitContext per test method There are scenarios where it is not possible or not desirable to inherit from BunitContext in the test class. In those cases, it is possible to create a new BunitContext instance per test method. As the BunitContext class implements IDisposable, it is recommended to use the using statement to ensure that the instance is disposed of after the test method has run. C# test code Razor test code public class HelloWorldExplicitContext { [Fact] public void HelloWorldComponentRendersCorrectly() { // Arrange using var ctx = new BunitContext(); // Act var cut = ctx.Render<HelloWorld>(); // Assert cut.MarkupMatches(\"<h1>Hello world from Blazor</h1>\"); } } @code { [Fact] public void HelloWorldComponentRendersCorrectly() { // Arrange using var ctx = new BunitContext(); // Act var cut = ctx.Render(@<HelloWorld/>); // Assert cut.MarkupMatches(@<h1>Hello world from Blazor</h1>); } } Getting an InvalidOperationException When the razor syntax is used and the test throws the following exception: System.InvalidOperationException: The render handle is not yet assigned. This usually means that the test class (Blazor component where the tests is declared in) is direclty inheriting from ComponentBase, as is the default for all Blazor components. The solution is to inherit from bUnits BunitContext instead, i.e.: @inherits BunitContext @code { [Fact] public void Test1() { // test code } } Limitations of rendering a RenderFragment inside a test When rendering a RenderFragment using the Render(RenderFragment) method, the created IRenderedComponent<TComponent> is static. This means that it will not re-render even if events are triggered. @inherits BunitContext @code { [Fact] public void Button_clicked_string_gets_updated() { var output = string.Empty; var cut = Render(@<button @onclick='@(() => output = \"Success\")'>@output</button>); cut.Find(\"button\").Click(); // This will pass, as events are triggered and the function get executed output.ShouldBe(\"Success\"); // This will fail, as the markup will not get updated cut.Find(\"button\").TextContent.ShouldBe(\"Success\"); } } Passing query parameters (SupplyParameterFromQuery) to a component In .NET 6 and later, components can receive parameters from a query string if the parameter is annotated with the [SupplyParameterFromQuery] attribute in addition to the [Parameter] attribute. In .NET 8 however, the [Parameter] attribute is no longer required, which means a value cannot be passed to the component during testing using the normal methods, e.g. the ComponentParameterCollectionBuilder<TComponent>'s Add method, if a component parameter is only annotated with the [SupplyParameterFromQuery] attribute. Instead, pass a query string parameters by setting it using the BunitNavigationManager. For example: @code { [SupplyParameterFromQuery] public string Name { get; set; } } A simple example of how to test a component that receives parameters from the query string: @inherits BunitContext @code { [Fact] public void Component_receives_parameters_from_query_string() { var navigationManager = Services.GetRequiredService<NavigationManager>(); var uri = navigationManager.GetUriWithQueryParameter(\"Name\", \"bUnit\"); navigationManager.NavigateTo(uri); var cut = Render<SupplyFromQueryParameterComponent>(); cut.Instance.Name.ShouldBe(\"bUnit\"); } } Further Reading Injecting services into components under test"
  },
  "docs/providing-input/root-render-tree.html": {
    "href": "docs/providing-input/root-render-tree.html",
    "title": "Controlling the root render tree | bUnit",
    "keywords": "Controlling the root render tree The root render tree, the render tree in which components under test are rendered, can be added to before components are rendered with bUnit's test context. This is mostly useful when a component under test, or a component it depends on, must be rendered inside another component, that provides a cascading value to it. For example, when using Blazors authentication, it is common to add the CascadingAuthenticationState component higher up the render tree, such that it can provide authentication state to those components below it that need it. Adding this through the RenderTree property on the BunitContext type makes it possible to add it once in a shared setup method, and not have to do so in every test method during the call to Render(). This can also be useful when writing tests that use a third-party component library, that require a special root component to be added to the render tree, but which otherwise dont change between tests. Adding a component to the root render tree The following example verifies that the PrintCascadingValue component correctly prints out the cascading value passed to it. This value is passed to it by adding the CascadingValue<string> component to the render tree and then rendering the PrintCascadingValue component. The PrintCascadingValue component looks like this: Cascading value: @Value @code { [CascadingParameter] public string Value { get; set; } } Here is the test that adds the CascadingValue<string> component to the render tree and then renders the PrintCascadingValue component. // Add a cascading value to the test contexts root render tree. RenderTree.Add<CascadingValue<string>>(parameters => parameters .Add(p => p.Value, \"FOO\") ); // The component will be rendered as a child of last // component added to the RenderTree property. var cut = Render<PrintCascadingValue>(); // Verify that the cascading value was passed correctly. cut.MarkupMatches($\"Cascading value: FOO\"); Note The call to Add can be done in a common setup method, outside the context of the test method listed here, for easy re-use between tests. Add only if not already in root render tree Sometimes common test setup logic exists outside the test class, perhaps abstracted away in other libraries. In those cases, the TryAdd method can be used to a components to the render tree, only if it has not already been added. TryAdd returns true if the component was added, false otherwise. RenderTree.TryAdd<CascadingValue<string>>(parameters => parameters .Add(p => p.Value, \"BAR?\") ); In the listing above, the cascading value BAR? is added only if there is not another CascadingValue<string> component added to the render tree already."
  },
  "docs/providing-input/substituting-components.html": {
    "href": "docs/providing-input/substituting-components.html",
    "title": "Substituting (mocking) component | bUnit",
    "keywords": "Substituting (mocking) components bUnit makes it possible to substitute child components of a component under test with other components, e.g. mock components. This makes it possible to isolate a component under test from other components it depends on, e.g. 3rd party components. To substitute a component during a test, you must register the substitute, or a substitute factory, with the ComponentFactories collection on bUnit's BunitContext. Note This feature is only available for test projects that target .NET 5 or later. The following sections will explain how to create substitute components and how to register them with the ComponentFactories collection. Creating substitute (mock) components These are the requirements substitute components must meet: A substitute component must implement IComponent, i.e. be a Blazor component. A substitute component must have the same parameters as the original component, OR have a CaptureUnmatchedValues parameter that Blazor can pass all parameters to. If the original component is assigned to a variable in component under test, e.g. via the @ref attribute, a substitute must be assignable to the original component (inherit from it). Most popular mocking libraries are able to create substitute/mock components easily, based on the original component, that follow the requirement specified above. If the substitute only has to match the two first requirements, bUnit's built-in Stub<T> can be used. Finally, for complex scenarios, a hand-coded substitute component can be created. Substituting components with bUnit's Stub<T> When the component that should be substitute out is not referenced in the component under test with @ref, use bUnit's built-in \"stubbing\" capability. For example, supposed you want to test the <Foo> component and substitute out it's child component <Bar>: <Foo> <Bar /> </Foo> To stub it out, use the AddStub<T>() method: [Fact] public void Foo_Doesnt_Have_A_Bar_But_Stub() { // Register the a stub substitution. ComponentFactories.AddStub<Bar>(); // Render the component under test. RenderedFragment cut = Render(@<Foo />); // Verify that the Bar component has // been substituted in the render tree. Assert.False(cut.HasComponent<Bar>()); Assert.True(cut.HasComponent<Stub<Bar>>()); } It is also possible to specify a base type/component for the component you want to substitute. For example, if <Bar> inherits from <BarBase>, you can specify <BarBase> and all components that inherit from <BarBase> will be substituted. ComponentFactories.AddStub<BarBase>(); To add substitute markup to the output, pass it in one of the following ways: // Add the markup specified in the string to the rendered output // instead of that from <Bar>. ComponentFactories.AddStub<Bar>(\"<div>NOT FROM BAR</div>\"); // Add the markup specified in the render fragment to the rendered // output instead of that from <Bar>. ComponentFactories.AddStub<Bar>(@<div>NOT FROM BAR</div>); It is also possible to access the parameter that is passed to the substituted component, both when specifying alternative render output or when verifying the correct parameters was passed to the substituted component. For example, suppose <Foo> has a parameter named Baz: // Add the markup specified in the template function to the rendered output // instead of that from <Bar>. ComponentFactories.AddStub<Bar>(parameters => $\"<div>{parameters.Get(x => Baz)}</div>\"); // Add the markup produced by the render template to the rendered // output instead of that from <Bar>. ComponentFactories.AddStub<Bar>(parameters => @<div>@(parameters.Get(x => Baz))</div>); To verify that the expected value was passed to the Baz parameter of <Foo>, first find the substituted component in the render tree using the FindComponent/FindComponents methods, and then inspect the Parameters property. E.g.: [Fact] public void Foo_Doesnt_Have_A_Bar_But_Stub() { ComponentFactories.AddStub<Bar>(); RenderedFragment cut = Render(@<Foo />); // Find the stubbed component in the render tree RenderedComponent<Stub<Bar>> barStub = cut.FindComponent<Stub<Bar>>(); // Access parameters passed to it through the stubbed components // Parameters property, using the selector to pick out the parameter. var valuePassedToBaz = barStub.Instance.Parameters.Get(x => x.Baz); // assert valuePassedToBaz is as expected... } Dynamic matching components to stub To stub more than one component, e.g. all components from a 3rd party component library, pass a Predicate<Type> to the AddStub method, that returns true for all components that should be stubbed. For example: // Stub all components of type `Bar` ComponentFactories.AddStub(type => type == typeof(Bar)); // Stub all components in the Third.Party.Lib namespace ComponentFactories.AddStub(type => type.Namespace == \"Third.Party.Lib\"); It is also possible to specify replacement markup or a RenderFragment for components substituted using the \"component predicate\" method: // Add the markup specified in the string to the rendered output // instead of the components that match the predicate, ComponentFactories.AddStub(type => type.Namespace == \"Third.Party.Lib\", \"<div>NOT FROM BAR</div>\"); // Add the markup produced by the render fragment to the rendered // output instead of the components that match the predicate. ComponentFactories.AddStub(type => type.Namespace == \"Third.Party.Lib\", @<div>NOT FROM BAR</div>); Creating a mock component with mocking libraries To get more control over the substituted component or when having a reference to it in the component under test, use a mock created by a mocking library. Mocking libraries usually offer options of setting up expectations and specify responses to calls made to their methods and properties, as long as these are virtual. Tip To learn how to configure a mock object, consult your favorite mocking frameworks documentation. Mocking limitations Since the standard life-cycle methods in Blazor are all virtual, i.e. OnInitialized or OnAfterRender, etc., components in Blazor are generally very mock friendly. However, if a mocked component has a constructor, field or property initializers, or implements Dispose/DisposeAsync, these will usually not be overridable by the mocking framework and will run when the component is instantiated and disposed. If that is undesirable, consider creating a wrapper component around the component you wish to mock, or, if you own the component, avoid using a constructor and make use of virtual where ever possible. Mocking examples Supposed you want to test the <Foo> component and substitute out it's child component <Bar>: <Foo> <Bar /> </Foo> Here are two examples of using the Moq and NSubstitute mocking libraries to substitute <Bar>: MOQ NSubstitute [Fact] public void Foo_Doesnt_Have_A_Bar_But_Mock() { // Register the mock instance for Bar Mock<Bar> barMock = new Mock<Bar>(); ComponentFactories.Add<Bar>(barMock.Object); // Render the component under test RenderedFragment cut = Render(@<Foo />); // Verify that the Bar component has // been substituted in the render tree RenderedComponent<Bar> bar = cut.FindComponent<Bar>(); Assert.Same(barMock.Object, bar.Instance); } Moq the exposes the mocked component instance through the Object property. [Fact] public void Foo_Doesnt_Have_A_Bar_But_Mock() { // Register the mock instance for Bar Bar barMock = Substitute.For<FancyParagraph>(); ComponentFactories.Add<Bar>(barMock); // Render the component under test RenderedFragment cut = Render(@<Foo />); // Verify that the Bar component has // been substituted in the render tree RenderedComponent<Bar> bar = cut.FindComponent<Bar>(); Assert.Same(barMock, bar.Instance); } Warning A mock instance can only be used once, i.e. can only be used substitute a single component in the render tree. To substitute more components with one Add call on ComponentFactories, pass a mock component factory in instead. See below for example. To mock multiple components of the same type, pass in a mocking component factory: MOQ NSubstitute // Register a mock component factory to replace multiple Bar components ComponentFactories.Add<Bar>(() => Mock.Of<Bar>()); // Register a mock component factory to replace multiple Bar components ComponentFactories.Add<Bar>(() => Substitute.For<FancyParagraph>())); To mock components conditionally, pass a type predicate to the add method, along with a mock component factory. The mock component factory will be passed the type to create a mock of. In the example below, an extension method is used to create a mock using Moq with reflection. The example also uses Moq's MockRepository type that makes it possible to set up the mocked components separately from when they are created. Other mocking frameworks may need similar helper method: var mockRepo = new MockRepository(MockBehavior.Loose); ComponentFactories.Add(type => type.Namespace == \"Thrid.Party.Lib\", type => mockRepo.CreateComponent(type)); And this is the extension method that can create mock components dynamically based on a type: // Extension method that can create mock components dynamically // based on a type. internal static class MockRepositoryExtensions { private static readonly MethodInfo CreateMethodInfo = typeof(MockRepository) .GetMethod(nameof(MockRepository.Create), Array.Empty<Type>()); public static IComponent CreateComponent(this MockRepository repository, Type type) { var genericCreateMethod = CreateMethodInfo.MakeGenericMethod(type); var mock = (Mock)genericCreateMethod.Invoke(repository, null); return (IComponent)mock.Object; } } Shallow rendering A popular technique in JavaScript-based frontend testing is \"shallow rendering\". \"Shallow rendering lets you render a component \"one level deep\" and assert facts about what its render method returns, without worrying about the behavior of child components, which are not instantiated or rendered\". -- React.js docs. This is possible in bUnit as well, using the type predicate technique discussed above. For example, to shallow render <Foo> using the built-in stub in bUnit, do the following: ComponentFactories.AddStub(type => type != typeof(Foo)); This will tell bUnit to stub out all components in the render tree that is NOT <Foo>. This can also be achieved using a mocking framework. See the example in the previous section above for how to dynamically create component mocks using Moq."
  },
  "docs/test-doubles/auth.html": {
    "href": "docs/test-doubles/auth.html",
    "title": "Adding authentication and authorization | bUnit",
    "keywords": "Adding authentication and authorization bUnit comes with test-specific implementations of Blazor's authentication and authorization types, making it easy to test components that use Blazor's <AuthorizeView>, <CascadingAuthenticationState> and <AuthorizeRouteView> components, as well as the AuthenticationStateProvider type. The test implementation of Blazor's authentication and authorization can be put into the following states: Authenticating Unauthenticated and unauthorized Authenticated and unauthorized Authenticated and authorized Authenticated and authorized with one or more roles, claims, and/or policies bUnit's authentication and authorization implementation is easily available by calling AddAuthorization() on a test context. This adds the necessary services to the Services collection and the CascadingAuthenticationState component to the root render tree. The method returns an instance of the BunitAuthorizationContext type that allows you to control the authentication and authorization state for a test. Note If your test class inherits directly from bUnit's BunitContext then you need to call the AddAuthorization() method on this, since AddAuthorization() is an extension method, otherwise it wont be available. E.g.: AddAuthorization(). The following sections show how to set each of these states in a test. Setting authenticating, authenticated and authorized states The examples in the following sections will use the <UserInfo> component listed below. This uses an injected AuthenticationStateProvider service and <CascadingAuthenticationState> and <AuthorizeView> components to show the user name when a user is authenticated. It also shows the authorization state when the authenticated user is authorized. @using Microsoft.AspNetCore.Components.Authorization @inject AuthenticationStateProvider AuthenticationStateProvider @if (isAuthenticated) { <h1>Welcome @userName</h1> } @if (!isAuthenticated) { <h1>Please log in!</h1> } <AuthorizeView> <Authorized> <p>State: Authorized</p> </Authorized> <Authorizing> <p>State: Authorizing</p> </Authorizing> <NotAuthorized> <p>State: Not authorized</p> </NotAuthorized> </AuthorizeView> @code { bool isAuthenticated = false; string userName; protected override async Task OnParametersSetAsync() { var state = await AuthenticationStateProvider.GetAuthenticationStateAsync(); isAuthenticated = state.User.Identity.IsAuthenticated; userName = state.User.Identity.Name; } } The following subsections demonstrate how to set the <UserInfo> into all three authentication and authorization states. Unauthenticated and unauthorized state To set the state to unauthenticated and unauthorized, do the following: // Arrange AddAuthorization(); // Act var cut = Render<UserInfo>(); // Assert cut.MarkupMatches(@\"<h1>Please log in!</h1> <p>State: Not authorized</p>\"); The highlighted line shows how AddAuthorization() is used to add the test-specific implementation of Blazor's authentication and authorization types to the Services collection, which makes the authentication state available to other services as well as components used throughout the test that require it. After calling AddAuthorization(), the default authentication state is unauthenticated and unauthorized. Authenticating and authorizing state To set the state to authenticating and authorizing, do the following: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorizing(); // Act var cut = Render<UserInfo>(); // Assert cut.MarkupMatches(@\"<h1>Please log in!</h1> <p>State: Authorizing</p>\"); After calling AddAuthorization(), the returned BunitAuthorizationContext is used to set the authenticating and authorizing state through the SetAuthorizing() method. Authenticated and unauthorized state To set the state to authenticated and unauthorized, do the following: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorized(\"TEST USER\", AuthorizationState.Unauthorized); // Act var cut = Render<UserInfo>(); // Assert cut.MarkupMatches(@\"<h1>Welcome TEST USER</h1> <p>State: Not authorized</p>\"); After calling AddAuthorization(), the returned BunitAuthorizationContext is used to set the authenticated and unauthorized state through the SetAuthorized(string, AuthorizationState) method. Authenticated and authorized state To set the state to authenticated and authorized, do the following: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorized(\"TEST USER\"); // Act var cut = Render<UserInfo>(); // Assert cut.MarkupMatches(@\"<h1>Welcome TEST USER</h1> <p>State: Authorized</p>\"); After calling AddAuthorization(), the returned BunitAuthorizationContext is used to set the authenticated and authorized state through the SetAuthorized(string, AuthorizationState) method. Note that the second parameter, AuthorizationState, is optional, and defaults to AuthorizationState.Authorized if not specified. Setting authorization details The following section will show how to specify roles and/or policies in a test. The examples will use the <UserRights> component listed below. It uses the <AuthorizeView> component to include different content based on the roles, claims, or policies specified in each test. @using Microsoft.AspNetCore.Components.Authorization @using System.Security.Claims @using System.Globalization <AuthorizeView> <h1>Hi @context.User.Identity.Name, you have these claims and rights:</h1> </AuthorizeView> <ul> <AuthorizeView> @foreach (var claim in @context.User.FindAll(x => x.Type != ClaimTypes.Name && x.Type != ClaimTypes.Role)) { <li>@GetClaimName(claim): @claim.Value</li> } </AuthorizeView> <AuthorizeView Roles=\"superuser\"> <li>You have the role SUPER USER</li> </AuthorizeView> <AuthorizeView Roles=\"admin\"> <li>You have the role ADMIN</li> </AuthorizeView> <AuthorizeView Policy=\"content-editor\"> <li>You are a CONTENT EDITOR</li> </AuthorizeView> <AuthorizeView> @if(context.User.Identity?.AuthenticationType == \"custom-auth-type\") { <li>You have the authentication type CUSTOM AUTH TYPE</li> } </AuthorizeView> </ul> @code { private static string GetClaimName(Claim claim) { var claimType = new Uri(claim.Type); var name = claimType.Segments.Last(); return CultureInfo.InvariantCulture.TextInfo.ToTitleCase(name); } } Roles To specify one or more roles for the authenticated and authorized user, do the following: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorized(\"TEST USER\"); authContext.SetRoles(\"superuser\"); // Act var cut = Render<UserRights>(); // Assert cut.MarkupMatches(@\"<h1>Hi TEST USER, you have these claims and rights:</h1> <ul> <li>You have the role SUPER USER</li> </ul>\"); The highlighted line shows how the SetRoles(params string[]) method is used to specify a single role. To specify multiple roles, do the following: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorized(\"TEST USER\"); authContext.SetRoles(\"admin\", \"superuser\"); // Act var cut = Render<UserRights>(); // Assert cut.MarkupMatches(@\"<h1>Hi TEST USER, you have these claims and rights:</h1> <ul> <li>You have the role SUPER USER</li> <li>You have the role ADMIN</li> </ul>\"); Policies To specify one or more policies for the authenticated and authorized user, do the following: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorized(\"TEST USER\"); authContext.SetPolicies(\"content-editor\"); // Act var cut = Render<UserRights>(); // Assert cut.MarkupMatches(@\"<h1>Hi TEST USER, you have these claims and rights:</h1> <ul> <li>You are a CONTENT EDITOR</li> </ul>\"); } The highlighted line shows how the SetPolicies(params string[]) method is used to specify one policy. To specify multiple policies, do the following: // Assert Claims To specify one or more claims for the authenticated and authorized user, do the following: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorized(\"TEST USER\"); authContext.SetClaims( new Claim(ClaimTypes.Email, \"test@example.com\"), new Claim(ClaimTypes.DateOfBirth, \"01-01-1970\") ); // Act var cut = Render<UserRights>(); // Assert cut.MarkupMatches(@\"<h1>Hi TEST USER, you have these claims and rights:</h1> <ul> <li>Emailaddress: test@example.com</li> <li>Dateofbirth: 01-01-1970</li> </ul>\"); The highlighted line shows how the SetClaims(params Claim[]) method is used to pass two instances of the Claim type. Example of passing both roles, claims, and policies Lets try to combine all the possibilities shown in the previous examples into one. The following example specifies two roles, one claim, and one policy for the authenticated and authorized user: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorized(\"TEST USER\"); authContext.SetRoles(\"admin\", \"superuser\"); authContext.SetPolicies(\"content-editor\"); authContext.SetClaims(new Claim(ClaimTypes.Email, \"test@example.com\")); // Act var cut = Render<UserRights>(); // Assert cut.MarkupMatches(@\"<h1>Hi TEST USER, you have these claims and rights:</h1> <ul> <li>Emailaddress: test@example.com</li> <li>You have the role SUPER USER</li> <li>You have the role ADMIN</li> <li>You are a CONTENT EDITOR</li> </ul>\"); With this example done, all auth-related test scenarios should be covered. If you find that one is missing, please let us know in the bUnit discussion forum. Authentication types To specify a authentication type for the authenticated and authorized user, do the following: // Arrange var authContext = AddAuthorization(); authContext.SetAuthorized(\"TEST USER\"); authContext.SetAuthenticationType(\"custom-auth-type\"); // Act var cut = Render<UserRights>(); // Assert cut.MarkupMatches(@\"<h1>Hi TEST USER, you have these claims and rights:</h1> <ul> <li>You have the authentication type CUSTOM AUTH TYPE</li> </ul>\"); The highlighted line shows how the SetAuthenticationType(string) method is used to change the Identity.AuthenticationType of the user."
  },
  "docs/test-doubles/emulating-ijsruntime.html": {
    "href": "docs/test-doubles/emulating-ijsruntime.html",
    "title": "Emulating IJSRuntime | bUnit",
    "keywords": "Emulating IJSRuntime It is common for Blazor components to use IJSRuntime to call JavaScript, and since bUnit does not run JavaScript, emulating IJSRuntime is needed for components that use it. In that regard, IJSRuntime is no different than other services that a component might depend on. bUnit comes with it's own JSInterop, a tailor-made implementation of IJSRuntime that is active by default, allowing you to specify how JavaScript interop calls should be handled and what values the calls should return, and also allowing you to verify that they the calls have happened. The implementation runs in \"strict mode\", which means it will throw an exception if it receives an invocation it has not been configured to handle. See more about strict vs. loose mode in the following section. If you prefer to use the same mocking framework for all mocking in your tests to keep things consistent, general-purpose mocking frameworks like Moq, JustMock Lite, or NSubstitute all work nicely with bUnit and can be used to mock IJSRuntime. In general, registering an implementation of IJSRuntime with bUnit's Services collection replaces bUnit's implementation. The following sections show how to use the built-in implementation of IJSRuntime. Note In the beta versions of bUnit you had to explicitly add the mock JSRuntime by calling Services.AddMockJSRuntime(). That is no longer needed, and indeed doesn't work any more. Strict vs. loose mode bUnit's JSInterop can run in two modes, strict or loose: Loose mode configures the implementation to just return the default value when it receives an invocation that has not been explicitly set up, e.g. if a component calls InvokeAsync<int>(...) the mock will simply return default(int) back to it immediately. Strict mode configures the implementation to throw an exception if it is invoked with a method call it has not been set up to handle explicitly. This is useful if you want to ensure that a component only performs a specific set of IJSRuntime invocations. By default, the bUnit's JSInterop runs in Strict mode. To change the mode, do the following: JSInterop.Mode = JSRuntimeMode.Loose; Setting up invocations Use the Setup<TResult>(...) and SetupVoid(...) methods to configure the implementation to handle calls from the matching InvokeAsync<TResult>(...) and InvokeVoidAsync(...) methods on IJSRuntime. Use the parameterless Setup<TResult>() method to emulate any call to InvokeAsync<TResult>(...) with a given return type TResult and use the parameterless SetupVoid() to emulate any call to InvokeVoidAsync(...). When an invocation is set up through of the Setup<TResult>(...) and SetupVoid(...) methods, a JSRuntimePlannedInvocation<TResult> object is returned. This can be used to set a result or an exception, to emulate what can happen during a JavaScript interop call in Blazor. Similarly, when the parameterless Setup<TResult>() and SetupVoid() methods are used a JSRuntimeCatchAllPlannedInvocation<TResult> object is returned which can be used to set the result of invocation. Here are two examples: // Set up an invocation and specify the result value immediately JSInterop.Setup<string>(\"getPageTitle\").SetResult(\"bUnit is awesome\"); // Set up an invocation without specifying the result var plannedInvocation = JSInterop.SetupVoid(\"startAnimation\"); // ... other test code // Later in the test, mark the invocation as completed. // SetResult() is not used in this case since InvokeVoidAsync // only completes or throws, it doesnt return a value. // Any calls to InvokeVoidAsync(...) up till this point will // have received an incomplete Task which the component // is awaiting until the call to SetVoidResult() below. plannedInvocation.SetVoidResult(); Verifying invocations All calls to the InvokeAsync<TResult>(...) and InvokeVoidAsync(...) methods in bUnit's JSInterop are stored in its Invocations list, which can be inspected and asserted against. In addition to this, all planned invocations have their own Invocations lists which only contain their invocations. Invocations are represented by the JSRuntimeInvocation type, which has three properties of interest when verifying an invocation happened as expected: Identifier - the name of the function name/identifier passed to the invoke method. Arguments - a list of arguments passed to the invoke method. CancellationToken - the cancellation token passed to the invoke method (if any). To verify these, just use the assertion methods you normally use. Support for IJSInProcessRuntime and IJSUnmarshalledRuntime bUnit's IJSRuntime supports being cast to the IJSInProcessRuntime and IJSUnmarshalledRuntime types, just like Blazor's IJSRuntime. To set up a handler for an Invoke or InvokeUnmarshalled call, just use the regular Setup and SetupVoid methods on bUnit's JSInterop. Support for importing JavaScript Modules Since the .NET 5 release of Blazor, it has been possible to import JavaScript modules directly from components. This is supported by bUnit's JSInterop through the SetupModule methods, that sets up calls to InvokeAsync<IJSObjectReference>. The SetupModule methods return a module JSInterop, which can be configured to handle JavaScript calls using the Setup and SetupVoid methods. For example, to configure bUnit's JSInterop to handle an import of the JavaScript module hello.js, and a call to the function world() in that model, do the following: var moduleInterop = JSInterop.SetupModule(\"hello.js\"); moduleInterop.SetupVoid(\"world\"); When testing methods that return an IJSObjectReference, such as await JsRuntime.InvokeAsync<IJSObjectReference>(\"SomeModule.GetInstance\"), the same process can be used with the identifier associated with the interoperation, configuring the IJSObjectReference in the same manner as a module. var objectReference = JSInterop.SetupModule(matcher => matcher.Identifier == \"SomeModule.GetInstance\"); objectReference.SetupVoid(\"world\"); Module Interop Mode By default, a module Interop inherits the Mode setting from the root JSInterop in bUnit. However, you can override it explicitly and have it in a different mode from another module's Interop or the root JSInterop. Just set the Mode property, e.g.: var moduleInterop = JSInterop.SetupModule(\"hello.js\"); moduleInterop.Mode = JSRuntimeMode.Loose; Support for IJSInProcessObjectReference and IJSUnmarshalledObjectReference bUnit's IJSObjectReference supports being cast to the IJSInProcessObjectReference and IJSUnmarshalledObjectReference types, just like Blazor's IJSObjectReference. To set up a handler for an Invoke or InvokeUnmarshalled call, just use the regular Setup and SetupVoid methods on bUnit's JSInterop. First-party JSInterop component emulation Blazor comes out of the box with a few components that require a working JSInterop. bUnit's JSInterop is setup to emulate the JavaScript interactions of those components. The following sections describe how the interaction is emulated for the supported components. JSInterop emulation The <Virtualize> component requires JavaScript to notify it about the available screen space it is being rendered to, and also when the users scrolls the viewport, to trigger the loading of new data. bUnit emulates this interaction by telling the <Virtualize> component that the viewport is 1,000,000,000 pixels large. That should ensure that all items are loaded, which makes sense in a testing scenario. To test the <Placeholder> template of the <Virtualize> component, create an items provider that doesn't return all items when queried. FocusAsync JSInterop emulation Support for the FocusAsync method on ElementReference in Blazor's .NET 5 release works by simply registering the invocations, which can then be verified to have occurred. To verify that the FocusAsync has been called in the <ClickToFocus> component: <input @ref=\"exampleInput\" /> <button @onclick=\"ChangeFocus\">Focus the Input Element</button> @code { private ElementReference exampleInput; private async Task ChangeFocus() { await exampleInput.FocusAsync(); } } Do the following: var cut = Render<ClickToFocus>(); var inputElement = cut.Find(\"input\"); cut.Find(\"button\").Click(); // Triggers onclick handler that sets focus of input element JSInterop.VerifyFocusAsyncInvoke() // Verifies that a FocusAsync call has happened .Arguments[0] // gets the first argument passed to the FocusAsync method .ShouldBeElementReferenceTo(inputElement); // verify that it is an element reference to the input element. Support for IJSInProcessRuntime and IJSUnmarshalledRuntime bUnit's IJSRuntime supports being cast to the IJSInProcessRuntime and IJSUnmarshalledRuntime types, just like Blazor's IJSRuntime. To set up a handler for Invoke and InvokeUnmarshalled calls, just use the regular Setup and SetupVoid methods on bUnit's JSInterop."
  },
  "docs/test-doubles/fake-webassemblyhostenvironment.html": {
    "href": "docs/test-doubles/fake-webassemblyhostenvironment.html",
    "title": "Adding IWebAssemblyHostEnvironment | bUnit",
    "keywords": "Adding IWebAssemblyHostEnvironment bUnit has itws own implementation of Blazor's IWebAssemblyHostEnvironment built-in, which is added by default to bUnit's BunitContext.Services service provider. That means nothing special is needed to test components that depend on IWebAssemblyHostEnvironment, as it is already available by default. Out of the box, the implementation has its Environment property set to production, and its BaseAddress set to /. Setting Environment and BaseAddress Lets look at a few examples of how to set the two IWebAssemblyHostEnvironment properties Environment and BaseAddress via the built-in object. In the examples, we'll use the following <HelloWorld> component: @inject IWebAssemblyHostEnvironment HostEnvironment <p id=\"message\"> Hello @(HostEnvironment.IsDevelopment() ? \"Developers\" : \"World\"). </p> <p id=\"address\"> The base URL is: @HostEnvironment.BaseAddress </p> To verify that the <HelloWorld> component correctly says hello to the developers, do the following: // Arrange var hostEnvironment = Services.GetRequiredService<BunitWebAssemblyHostEnvironment>(); // Sets the environment to \"Development\". There are two other helper // methods available as well, SetEnvironmentToProduction() and // set SetEnvironmentToStaging(), or environment can also be changed // directly through the hostEnvironment.Environment property. hostEnvironment.SetEnvironmentToDevelopment(); var cut = Render<SimpleUsingWebAssemblyHostEnvironment>(); // Assert - inspects markup to verify the message cut.Find(\"#message\").MarkupMatches($\"<p>Hello Developers.</p>\"); To verify that the <HelloWorld> component correctly uses the current BaseAddress, do the following: // Arrange var hostEnvironment = Services.GetRequiredService<BunitWebAssemblyHostEnvironment>(); // Sets a new base address directly on the BaseAddress property. hostEnvironment.BaseAddress = \"myBaseUrl/\"; // Act var cut = Render<SimpleUsingWebAssemblyHostEnvironment>(); // Assert - inspect markup to verify that the BaseAddress is used correctly. cut.Find(\"#address\").MarkupMatches($\"<p>The base URL is: myBaseUrl/</p>\");"
  },
  "docs/test-doubles/index.html": {
    "href": "docs/test-doubles/index.html",
    "title": "Mocking and faking component dependencies | bUnit",
    "keywords": "Mocking or faking component dependencies Mocking or faking a component under test's dependencies (services) can be the difference between being able to write a stable test that is easy to understand, and the opposite. bUnit does not have any particular preferences when it comes to mocking frameworks; all the usual suspects will work with bUnit. For example, Moq, JustMock and NSubstitute all work well with bUnit, so pick the one you are the most comfortable with and use it. bUnit does, however, come with a few specially crafted test doubles for some of Blazors built-in services. These are designed to make it easy to write tests of components that uses these services. More are planned for the future too. The built-in test doubles are described on the following pages: Adding authentication and authorization Emulating IJSRuntime Mocking HttpClient Adding persistent component state Adding NavigationManager Adding IWebAssemblyHostEnvironment Uploading files to the InputFile component"
  },
  "docs/test-doubles/input-file.html": {
    "href": "docs/test-doubles/input-file.html",
    "title": "Uploading files to the InputFile component | bUnit",
    "keywords": "Uploading files to the InputFile component bUnit comes with integrated support for the InputFile component and makes it easy to simulate uploading files. To upload a file, first find the InputFile component in the component under test. Afterward, call the method UploadFile: // Create an InputFileContent with string content InputFileContent fileToUpload = InputFileContent.CreateFromText(\"Text content\", \"Filename.txt\"); // Render the component under test which contains the InputFile component as a child component RenderedComponent<ComponentUnderTest> cut = Render<ComponentUnderTest>(); // Find the InputFile component RenderedComponent<InputFile> inputFile = cut.FindComponent<InputFile>(); // Upload the file to upload to the InputFile component inputFile.UploadFile(fileToUpload); // Assertions... To upload binary content, create an InputFileContent with the InputFileContent.CreateFromBinary() method. Known limitations bUnit's support for the InputFile component is limited when uploading and resizing images (using the provided stream). <InputFile OnChange=\"Upload\" /> <img src=\"@imageBase64\"> @code { private string imageBase64 = string.Empty; private async Task Upload(InputFileChangeEventArgs args) { var file = args.File; var preview = await file.RequestImageFileAsync(\"image/png\", 100, 100); await using var stream = preview.OpenReadStream(); var buffer = new byte[stream.Length]; await using var memoryStream = new MemoryStream(buffer); await stream.CopyToAsync(memoryStream); var base64 = Convert.ToBase64String(buffer); imageBase64 = $\"data:image/png;base64,{base64}\"; } } When using the RequestImageFileAsync method, the UploadFiles method will not be able to upload the file inside a test. Blazor has some internal checks, bUnit can not overcome easily. So the following test will fail: [Fact] public void UploadFileTest() { var cut = Render<ComponentThatUsesInputFile>(); cut.FindComponent<InputFile>().UploadFiles(InputFileContent.CreateFromBinary([1,2], \"test.png\")); cut.Find(\"img\").GetAttribute(\"src\").Should().NotBeNullOrEmpty(); // Will fail Renderer.UnhandledException.Should().BeNull(); // Will fail } To work around this limitation, refactoring the logic into a service that is injected into the component and then mocking the service in the test is a possible solution."
  },
  "docs/test-doubles/mocking-httpclient.html": {
    "href": "docs/test-doubles/mocking-httpclient.html",
    "title": "Mocking HttpClient | bUnit",
    "keywords": "Mocking HttpClient Mocking the HttpClient service in .NET Core is a bit more cumbersome than interface-based services like IJSRuntime. There is currently no built-in mock for HttpClient in bUnit, but with the use of RichardSzalay.MockHttp we can easily add one that works with bUnit. To use RichardSzalay.MockHttp, add the following package reference to your test project's .csproj file: <PackageReference Include=\"RichardSzalay.MockHttp\" Version=\"6.0.0\" /> To make it easier to work with RichardSzalay.MockHttp, add the following extension class to your test project. It makes it easier to add the HttpClient mock to bUnit's test context's Services collection, and configure responses to requests: using Bunit; using Microsoft.Extensions.DependencyInjection; using RichardSzalay.MockHttp; using System; using System.Net; using System.Net.Http; using System.Net.Http.Headers; using System.Text.Json; public static class MockHttpClientBunitHelpers { public static MockHttpMessageHandler AddMockHttpClient(this BunitServiceProvider services) { var mockHttpHandler = new MockHttpMessageHandler(); var httpClient = mockHttpHandler.ToHttpClient(); httpClient.BaseAddress = new Uri(\"http://localhost\"); services.AddSingleton<HttpClient>(httpClient); return mockHttpHandler; } public static MockedRequest RespondJson<T>(this MockedRequest request, T content) { request.Respond(req => { var response = new HttpResponseMessage(HttpStatusCode.OK); response.Content = new StringContent(JsonSerializer.Serialize(content)); response.Content.Headers.ContentType = new MediaTypeHeaderValue(\"application/json\"); return response; }); return request; } public static MockedRequest RespondJson<T>(this MockedRequest request, Func<T> contentProvider) { request.Respond(req => { var response = new HttpResponseMessage(HttpStatusCode.OK); response.Content = new StringContent(JsonSerializer.Serialize(contentProvider())); response.Content.Headers.ContentType = new MediaTypeHeaderValue(\"application/json\"); return response; }); return request; } } With the helper methods in place, you can do the following in your tests: var mock = Services.AddMockHttpClient(); mock.When(\"/getData\").RespondJson(new List<Data>{ ... }); This registers the mock HttpClient in bUnit's test context's Services collection, and then tells the mock that when a request is received for /getData, it should respond with the new List<Data>{ ... }, serialized as JSON. Tip You can add additional RespondXXX methods to the MockHttpClientBunitHelpers class to fit your testing needs."
  },
  "docs/test-doubles/mocking-localizer.html": {
    "href": "docs/test-doubles/mocking-localizer.html",
    "title": "Mocking Localization via IStringLocalizer | bUnit",
    "keywords": "There are just two steps. First in your setup add the following: BunitContext.Services.AddLocalization(); Then in your test code, when you need the localized string to compare, you write the following: var localizer = ctx.Services.GetService<IStringLocalizer<SharedStrings>>(); Where SharedStrings.cs (you can name this anything you want) that has the resource files such as `SharedStrings.en.resx`"
  },
  "docs/test-doubles/navigation-manager.html": {
    "href": "docs/test-doubles/navigation-manager.html",
    "title": "Adding NavigationManager | bUnit",
    "keywords": "Adding NavigationManager bUnit has its own version of Blazor's NavigationManager built-in, which is added by default to bUnit's BunitContext.Services service provider. That means nothing special is needed to test components that depend on NavigationManager, as it is already available by default. Verify NavigationManager interactions Lets look at a few examples that show how to verify that a component correctly interacts with the NavigationManager in various ways. In the examples, we'll use the following <PrintCurrentUrl> component: @implements IDisposable @inject NavigationManager NavMan <button @onclick=\"() => NavMan.NavigateTo(GoToUrl)\"></button> <p>@url</p> @code { private string url; [Parameter] public string GoToUrl { get; set; } = string.Empty; protected override void OnInitialized() => NavMan.LocationChanged += OnLocationChanged; public void Dispose() => NavMan.LocationChanged -= OnLocationChanged; private void OnLocationChanged(object? sender, LocationChangedEventArgs e) { url = e.Location; StateHasChanged(); } } To verify that the <PrintCurrentUrl> component correctly listens to location changes, do the following: // Arrange var navMan = Services.GetRequiredService<BunitNavigationManager>(); var cut = Render<PrintCurrentUrl>(); // Act - trigger a navigation change navMan.NavigateTo(\"newUrl\"); // Assert - inspects markup to verify the location change is reflected there cut.Find(\"p\").MarkupMatches($\"<p>{navMan.BaseUri}newUrl</p>\"); To verify that the <PrintCurrentUrl> component correctly calls NavigateTo when it's button is clicked, do the following: // Arrange var cut = Render<PrintCurrentUrl>(parameters => parameters .Add(p => p.GoToUrl, \"http://localhost/foo\")); // Act - trigger a location change by clicking the button cut.Find(\"button\").Click(); // Assert - inspect the navigation manager to see if its Uri has been updated. var navMan = Services.GetRequiredService<BunitNavigationManager>(); Assert.Equal(\"http://localhost/foo\", navMan.Uri); If a component issues multiple NavigateTo calls, then it is possible to inspect the navigation history by accessing the History property. It's a stack based structure, meaning the latest navigations will be first in the collection at index 0. Asserting that navigation was prevented with the NavigationLock component The NavigationLock component, which was introduced with .NET 7, gives the possibility to intercept the navigation and can even prevent it. bUnit will always create a history entry for prevented or even failed interceptions. This gets reflected in the NavigationHistory property. A component can look like this: @inject NavigationManager NavigationManager <button @onclick=\"(() => NavigationManager.NavigateTo(\"/counter\"))\">Counter</button> <NavigationLock OnBeforeInternalNavigation=\"InterceptNavigation\"></NavigationLock> @code { private void InterceptNavigation(LocationChangingContext context) { context.PreventNavigation(); } } A typical test, which asserts that the navigation got prevented, would look like this: var navMan = Services.GetRequiredService<BunitNavigationManager>(); var cut = Render<InterceptComponent>(); cut.Find(\"button\").Click(); // Assert that the navigation was prevented var navigationHistory = navMan.History.Single(); Assert.Equal(NavigationState.Prevented, navigationHistory.NavigationState); Simulate preventing navigation from a <a href> with the NavigationLock component As <a href> navigation is not natively supported in bUnit, the NavigationManager can be used to simulate the exact behavior. <a href=\"/counter\">Counter</a> <NavigationLock OnBeforeInternalNavigation=\"InterceptNavigation\"></NavigationLock> @code { private void InterceptNavigation(LocationChangingContext context) { throw new Exception(); } } The test utilizes the NavigationManager itself to achieve the same: var navMan = Services.GetRequiredService<BunitNavigationManager>(); var cut = Render<InterceptAHRefComponent>(); navMan.NavigateTo(\"/counter\"); // Assert that the navigation was prevented var navigationHistory = navMan.History.Single(); Assert.Equal(NavigationState.Faulted, navigationHistory.NavigationState); Assert.NotNull(navigationHistory.Exception); Getting the result of NavigationManager.NavigateToLogin NavigationManager.NavigateToLogin is a function, which was introduced with .NET 7, which allows to login dynamically. The function can also retrieve an InteractiveRequestOptions object, which can hold additional parameter. InteractiveRequestOptions requestOptions = new() { Interaction = InteractionType.SignIn, ReturnUrl = NavigationManager.Uri, }; requestOptions.TryAddAdditionalParameter(\"prompt\", \"login\"); NavigationManager.NavigateToLogin(\"authentication/login\", requestOptions); A test could look like this: var navigationManager = Services.GetRequiredService<BunitNavigationManager>(); ActionToTriggerTheNavigationManager(); // This helper method retrieves the InteractiveRequestOptions object var requestOptions = navigationManager.History.Last().StateFromJson<InteractiveRequestOptions>(); Asser.NotNull(requestOptions); Assert.Equal(requestOptions.Interaction, InteractionType.SignIn); options.TryGetAdditionalParameter(\"prompt\", out string prompt); Assert.Equal(prompt, \"login\");"
  },
  "docs/test-doubles/persistentcomponentstate.html": {
    "href": "docs/test-doubles/persistentcomponentstate.html",
    "title": "Adding persistent component state | bUnit",
    "keywords": "Adding persistent component state bUnit comes with its own version of the PersistentComponentState type in Blazor that makes it possible to test components that use the type. Using the PersistentComponentState To use the PersistentComponentState in bUnit, call the AddBunitPersistentComponentState extension method on BunitContext: var state = AddBunitPersistentComponentState(); Calling AddBunitPersistentComponentState returns a BunitPersistentComponentState type, which has three methods; one to persist data, one to get persisted data, and one that triggers any \"OnPersisting\" callbacks added to the PersistentComponentState. To add data to the PersistentComponentState before running a test, i.e. to verify that a component uses the persisted state, use the Persist method: var state = AddBunitPersistentComponentState(); var key = \"STATE KEY\"; var data = ...; // data to persist state.Persist(key, data); // render component To trigger a callback registered with the PersistentComponentState.RegisterOnPersisting method, use the TriggerOnPersisting method on BunitPersistentComponentState: var state = AddBunitPersistentComponentState(); // render component state.TriggerOnPersisting(); To check if data has been persisted, use the TryTake method: var state = AddBunitPersistentComponentState(); var key = \"STATE KEY\"; // render component, call TriggerOnPersisting bool foundState = state.TryTake<string>(key, out var data); The following section has a complete example. Example - testing the <FetchData> component In this example, lets test the following <FetchData> component that use PersistentComponentState: @page \"/fetchdata\" @inject PersistentComponentState State @foreach (var f in Forecasts) { <p>@f.Temperature</p> } @code { private WeatherForecast[] Forecasts { get; set; } protected override async Task OnInitializedAsync() { State.RegisterOnPersisting(PersistForecasts); if (!State.TryTakeFromJson<WeatherForecast[]>(\"weather-data\", out var forecasts)) { forecasts = await CreateForecastsAsync(); } Forecasts = forecasts; } private Task PersistForecasts() { State.PersistAsJson(\"weather-data\", Forecasts); return Task.CompletedTask; } // Emulates calling an API or database to get forecasts private Task<WeatherForecast[]> CreateForecastsAsync() => new WeatherForecast[] { ... }; } To test that the <FetchData> component uses persisted weather data instead of downloading (generating) it again with the CreateForecastsAsync method, use the Persist method on the BunitPersistentComponentState type: // Arrange var state = AddBunitPersistentComponentState(); // Persist a single weather forecast with a temperature of 42 state.Persist(\"weather-data\", new [] { new WeatherForecast { Temperature = 42 } }); // Act var cut = Render<FetchData>(); // Assert - verify that the persisted forecast was rendered out cut.MarkupMatches(\"<p>42</p>\"); To test that the <FetchData> component correctly persists weather data when its OnPersisting callback is triggered, do the following: // Arrange var state = AddBunitPersistentComponentState(); var cut = Render<FetchData>(); // Act - trigger the FetchData components PersistForecasts method state.TriggerOnPersisting(); // Assert that state was saved and there is a non-empty forecast array returned var didSaveState = state.TryTake<WeatherForecast[]>(\"weather-data\", out var savedState); Assert.IsTrue(didSaveState); Assert.NotEmpty(savedState);"
  },
  "docs/verification/async-assertion.html": {
    "href": "docs/verification/async-assertion.html",
    "title": "Assertion of asynchronous changes | bUnit",
    "keywords": "Assertion of asynchronous changes A test can fail if a component performs asynchronous renders. This may be due to a reason such as waiting for an asynchronous operation to complete before continuing its render life-cycle . For example, if a component is waiting for an async web service to return data to it in the OnInitializedAsync() life-cycle method before rendering it to the render tree. You need to handle this specifically in your tests because tests execute in the test framework's synchronization context and the test renderer executes renders in its own synchronization context. If you do not, you will likely experience tests that sometimes pass, and sometimes fail. bUnit comes with two methods that help to deal with this issue: the WaitForAssertion() method covered on this page, and the WaitForState() method covered on the Awaiting an asynchronous state change in a component under test page. Let's start by taking a look at the WaitForAssertion method in more detail. Waiting for assertion to pass using WaitForAssertion The WaitForAssertion(Action, TimeSpan?) method can be used to block and wait in a test method until the provided assert action does not throw an exception, or until the timeout is reached (the default timeout is one second). Note The WaitForAssertion() method will try the assert action passed to it when the WaitForAssertion() method is called and every time the component under test renders. Let's look at an example. Consider the following <AsyncData> component, which awaits an async TextService in its OnInitializedAsync() life-cycle method. When the service returns the data, the component will automatically re-render to update its rendered markup. <p>@text</p> @code { string text = string.Empty; [Parameter] public Task<string> TextService { get; set; } protected override async Task OnInitializedAsync() { text = await TextService; } } To test the <AsyncData> component, do the following: // Arrange var textService = new TaskCompletionSource<string>(); var cut = Render<AsyncData>(parameters => parameters .Add(p => p.TextService, textService.Task) ); // Act - set the awaited result from the text service textService.SetResult(\"Hello World\"); // Wait for assertion to pass cut.WaitForAssertion(() => cut.MarkupMatches(\"<p>Hello World</p>\")); This is what happens in the test: The test uses a TaskCompletionSource<string> to simulate an async web service. In the second highlighted line, the result is provided to the component through the textService. This causes the component to re-render. Finally, in the third highlighted line, the WaitForAssertion() method is used to block the test until the predicate assertion action runs without throwing an exception. Controlling wait timeout The timeout, which defaults to one second, can be controlled by passing a TimeSpan as the second argument to the WaitForAssertion() method, e.g.: cut.WaitForAssertion(() => cut.MarkupMatches(\"<p>Hello World</p>\"), TimeSpan.FromSeconds(2)); If the timeout is reached, a WaitForFailedException exception is thrown with the following error message: The assertion did not pass within the timeout period. Setting the timeout to something less than one second does not make tests run faster. The WaitForAssertion() method returns as soon as it observes the predicate assertion running without throwing. So, it is generally only useful to set a different timeout than the default if the asynchronous operation takes longer than one second to complete, which should only be an issue in end-2-end or integration-testing scenarios."
  },
  "docs/verification/index.html": {
    "href": "docs/verification/index.html",
    "title": "Verifying output from a component under test | bUnit",
    "keywords": "Verifying output from a component under test This section covers the different ways to verify the result of a test scenario: Verifying markup from a component: This covers the different ways bUnit enables verification and assertions against the rendered markup from a component. Verifying the state of a component under test: This covers how to inspect an instance of the component under test. Customizing the semantic HTML comparison: This covers how to customize the semantic HTML/markup comparer included in bUnit for more stable tests. Assertion of asynchronous changes: This covers how to create stable tests in an asynchronous world."
  },
  "docs/verification/semantic-html-comparison.html": {
    "href": "docs/verification/semantic-html-comparison.html",
    "title": "Customizing the semantic HTML comparison | bUnit",
    "keywords": "Customizing the semantic HTML comparison This library includes comparison and assert helpers that use the AngleSharp Diffing library to perform semantic HTML comparison. On this page we will go through how the comparison works, and what options you have to affect the comparison process. Why semantic comparison is needed for stable tests Just performing string comparison of two strings containing HTML markup can break quite easily, even if the two markup strings are semantically equivalent. Some changes that can cause a regular string comparison to fail are as follows: Formatting of markup, e.g. with extra line breaks or indentions and changes to insignificant whitespace. Reordering of attributes. The order of attributes does not matter. Reordering of classes defined in the class=\"...\" attribute. The order of classes does not matter. Change of boolean attributes to be implicit or explicit, e.g. from required=\"required\" to required. Changes to insignificant whitespace inside <style> tags. Changes to HTML comments and comments inside <style> tags. The AngleSharp Diffing library handles all those cases, so your tests are more stable. Customizing Options The AngleSharp Diffing library also allows us to customize the comparison process by adding special attributes to the \"control\" markup, i.e. the expected markup we want to use in verification. All the customization options below will match with the following markup: <header> <h1 id=\"head-1\"> Hello <em>world</em> </h1> </header> Here are the customization options you have available to you: Ignore comments (enabled by default): Comments in markup and inside <style> tags are automatically ignored and not part of the comparison process. Ignore element: Use the diff:ignore attribute to ignore an element, all its attributes and its child nodes. For example, to ignore the h1 element, do the following: <header> <h1 diff:ignore></h1> </header> Ignore attribute: To ignore an attribute during comparison, add the :ignore modifier to the attribute (no value is needed). For example, to ignore the id attribute: <header> <h1 id:ignore>Hello <em>world</em></h1> </header> Ignore children: Use the diff:ignoreChildren attribute (no value is needed) to ignore all child nodes/elements of an element. This does not include attributes. For example, to ignore all child nodes of the h1 element, do the following: <header> <h1 id=\"head-1\" diff:ignoreChildren></h1> </header> Ignore all attributes: Use the diff:ignoreAttributes attribute (no value is needed) to ignore all attributes of an element. For example: <header> <h1 diff:ignoreAttributes>Hello <em>world</em></h1> </header> Note The diff:ignoreChildren and diff:ignoreAttributes attributes can be combined to ignore all child nodes/element and attributes of an element, but still verify that the element itself exists. For example: <header> <h1 diff:ignoreChildren diff:ignoreAttributes></h1> </header> Configure whitespace handling: By default, all nodes and elements are compared using the Normalize whitespace handling option. The Normalize option will trim all text nodes and replace two or more whitespace characters with a single space character. The other options are Preserve, which will leave all whitespace unchanged, and RemoveWhitespaceNodes, which will only remove empty text nodes. To override the default option, use the diff:whitespace attribute, and pass one of the three options to it. For example: <header> <h1 id=\"head-1\" diff:whitespace=\"preserve\"> Hello <em>world</em> </h1> </header> Note The default for <pre> and <script> elements is the Preserve option. To change that, use the diff:whitespace attribute. For example: <header> <h1 id=\"head-1\" diff:whitespace=\"RemoveWhitespaceNodes\">Hello<em>world</em></pre> </header> Perform case-insensitive comparison: By default, all text comparison is case sensitive, but if you want to perform a case-insensitive comparison of text inside elements or attributes, use the diff:ignoreCase attribute on elements and :ignoreCase modifier on attributes. For example, to perform a case insensitive comparison of the text in the following h1 element , do the following: <header> <h1 id=\"head-1\" diff:ignoreCase>HeLLo <em>world</em></h1> </header> To perform case insensitive comparison of the text inside the id attribute, do the following: <header> <h1 id:ignoreCase=\"HeAD-1\">Hello <em>world</em></h1> </header> Use RegEx during comparison: To use a regular expression when comparing the text inside an element or inside an attribute, use the diff:regex attribute on elements and the :regex modifier on attributes. For example, to use a regular expression during comparison of the text in the em element, add the diff:regex attribute to the element and place the regular expression in the body of the element: <header> <h1 id=\"head-1\">Hello <em diff:regex>\\w</em></h1> </header> To use a regular expression during comparison of the text inside the id attribute, add the :regex modifier to the attribute and add the regular expression in the attribute's value: <h1 id:regex=\"head-\\d{1}\">...</h1> Note The attribute modifiers :ignoreCase and :regex can be combined, for example, as: attr:ignoreCase:regex=\"FOO-\\d{4}\" Examples Lets look at a few examples where we use the semantic comparison options listed above to modify the comparison. In tests, we have the MarkupMatches() methods we can use to perform semantic comparison of the output from a rendered component. For example, we may have a component, <Heading>, that renders the following markup: <h3 id=\"heading-1337\" required> Heading text <small class=\"text-muted mark\"> Secondary text </small> </h3> In this case, we want to verify that the markup is rendered correctly, using something such as RegEx to verify the id attribute (it might be generated) and ignoring the <small> element. In tests we can do this like so with the MarkupMatches() method: var cut = Render<Heading>(); // Assert // Here we specify expected HTML from CUT. var expectedHtml = @\"<h3 id:regex=\"\"heading-\\d{4}\"\" required> Heading text <small diff:ignore></small> </h3>\"; // Here we use the HTML diffing library to assert that the rendered HTML // from CUT is semantically the same as the expected HTML string above. cut.MarkupMatches(expectedHtml); }"
  },
  "docs/verification/verify-component-state.html": {
    "href": "docs/verification/verify-component-state.html",
    "title": "Verifying the state of a component under test | bUnit",
    "keywords": "Verifying the state of a component The instance of a component under test is available through the Instance property on the IRenderedComponent<TComponent> type. When using the BunitContext's Render<TComponent>() method, this is the type returned. In .razor based tests, using the BunitContext's Render<TComponent>(RenderFragment) method also returns an IRenderedComponent<TComponent> (as opposed to the Render(RenderFragment) method which returns the more simple IRenderedComponent<TComponent>). Note Since IRenderedComponent<TComponent> inherits from IRenderedComponent<TComponent>, all the markup verification techniques covered on the Verifying markup from a component page also apply to the IRenderedComponent<TComponent> type. Inspecting the Component Under Test The Instance property on the IRenderedComponent<TComponent> type provides access to the component under test. For example: RenderedComponent<Alert> cut = Render<Alert>(); Alert alert = cut.Instance; // Assert against <Alert /> instance Warning While it is possible to set [Parameter] and [CascadingParameter] properties directly through the Instance property on the IRenderedComponent<TComponent> type, doing so does not implicitly trigger a render and the component life-cycle methods are not called. The correct approach is to set parameters through the Render() methods. See the Triggering a render life cycle on a component page for more on this. Finding Components in the Render Tree To get the instances of components nested inside the component under test, use the FindComponent<TComponent>() and FindComponents<TComponent>() methods on the IRenderedComponent<TComponent> type. Suppose, for each task in the todo list, we have a <TodoList> component with <Task> components nested inside. In this case, the <Task> components can be found like this: var cut = Render<TodoList>(parameter => parameter .Add(p => p.Tasks, new [] { \"Task 1\", \"Task 2\" }) ); var tasks = cut.FindComponents<Task>(); Assert.Equal(2, tasks.Count); Both the FindComponent<TComponent>() and FindComponents<TComponent>() methods perform a depth-first search of the render tree, with the first method returning only the first matching component found, and the latter returning all matching components in the render tree."
  },
  "docs/verification/verify-markup.html": {
    "href": "docs/verification/verify-markup.html",
    "title": "Verifying markup from a component | bUnit",
    "keywords": "Verifying markup from a component Generally, the strategy for verifying markup produced by components depends on whether you are creating reusable component library or a single-use Blazor app component. With a reusable component library, the markup produced may be considered part of the externally observable behavior of the component, and that should thus be verified, since users of the component may depend on the markup having a specific structure. Consider using MarkupMatches and semantic comparison described below to get the best protection against regressions and good maintainability. When building components for a Blazor app, the externally observable behavior of components are how they visibly look and behave from an end-users point of view, e.g. what the user sees and interact with in a browser. In this scenario, consider use FindByLabelText and related methods described below to inspect and assert against individual elements look and feel, for a good balance between protection against regressions and maintainability. Learn more about this testing approach at https://testing-library.com. This page covers the following verification approaches: Inspecting the individual DOM nodes in the DOM tree Semantic comparison of markup Finding expected differences in markup between renders Verification of raw markup The following sections will cover each of these. Result of rendering components When a component is rendered in a test, the result is a IRenderedComponent<TComponent> or a IRenderedComponent<TComponent>. Through these, it is possible to access the rendered markup (HTML) of the component and, in the case of IRenderedComponent<TComponent>, the instance of the component. Note An IRenderedComponent<TComponent> inherits from IRenderedComponent<TComponent>. This page will only cover features of the IRenderedComponent<TComponent> type. IRenderedComponent<TComponent> is covered on the Verifying the state of a component under test page. Inspecting DOM nodes The rendered markup from a component is available as a DOM node through the Nodes property on IRenderedComponent<TComponent>. The nodes and element types comes from AngleSharp that follows the W3C DOM API specifications and gives you the same results as a state-of-the-art browsers implementation of the DOM API in JavaScript. Besides the official DOM API, AngleSharp and bUnit add some useful extension methods on top. This makes working with DOM nodes convenient. Finding DOM elements bUnit supports multiple different ways of searching and querying the rendered HTML elements: FindByLabelText(string labelText) that takes a text string used to label an input element and returns an IElement as output, or throws an exception if none are found (this is included in the experimental library bunit.web.query). Use this method when possible compared to the generic Find and FindAll methods. Find(string cssSelector) takes a \"CSS selector\" as input and returns an IElement as output, or throws an exception if none are found. FindAll(string cssSelector) takes a \"CSS selector\" as input and returns a list of IElement elements. Let's see some examples of using the Find(string cssSelector) and FindAll(string cssSelector) methods to query the <FancyTable> component listed below. <table> <caption>Lorem lipsum captium</caption> <tbody> <tr> <td style=\"white-space:nowrap\">Foo</td> <td>Bar</td> </tr> <tr> <td style=\"white-space:nowrap\">Baz</td> <td>Boo</td> </tr> </tbody> </table> To find the <caption> element and the first <td> elements in each row, do the following: var tableCaption = cut.Find(\"caption\"); var tableCells = cut.FindAll(\"td:first-child\"); Assert.Empty(tableCaption.Attributes); Once you have one or more elements, you verify against them, such as by inspecting their properties through the DOM API. For example: Assert.All(tableCells, td => td.HasAttribute(\"style\")); } } Auto-refreshing Find() queries An element found with the Find(string cssSelector) method will be updated if the component it came from is re-rendered. However, that does not apply to elements that are found by traversing the DOM tree via the Nodes property on IRenderedComponent<TComponent>, for example, as those nodes do not know when their root component is re-rendered. Consequently, they dont know when they should be updated. As a result of this, it is always recommended to use the Find(string cssSelector) method when searching for a single element. Alternatively, always reissue the query whenever you need the element. Semantic comparison of markup Working with raw markup only works well with very simple output, but even then you have to sanitize it to get stable tests. A much better approach is to use the semantic HTML comparer that comes with bUnit. How does the semantic HTML comparer work? The comparer takes two HTML fragments (e.g. in the form of a C# string) as input, and returns true if both HTML fragments result in the same visual rendered output in a web browser. If not, it returns false. For example, a web browser will render this HTML: <span>Foo Bar</span> This will be done in exactly the same way as this HTML: <span> Foo Bar </span> This is why it makes sense to allow tests to pass, even when the rendered HTML markup is not entirely identical to the expected HTML from a normal string comparer's perspective. bUnit's semantic HTML comparer safely ignores things like insignificant whitespace and the order of attributes on elements, as well as many more things. This leads to much more stable tests, as - for example - a reformatted component doesn't break its tests because of insignificant whitespace changes. More details of the semantic comparer can be found on the Customizing the semantic HTML comparison page. The MarkupMatches() method The HTML comparer can be easily accessed through MarkupMatches() extension methods, available in places that represent HTML fragments in bUnit, i.e. on IRenderedComponent<TComponent> and the INode and INodeList types. In the following examples, the <Heading> component listed below will be used as the component under test. <h3 id=\"heading-1337\" required> Heading text <small class=\"text-muted mark\"> Secondary text </small> </h3> To use the MarkupMatches() method to perform a semantic comparison of the output of the <Heading> component through its IRenderedComponent<TComponent>, do the following: var cut = Render<Heading>(); cut.MarkupMatches(@\"<h3 id=\"\"heading-1337\"\" required> Heading text <small class=\"\"mark text-muted\"\">Secondary text</small> </h3>\"); The highlighted line shows the call to the MarkupMatches() method. This test passes even though the insignificant whitespace is not exactly the same between the expected HTML string and the raw markup produced by the <Heading> component. It even works when the CSS class list is not in the same order on the <small> element. The MarkupMatches() method is also available on INode and INodeList types, for example: var cut = Render<Heading>(); var smallElm = cut.Find(\"small\"); smallElm.MarkupMatches(@\"<small class=\"\"mark text-muted\"\">Secondary text</small>\"); Here we use the Find(string cssSelector) method to find the <small> element, and only verify it and its content and attributes. Tip Working with Find(), FindAll(), INode and INodeList is covered later on this page. Text content can also be verified with the MarkupMatches() method, e.g. the text inside the <small> element. It has the advantage over regular string comparison in that it removes insignificant whitespace in the text automatically - even between words - where a normal string Trim() method isn't enough. For example: var cut = Render<Heading>(); var smallElmText = cut.Find(\"small\").TextContent; smallElmText.MarkupMatches(\"Secondary text\"); The semantic HTML comparer can be customized to make a test case even more stable and easier to maintain. For example, it is possible to ignore an element or attribute during comparison, or provide a regular expression to the comparer when comparing a specific element or attribute to make the comparer work with generated data. Learn more about the customization options on the Customizing the semantic HTML comparison page. Verification of raw markup To access the rendered markup of a component, just use the Markup property on IRenderedComponent<TComponent>. This holds the raw HTML from the component as a string. Warning Be aware that all indentions and whitespace in your components (.razor files) are included in the raw rendered markup, so it is often wise to normalize the markup string a little. For example, via the string Trim() method to make the tests more stable. Otherwise, a change to the formatting in your components might break the tests unnecessarily when it does not need to. To avoid these issues and others related to asserting against raw markup, use the semantic HTML comparer that comes with bUnit, described in the next section. To get the markup as a string, do the following: var renderedMarkup = cut.Markup; Assert.Equal(\"<h1>Hello world from Blazor</h1>\", renderedMarkup); } Standard string assertions can be performed against the markup string, such as checking whether it contains a value or is empty."
  },
  "index.html": {
    "href": "index.html",
    "title": "bUnit - a testing library for Blazor components | bUnit",
    "keywords": "bUnit: a testing library for Blazor components bUnit is a testing library for Blazor Components. Its goal is to make it easy to write comprehensive, stable unit tests. With bUnit, you can: Setup and define components under tests using C# or Razor syntax Verify outcomes using semantic HTML comparer Interact with and inspect components as well as trigger event handlers Pass parameters, cascading values and inject services into components under test Mock IJSRuntime, Blazor authentication and authorization, and others bUnit builds on top of existing unit testing frameworks such as xUnit, NUnit, MSTest and TUnit, which run the Blazor components tests in just the same way as any normal unit test. bUnit runs a test in milliseconds, compared to browser-based UI tests which usually take seconds to run. Go to the Documentation pages to learn more. Test example Lets write a test for the <Counter> component listed below. This comes with the standard Blazor project template which verifies that the counter corrects increments when the button is clicked: <h1>Counter</h1> <p> Current count: @currentCount </p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button> @code { int currentCount = 0; void IncrementCount() { currentCount++; } } To do this, you can carry out the following using bUnit and xUnit: @inherits BunitContext @code { [Fact] public void CounterShouldIncrementWhenClicked() { // Arrange: render the Counter.razor component var cut = Render(@<Counter />); // Act: find and click the <button> element to increment // the counter in the <p> element cut.Find(\"button\").Click(); // Assert: first find the <p> element, then verify its content cut.Find(\"p\").MarkupMatches(@<p>Current count: 1</p>); } } This test uses bUnit's test context to render the Counter component with the Render method. It then finds the button the component rendered and clicks it with the Find and Click methods. Finally, it finds the paragraph (<p>) element and verifies that it matches the expected markup passed to the MarkupMatches method. Go to the Documentation pages to learn more. NuGet downloads bUnit is available on NuGet in various incarnations. Most users should just pick the bUnit package: Name Description NuGet Download Link bUnit Includes the bUnit.core and bUnit.web packages. bUnit.template Template for bUnit test projects based on xUnit, NUnit or MSTest bUnit.generators Source code generators to minimize code setup in various situations. bUnit.web.query bUnit implementation of testing-library.com's query APIs. Sponsors A huge thank you to the sponsors of bUnit. The higher tier sponsors are: TestMu AI Contributors Shoutouts and a big thank you to all the contributors to the library, including those who raise issues, those who provide input to issues, and those who send pull requests. Want to help out? You can help in a number of ways: Provide feedback and input through issues, via Twitter or by using the bUnit Gitter chat room. Help build the library. Just pick an issue and submit pull requests. Help write documentation. Create blog posts, presentations, or video tutorials. If you do, I'll be happy to showcase them in the related section on this site. Code of conduct This project has adopted the code of conduct defined by the Contributor Covenant to clarify expected behavior in our community. For more information see the .NET Foundation Code of Conduct. .NET Foundation This project is supported by the .NET Foundation."
  }
}